{
    "coordinate_compression_def": {
        "prefix": "coordinate_compression_def",
        "body": [
            "template <typename T>",
            "struct CoordinateCompression{",
            "  map<T, int> mp;",
            "  vector<T> v;",
            "  CoordinateCompression(vector<T> &x){",
            "    v.resize(x.size());",
            "    copy(x.begin(), x.end(), v.begin());",
            "    sort(v.begin(), v.end());",
            "    v.erase(unique(v.begin(), v.end()), v.end());",
            "    for(int i = 0; i < v.size(); i++){",
            "      mp[v[i]] = i;",
            "    }",
            "  }",
            "};",
            "",
            "using CoordinateCompressionI = CoordinateCompression<int>;",
            "using CoordinateCompressionL = CoordinateCompression<long long>;",
            ""
        ]
    },
    "coordinate_compression_use": {
        "prefix": "coordinate_compression_use",
        "body": [
            "CoordinateCompressionL cl = CoordinateCompressionL(v);",
            ""
        ]
    },
    "extend_cerr_def": {
        "prefix": "extend_cerr_def",
        "body": [
            "void excerr(){",
            "  cerr << endl;",
            "}",
            "",
            "template <class Head, class... Tail>",
            "void excerr(Head&& head, Tail&&... tail){",
            "  if(sizeof...(tail) != 0)cerr << head << \" \";",
            "  else cerr << head;",
            "  excerr(forward<Tail>(tail)...);",
            "}",
            ""
        ]
    },
    "extend_cerr_use": {
        "prefix": "extend_cerr_use",
        "body": [
            "excerr(\"a\", 1, \"b\");",
            ""
        ]
    },
    "extend_cout_def": {
        "prefix": "extend_cout_def",
        "body": [
            "void excout(){",
            "  cout << endl;",
            "}",
            "",
            "template <class Head, class... Tail>",
            "void excout(Head&& head, Tail&&... tail){",
            "  if(sizeof...(tail) != 0)cout << head << \" \";",
            "  else cout << head;",
            "  excout(forward<Tail>(tail)...);",
            "}",
            ""
        ]
    },
    "extend_cout_use": {
        "prefix": "extend_cout_use",
        "body": [
            "excout(\"a\", 1, \"b\");",
            ""
        ]
    },
    "fast_moebius_def": {
        "prefix": "fast_moebius_def",
        "body": [
            "/*",
            " * f(U) = \\sum_{U\\in T}(-1)^(|T\\U|)f(T)",
            " * for f(U) = \\sum_{T\\in U}f(T), use f[j | i] -= f[j];",
            " */",
            "template <typename T>",
            "void fast_moebius(vector<T> &f){",
            "  int n = f.size();",
            "  for(int i = 1; i < n; i<<=1){",
            "    for(int j = 0; j < n; j++){",
            "      if((j & i) == 0){",
            "        f[j] -= f[j | i];",
            "      }",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "fast_moebius_use": {
        "prefix": "fast_moebius_use",
        "body": [
            "fast_moebius<ll>(g);",
            ""
        ]
    },
    "fast_zeta_def": {
        "prefix": "fast_zeta_def",
        "body": [
            "/*",
            " * f(U) = \\sum_{U\\in T}f(T)",
            " * for f(U) = \\sum_{T\\in U}f(T), use f[j | i] += f[j];",
            " */",
            "template <typename T>",
            "void fast_zeta(vector<T> &f){",
            "  int n = f.size();",
            "  for(int i = 1; i < n; i<<=1){",
            "    for(int j = 0; j < n; j++){",
            "      if((j & i) == 0){",
            "        f[j] += f[j | i];",
            "      }",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "fast_zeta_use": {
        "prefix": "fast_zeta_use",
        "body": [
            "fast_zeta<ll>(f);",
            ""
        ]
    },
    "convex_hull_trick_def": {
        "prefix": "convex_hull_trick_def",
        "body": [
            "template <typename T>",
            "struct ConvexHullTrick_ {",
            "  vector<pair<T, T> > lines;",
            "  function<bool(T l, T r)> comp;",
            "  explicit ConvexHullTrick_(function<bool(T l, T r)> comp_=[](T l, T r){return l >= r;}): comp(comp_){}",
            "  bool isnot_require(pair<T, T> l1, pair<T, T> l2, pair<T, T> l3){",
            "    if(l1 < l3)swap(l1, l3);",
            "    return (l3.second - l2.second) * (l2.first - l1.first) >= (l2.second - l1.second) * (l3.first - l2.first);",
            "  }",
            "  void add(pair<T, T> p){",
            "    while(lines.size() >= 2 && isnot_require(*(lines.end()-2), *(lines.end()-1), p))lines.pop_back();",
            "    lines.push_back(p);",
            "  }",
            "  T f(int i, T x){",
            "    return lines[i].first * x + lines[i].second;",
            "  }",
            "  T val(T x){",
            "    int ld = -1;",
            "    int rd = lines.size() - 1;",
            "    while(rd - ld > 1){",
            "      int md = (rd + ld) / 2;",
            "      if(comp(f(md, x), f(md + 1, x)))ld = md;",
            "      else rd = md;",
            "    }",
            "    return f(rd, x);",
            "  }",
            "};",
            "",
            "using ConvexHullTrickI = ConvexHullTrick_<int>;",
            "using ConvexHullTrickL = ConvexHullTrick_<long long>;",
            ""
        ]
    },
    "convex_hull_trick_use": {
        "prefix": "convex_hull_trick_use",
        "body": [
            "ConvexHullTrickL cht(comp);",
            "cht.add(make_pair(a, b));",
            "auto t = cht.val(x);",
            ""
        ]
    },
    "extgcd_def": {
        "prefix": "extgcd_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            ""
        ]
    },
    "extgcd_use": {
        "prefix": "extgcd_use",
        "body": [
            "extgcd<ll>(a, b, x, y);",
            ""
        ]
    },
    "crt_def": {
        "prefix": "crt_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template<typename T>",
            "pair<T, T> crt(vector<T> b, vector<T> m){",
            "  T r = 0, M = 1;",
            "  for(int i = 0; i < b.size(); i++){",
            "    T x, y;",
            "    T d = extgcd<T>(M, m[i], x, y);",
            "    if((b[i] - r) % d != 0)return make_pair(0, -1);",
            "    T tmp = (b[i] - r) / d * x % (m[i] / d);",
            "    r += M * tmp;",
            "    M *= m[i] / d;",
            "  }",
            "  r %= M;",
            "  if(r < 0)r += M;",
            "  return make_pair(r % M, M);",
            "}",
            ""
        ]
    },
    "crt_use": {
        "prefix": "crt_use",
        "body": [
            "P p = crt<long long, long long>(b, m);",
            ""
        ]
    },
    "modinv_def": {
        "prefix": "modinv_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template <typename T>",
            "T modinv(T a, T m){",
            "  long long x = 0, y = 0;",
            "  extgcd<long long>(a, m, x, y);",
            "  x %= m;",
            "  if(x < 0)x += m;",
            "  return x;",
            "}",
            ""
        ]
    },
    "modinv_use": {
        "prefix": "modinv_use",
        "body": [
            "modinv<ll>(x);",
            ""
        ]
    },
    "garner_def": {
        "prefix": "garner_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template <typename T>",
            "T modinv(T a, T m){",
            "  long long x = 0, y = 0;",
            "  extgcd<long long>(a, m, x, y);",
            "  x %= m;",
            "  if(x < 0)x += m;",
            "  return x;",
            "}",
            "",
            "template <typename T>",
            "long long garner(vector<T> b, vector<T> m, T MOD){",
            "  m.emplace_back(MOD);",
            "  vector<long long> coef(m.size(), 1);",
            "  vector<long long> consts(m.size(), 0);",
            "  for(int i = 0; i < b.size(); i++){",
            "    long long t = ((b[i] - consts[i]) % m[i]) * modinv<long long>(coef[i], m[i]) % m[i];",
            "    if(t < 0)t += m[i];",
            "    for(int j = i + 1; j < m.size(); j++){",
            "      consts[j] = (consts[j] + t * coef[j] % m[j]) % m[j];",
            "      coef[j] = coef[j] * m[i] % m[j];",
            "    }",
            "  }",
            "  return consts.back();",
            "}",
            ""
        ]
    },
    "garner_use": {
        "prefix": "garner_use",
        "body": [
            "garner<long long>(b, m, mod);",
            ""
        ]
    },
    "gcd_def": {
        "prefix": "gcd_def",
        "body": [
            "template<typename T>",
            "T gcd(T a, T b) {",
            "  if(a > b)return gcd(b, a);",
            "  if(a == 0)return b;",
            "  return gcd(b % a, a);",
            "}",
            ""
        ]
    },
    "gcd_use": {
        "prefix": "gcd_use",
        "body": [
            "gcd<ll>(a, b);",
            ""
        ]
    },
    "arbitrary_garner_def": {
        "prefix": "arbitrary_garner_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template <typename T>",
            "T modinv(T a, T m){",
            "  long long x = 0, y = 0;",
            "  extgcd<long long>(a, m, x, y);",
            "  x %= m;",
            "  if(x < 0)x += m;",
            "  return x;",
            "}",
            "",
            "template <typename T>",
            "long long garner(vector<T> b, vector<T> m, T MOD){",
            "  m.emplace_back(MOD);",
            "  vector<long long> coef(m.size(), 1);",
            "  vector<long long> consts(m.size(), 0);",
            "  for(int i = 0; i < b.size(); i++){",
            "    long long t = ((b[i] - consts[i]) % m[i]) * modinv<long long>(coef[i], m[i]) % m[i];",
            "    if(t < 0)t += m[i];",
            "    for(int j = i + 1; j < m.size(); j++){",
            "      consts[j] = (consts[j] + t * coef[j] % m[j]) % m[j];",
            "      coef[j] = coef[j] * m[i] % m[j];",
            "    }",
            "  }",
            "  return consts.back();",
            "}",
            "",
            "template<typename T>",
            "T gcd(T a, T b) {",
            "  if(a > b)return gcd(b, a);",
            "  if(a == 0)return b;",
            "  return gcd(b % a, a);",
            "}",
            "",
            "template <typename T>",
            "long long arbitrary_garner(vector<T> &b, vector<T> &m, T MOD){",
            "  for(int i = 0; i < b.size(); i++){",
            "    for(int j = 0; j < i; j++){",
            "      T g = gcd(m[i], m[j]);",
            "      if((b[i] - b[j]) % g != 0)return -1;",
            "",
            "      m[i] /= g, m[j] /= g;",
            "",
            "      T gi = gcd(m[i], g), gj = g / gi;",
            "",
            "      do{",
            "        g = gcd(gi, gj);",
            "        gi *= g, gj /= g;",
            "      }while(g != 1);",
            "",
            "      m[i] *= gi, m[j] *= gj;",
            "      b[i] %= m[i], b[j] %= m[j];",
            "    }",
            "  }",
            "  return garner<T>(b, m, MOD);",
            "}",
            ""
        ]
    },
    "arbitrary_garner_use": {
        "prefix": "arbitrary_garner_use",
        "body": [
            "arbitrary_garner(b, m);",
            ""
        ]
    },
    "power_def": {
        "prefix": "power_def",
        "body": [
            "template <typename T>",
            "T power(T a, T n, T mod) {",
            "  T res = 1;",
            "  T tmp = n;",
            "  T curr = a;",
            "  while(tmp){",
            "    if(tmp % 2 == 1){",
            "      res = (T)(res * curr % mod);",
            "    }",
            "    curr = (T)(curr * curr % mod);",
            "    tmp >>= 1;",
            "  }",
            "",
            "  return res;",
            "}",
            ""
        ]
    },
    "power_use": {
        "prefix": "power_use",
        "body": [
            "power<ll>(p, n);",
            ""
        ]
    },
    "factorial_def": {
        "prefix": "factorial_def",
        "body": [
            "template <typename T>",
            "T power(T a, T n, T mod) {",
            "  T res = 1;",
            "  T tmp = n;",
            "  T curr = a;",
            "  while(tmp){",
            "    if(tmp % 2 == 1){",
            "      res = (T)(res * curr % mod);",
            "    }",
            "    curr = (T)(curr * curr % mod);",
            "    tmp >>= 1;",
            "  }",
            "",
            "  return res;",
            "}",
            "",
            "struct Factorial{",
            "  int n = 0;",
            "  static const long long mod_default = 1e9 + 7;",
            "  long long MOD = mod_default;",
            "  vector<long long> fac;",
            "  vector<long long> inv_;",
            "  explicit Factorial(){}",
            "  explicit Factorial(int n, long long mod_=mod_default): n(n), MOD(mod_){",
            "    assert(MOD > 0 && n < MOD);",
            "    fac.resize(n + 1);",
            "    inv_.resize(n + 1);",
            "    calc_factorial();",
            "    calc_inv();",
            "  }",
            "  void calc_factorial(){",
            "    fac[0] = 1;",
            "    for(int i = 1; i <= n; i++){",
            "      fac[i] = i * fac[i-1] % MOD;",
            "    }",
            "  }",
            "  void calc_inv(){",
            "    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);",
            "    for(int i = n - 1; i >= 0; i--){",
            "      inv_[i] = (i + 1) * inv_[i+1] % MOD;",
            "    }",
            "  }",
            "  long long& operator[](size_t i){",
            "    if((int)i > n){",
            "      cerr << \"list index out of range\" << endl;",
            "      abort();",
            "    }",
            "    return fac[i];",
            "  }",
            "  long long inv(size_t i){",
            "    if((int)i > n){",
            "      cerr << \"list index out of range\" << endl;",
            "      abort();",
            "    }",
            "    return inv_[i];",
            "  }",
            "  long long comb(int n, int k){",
            "    if(n < 0 || k < 0 || n < k)return 0;",
            "    long long res = fac[n];",
            "    res = res * inv_[n-k] % MOD;",
            "    res = res * inv_[k] % MOD;",
            "    return res;",
            "  }",
            "  long long perm(int n, int k){",
            "    if(n < 0 || k < 0 || n < k)return 0;",
            "    long long res = fac[n];",
            "    res = res * inv_[n-k] % MOD;",
            "    return res;",
            "  }",
            "  long long h(int n, int k){",
            "    if(n == 0 && k == 0)return 1;",
            "    return comb(n + k - 1, k);",
            "  }",
            "};",
            ""
        ]
    },
    "factorial_use": {
        "prefix": "factorial_use",
        "body": [
            "Factorial fac(n, mod);",
            "fac.comb(n, k);",
            ""
        ]
    },
    "millar_rabin_def": {
        "prefix": "millar_rabin_def",
        "body": [
            "template <typename T>",
            "T power(T a, T n, T mod) {",
            "  T res = 1;",
            "  T tmp = n;",
            "  T curr = a;",
            "  while(tmp){",
            "    if(tmp % 2 == 1){",
            "      res = (T)(res * curr % mod);",
            "    }",
            "    curr = (T)(curr * curr % mod);",
            "    tmp >>= 1;",
            "  }",
            "",
            "  return res;",
            "}",
            "",
            "template <typename T>",
            "bool suspect(T a, int s, T d, T n){",
            "  T x = power<T>(a, d, n);",
            "  if(x == 1)return true;",
            "  for(int r = 0; r < s; r++){",
            "    if(x == n - 1)return true;",
            "    x = x * x % n;",
            "  }",
            "  return false;",
            "}",
            "",
            "template <typename T>",
            "bool millar_rabin(T n){",
            "  if(n <= 1 || (n > 2 && n % 2 == 0))return false;",
            "  vector<ll> test = {2, 3, 5, 7, 11, 13, 17, 19, 23};",
            "  T d = n - 1;",
            "  int s = 0;",
            "  while(d % 2 == 0)s++, d /= 2;",
            "  for(int i = 0; i < test.size() && test[i] < n; i++){",
            "    if(!suspect<T>(test[i], s, d, n))return false;",
            "  }",
            "  return true;",
            "}",
            ""
        ]
    },
    "millar_rabin_use": {
        "prefix": "millar_rabin_use",
        "body": [
            "millar_rabin(x);",
            ""
        ]
    },
    "ntt_def": {
        "prefix": "ntt_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template <typename T>",
            "T modinv(T a, T m){",
            "  long long x = 0, y = 0;",
            "  extgcd<long long>(a, m, x, y);",
            "  x %= m;",
            "  if(x < 0)x += m;",
            "  return x;",
            "}",
            "",
            "template <typename T>",
            "long long garner(vector<T> b, vector<T> m, T MOD){",
            "  m.emplace_back(MOD);",
            "  vector<long long> coef(m.size(), 1);",
            "  vector<long long> consts(m.size(), 0);",
            "  for(int i = 0; i < b.size(); i++){",
            "    long long t = ((b[i] - consts[i]) % m[i]) * modinv<long long>(coef[i], m[i]) % m[i];",
            "    if(t < 0)t += m[i];",
            "    for(int j = i + 1; j < m.size(); j++){",
            "      consts[j] = (consts[j] + t * coef[j] % m[j]) % m[j];",
            "      coef[j] = coef[j] * m[i] % m[j];",
            "    }",
            "  }",
            "  return consts.back();",
            "}",
            "",
            "template <typename T>",
            "T power(T a, T n, T mod) {",
            "  T res = 1;",
            "  T tmp = n;",
            "  T curr = a;",
            "  while(tmp){",
            "    if(tmp % 2 == 1){",
            "      res = (T)(res * curr % mod);",
            "    }",
            "    curr = (T)(curr * curr % mod);",
            "    tmp >>= 1;",
            "  }",
            "",
            "  return res;",
            "}",
            "",
            "template <int MOD, int g>",
            "struct NTT{",
            "  int get_mod(){",
            "    return MOD;",
            "  }",
            "  void _ntt(vector<long long> &f, bool inv=false){",
            "    int n = f.size(), mask = n - 1;",
            "    int h = power<long long>(g, (MOD - 1) / n, MOD);",
            "    if(inv)h = modinv(h, MOD);",
            "    vector<long long> tmp(n);",
            "    for(int i = n >> 1; i >= 1; i >>= 1){",
            "      long long zeta = power<long long>(h, i, MOD);",
            "      long long w = 1;",
            "      for(int j = 0; j < n; j += i){",
            "        for(int k = 0; k < i; k++){",
            "          tmp[j+k] = (f[((j<<1)&mask)+k] + w * f[(((j<<1)+i)&mask)+k] % MOD) % MOD;",
            "        }",
            "        w = w * zeta % MOD;",
            "      }",
            "      swap(f, tmp);",
            "    }",
            "  }",
            "  void ntt(vector<long long> &f){",
            "    _ntt(f, false);",
            "  }",
            "  void intt(vector<long long> &f){",
            "    _ntt(f, true);",
            "    int n = f.size();",
            "    int ni = modinv(n, MOD);",
            "    for(int i = 0; i < n; i++)f[i] = f[i] * ni % MOD;",
            "  }",
            "  vector<long long> convolution(vector<long long> f, vector<long long> h){",
            "    int n = 1;",
            "    while(n < int(f.size() + h.size()))n *= 2;",
            "    f.resize(n, 0); h.resize(n, 0);",
            "    ntt(f);",
            "    ntt(h);",
            "    for(int i = 0; i < n; i++)f[i] = f[i] * h[i] % MOD;",
            "    intt(f);",
            "    return f;",
            "  }",
            "};",
            "",
            "using NTT1 = NTT<167772161, 3>;",
            "using NTT2 = NTT<469762049, 3>;",
            "using NTT3 = NTT<1224736769, 3>;",
            "",
            "vector<long long> arbitrary_mod_convolution(vector<long long> f, vector<long long> g, long long MOD){",
            "  for(size_t i = 0; i < f.size(); i++)f[i] %= MOD;",
            "  for(size_t i = 0; i < g.size(); i++)g[i] %= MOD;",
            "  NTT1 ntt1;",
            "  NTT2 ntt2;",
            "  NTT3 ntt3;",
            "  auto x1 = ntt1.convolution(f, g);",
            "  auto x2 = ntt2.convolution(f, g);",
            "  auto x3 = ntt3.convolution(f, g);",
            "",
            "  vector<long long> res(x1.size());",
            "  vector<long long> b(3), m(3);",
            "  m[0] = ntt1.get_mod();",
            "  m[1] = ntt2.get_mod();",
            "  m[2] = ntt3.get_mod();",
            "  for(size_t i = 0; i < x1.size(); i++){",
            "    b[0] = x1[i];",
            "    b[1] = x2[i];",
            "    b[2] = x3[i];",
            "    res[i] = garner<long long>(b, m, MOD);",
            "  }",
            "  return res;",
            "}",
            ""
        ]
    },
    "ntt_use": {
        "prefix": "ntt_use",
        "body": [
            "NTT1 ntt;",
            "h = ntt.convolution(f, g);",
            ""
        ]
    },
    "modint_def": {
        "prefix": "modint_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template <typename T>",
            "T modinv(T a, T m){",
            "  long long x = 0, y = 0;",
            "  extgcd<long long>(a, m, x, y);",
            "  x %= m;",
            "  if(x < 0)x += m;",
            "  return x;",
            "}",
            "",
            "template <typename T>",
            "T power(T a, T n, T mod) {",
            "  T res = 1;",
            "  T tmp = n;",
            "  T curr = a;",
            "  while(tmp){",
            "    if(tmp % 2 == 1){",
            "      res = (T)(res * curr % mod);",
            "    }",
            "    curr = (T)(curr * curr % mod);",
            "    tmp >>= 1;",
            "  }",
            "",
            "  return res;",
            "}",
            "",
            "struct Mint{",
            "  const static ll default_mod = (ll)(1e9 + 7);",
            "  ll MOD = default_mod;",
            "  ll x = 0;",
            "  ll get_mod(){",
            "    return MOD;",
            "  }",
            "  Mint(){}",
            "  Mint(ll x_, ll MOD=default_mod): MOD(MOD){",
            "    x = x_;",
            "    x %= MOD;",
            "    if(x < 0)x += MOD;",
            "  }",
            "  Mint(const Mint &m){",
            "    x = m.x;",
            "    MOD = m.MOD;",
            "  }",
            "  Mint &operator+=(const Mint &y){",
            "    x = (x + y.x) % MOD;",
            "    if(x < 0)x += MOD;",
            "    return *this;",
            "  }",
            "  Mint &operator-=(const Mint &y){",
            "    x = (x - y.x) % MOD;",
            "    if(x < 0)x += MOD;",
            "    return *this;",
            "  }",
            "  Mint &operator*=(const Mint &y){",
            "    x = (x * y.x) % MOD;",
            "    if(x < 0)x += MOD;",
            "    return *this;",
            "  }",
            "  Mint inverse() const{",
            "    return Mint(modinv<ll>(x, MOD), MOD);",
            "  }",
            "  Mint &operator/=(const Mint &y){",
            "    x = (x * y.inverse().x) % MOD;",
            "    if(x < 0)x += MOD;",
            "    return *this;",
            "  }",
            "  Mint operator-() const{",
            "    return Mint(-x, MOD);",
            "  }",
            "  Mint operator+(const Mint &y) const{",
            "    return Mint(*this) += y;",
            "  }",
            "  Mint operator-(const Mint &y) const{",
            "    return Mint(*this) -= y;",
            "  }",
            "  Mint operator*(const Mint &y) const{",
            "    return Mint(*this) *= y;",
            "  }",
            "  Mint operator/(const Mint &y) const{",
            "    return Mint(*this) /= y;",
            "  }",
            "  bool operator==(const Mint &y) const{",
            "    return x == y.x;",
            "  }",
            "  bool operator!=(const Mint &y) const{",
            "    return x != y.x;",
            "  }",
            "  Mint pow(long long k) const{",
            "    long long ret = power<long long>(x, k, MOD);",
            "    return Mint(ret, MOD);",
            "  }",
            "  friend ostream& operator<<(ostream &os, const Mint &m){",
            "    return os << m.x;",
            "  }",
            "  friend istream& operator>>(istream &is, Mint &m){",
            "    ll t;",
            "    is >> t;",
            "    m = Mint(t);",
            "    return is;",
            "  }",
            "  explicit operator long long() const{",
            "    return x;",
            "  }",
            "};",
            ""
        ]
    },
    "modint_use": {
        "prefix": "modint_use",
        "body": [
            "Mint x(n);",
            ""
        ]
    },
    "factorize_def": {
        "prefix": "factorize_def",
        "body": [
            "template <typename T>",
            "map<T, int> factorize(T n){",
            "  map<T, int> res;",
            "  T tmp = n;",
            "  for(T i = 2; i * i <= n; i++){",
            "    while(tmp % i == 0){",
            "      ++res[i];",
            "      tmp /= i;",
            "    }",
            "  }",
            "  if(tmp != 1)res[tmp] = 1;",
            "  return res;",
            "}",
            ""
        ]
    },
    "factorize_use": {
        "prefix": "factorize_use",
        "body": [
            "auto m = factorize<ll>(x);",
            ""
        ]
    },
    "euler_phi_def": {
        "prefix": "euler_phi_def",
        "body": [
            "template<typename T>",
            "T extgcd(T a, T b, T &x, T &y){ ",
            "  T d = a;",
            "  if(b != 0){",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  }else{",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "",
            "template <typename T>",
            "T modinv(T a, T m){",
            "  long long x = 0, y = 0;",
            "  extgcd<long long>(a, m, x, y);",
            "  x %= m;",
            "  if(x < 0)x += m;",
            "  return x;",
            "}",
            "",
            "template <typename T>",
            "map<T, int> factorize(T n){",
            "  map<T, int> res;",
            "  T tmp = n;",
            "  for(T i = 2; i * i <= n; i++){",
            "    while(tmp % i == 0){",
            "      ++res[i];",
            "      tmp /= i;",
            "    }",
            "  }",
            "  if(tmp != 1)res[tmp] = 1;",
            "  return res;",
            "}",
            "",
            "long long euler_phi(long long n){",
            "  ll res = n;",
            "  auto mp = factorize(n);",
            "  const int MOD = 1e9 + 7;",
            "  for(auto itr = mp.begin(); itr != mp.end(); ++itr){",
            "    long long p = itr->first;",
            "    res = res * ((p-1) * modinv<long long>(p, MOD) % MOD) % MOD;",
            "  }",
            "  return res;",
            "}",
            ""
        ]
    },
    "euler_phi_use": {
        "prefix": "euler_phi_use",
        "body": [
            "euler_phi(x);",
            ""
        ]
    },
    "devisor_def": {
        "prefix": "devisor_def",
        "body": [
            "template <typename T>",
            "vector<T> devisor(T n){",
            "  vector<T> res;",
            "  for(T i = 1; i * i <= n; i++){",
            "    if(n % i == 0){",
            "      res.push_back(i);",
            "      if(n != i * i)res.push_back(n / i);",
            "    }",
            "  }",
            "  sort(res.begin(), res.end());",
            "  return res;",
            "}",
            ""
        ]
    },
    "devisor_use": {
        "prefix": "devisor_use",
        "body": [
            "auto d = devisor<ll>(x);",
            ""
        ]
    },
    "segment_sieve_def": {
        "prefix": "segment_sieve_def",
        "body": [
            "vector<long long> segment_sieve(long long a, long long b){",
            "  vector<bool> is_prime(b - a, true);",
            "  long long B = (long long)(sqrt(b)) + 1;",
            "  vector<bool> is_prime_small(B + 1, true);",
            "  is_prime_small[0] = is_prime_small[1] = false;",
            "  for(int i = 0; i < b - a && i + a <= 1; i++)is_prime[i] = false;",
            "  for(int i = 2; i <= B; i++){",
            "    if(is_prime_small[i]){",
            "      for(long long j = max(2LL, (a + i - 1) / i); (long long)j * (long long)i < b; j++)is_prime[(long long)i * (long long)j - a] = false;",
            "      for(int j = 2; j * i <= B; j++)is_prime_small[i * j] = false;",
            "    }",
            "  }",
            "  vector<long long> res;",
            "  for(int i = 0; i < b - a; i++){",
            "    if(is_prime[i])res.push_back(i + a);",
            "  }",
            "  return res;",
            "}",
            ""
        ]
    },
    "segment_sieve_use": {
        "prefix": "segment_sieve_use",
        "body": [
            "auto p = segment_sieve<ll>(a, b);",
            ""
        ]
    },
    "list_prime_def": {
        "prefix": "list_prime_def",
        "body": [
            "template <typename T>",
            "vector<T> list_prime(T n){",
            "  vector<T> res;",
            "  vector<bool> i_prime = vector<bool>(n+1, true);",
            "  i_prime[0] = i_prime[1] = false;",
            "  for(ll i = 2; i <= n; i++){",
            "    if(i_prime[i]){",
            "      res.push_back(i);",
            "      for(ll j = 2; j * i <= n; j++){",
            "        i_prime[i * j] = false;",
            "      }",
            "    }",
            "  }",
            "  return res;",
            "}",
            ""
        ]
    },
    "list_prime_use": {
        "prefix": "list_prime_use",
        "body": [
            "auto p = list_prime(n);",
            ""
        ]
    },
    "is_prime_def": {
        "prefix": "is_prime_def",
        "body": [
            "template <typename T>",
            "bool is_prime(T x){",
            "  if(x == 1)return false;",
            "  for(ll i = 2; i * i <= x; i++){",
            "    if(x % i == 0)return false;",
            "  }",
            "  return true;",
            "}",
            ""
        ]
    },
    "is_prime_use": {
        "prefix": "is_prime_use",
        "body": [
            "is_prime(x);",
            ""
        ]
    },
    "fft_def": {
        "prefix": "fft_def",
        "body": [
            "const long double m_pi = acosl(-1.);",
            "template <typename T>",
            "struct custom_complex{",
            "  T x = 0, y = 0;",
            "  custom_complex(){}",
            "  custom_complex(T x, T y): x(x), y(y){}",
            "  custom_complex operator+(const custom_complex &r) const{",
            "    return custom_complex(x + r.x, y + r.y);",
            "  }",
            "  custom_complex operator-(const custom_complex &r) const{",
            "    return custom_complex(x - r.x, y - r.y);",
            "  }",
            "  custom_complex operator*(const custom_complex &r) const{",
            "    return custom_complex(x * r.x - y * r.y, x * r.y + y * r.x);",
            "  }",
            "  custom_complex conjugate() const{",
            "    return custom_complex(x, - y);",
            "  }",
            "  custom_complex operator/(const custom_complex &r ) const{",
            "    T norm = r.x * r.x + r.y * r.y;",
            "    custom_complex cc = (*this) * r.conjugate();",
            "    cc.x /= norm;",
            "    cc.y /= norm;",
            "    return cc;",
            "  }",
            "  custom_complex& operator*=(const custom_complex &r){",
            "    T xp = x, yp = y;",
            "    x = xp * r.x - yp * r.y;",
            "    y = xp * r.y + yp * r.x;",
            "    return *this;",
            "  }",
            "  T real() const{",
            "    return x;",
            "  }",
            "  T imag() const{",
            "    return y;",
            "  }",
            "};",
            "",
            "template <typename T>",
            "custom_complex<T> pol(T r, T theta){",
            "  return custom_complex<T>(r * cosl(theta), r * sinl(theta));",
            "}",
            "",
            "using dbase = long double;",
            "using cd = custom_complex<dbase>;",
            "// f.size() should be the power of 2.",
            "void rec_fft(vector<cd> &f, bool inv=false){",
            "  int n = f.size();",
            "  if(n == 1)return;",
            "  vector<cd> f0(n / 2), f1(n / 2);",
            "  for(int i = 0; i < n / 2; i++){",
            "    f0[i] = f[i * 2];",
            "    f1[i] = f[i * 2 + 1];",
            "  }",
            "  rec_fft(f0, inv);",
            "  rec_fft(f1, inv);",
            "  dbase th = m_pi * 2 / n;",
            "  if(inv)th = - th;",
            "  cd u(cos(th), sin(th)), ui(1., 0);",
            "  for(int i = 0; i < n; i++){",
            "    f[i] = f0[i%(n/2)] + ui * f1[i%(n/2)];",
            "    ui = ui * u;",
            "  }",
            "}",
            "",
            "// f.size() should be the power of 2.",
            "void fft(vector<cd> &f, bool inv=false){",
            "  int n = f.size(), mask = n - 1;",
            "  vector<cd> tmp(n);",
            "  for(int i = n >> 1; i >= 1; i >>= 1){",
            "    cd zeta = pol<dbase>(1., 2. * m_pi * i * (inv ? -1.: 1.) / n);",
            "    cd w = cd(1., 0);",
            "    for(int j = 0; j < n; j += i){",
            "      for(int k = 0; k < i; k++){",
            "        tmp[j + k] = f[((j<<1)&mask) + k] + w * f[(((j<<1)+i)&mask)+k];",
            "      }",
            "      w *= zeta;",
            "    }",
            "    swap(f, tmp);",
            "  }",
            "}",
            "",
            "void dft(vector<cd> &f){",
            "  fft(f);",
            "}",
            "",
            "void idft(vector<cd> &f){",
            "  fft(f, true);",
            "  for(size_t i = 0; i < f.size(); i++)f[i] = f[i] / cd(f.size(), 0.);",
            "}",
            "",
            "template <typename T>",
            "vector<T> convolution(const vector<T> &f, const vector<T> &g){",
            "  int n = 1;",
            "  while(n < 2 * f.size() + 1)n *= 2;",
            "  vector<cd> F(n, cd(0., 0.)), G(n, cd(0., 0.));",
            "  for(int i = 0; i < f.size(); i++)F[i] = cd(f[i], 0.);",
            "  for(int i = 0; i < g.size(); i++)G[i] = cd(g[i], 0.);",
            "",
            "  dft(F);",
            "  dft(G);",
            "  vector<cd> H(n);",
            "  for(int i = 0; i < n; i++)H[i] = F[i] * G[i];",
            "  idft(H);",
            "  vector<T> h(n);",
            "  for(int i = 0; i < n; i++){",
            "    h[i] = T(round(H[i].real()));",
            "  }",
            "  return h;",
            "}",
            ""
        ]
    },
    "fft_use": {
        "prefix": "fft_use",
        "body": [
            "fft(f);",
            ""
        ]
    },
    "bigint_def": {
        "prefix": "bigint_def",
        "body": [
            "const long double m_pi = acosl(-1.);",
            "template <typename T>",
            "struct custom_complex{",
            "  T x = 0, y = 0;",
            "  custom_complex(){}",
            "  custom_complex(T x, T y): x(x), y(y){}",
            "  custom_complex operator+(const custom_complex &r) const{",
            "    return custom_complex(x + r.x, y + r.y);",
            "  }",
            "  custom_complex operator-(const custom_complex &r) const{",
            "    return custom_complex(x - r.x, y - r.y);",
            "  }",
            "  custom_complex operator*(const custom_complex &r) const{",
            "    return custom_complex(x * r.x - y * r.y, x * r.y + y * r.x);",
            "  }",
            "  custom_complex conjugate() const{",
            "    return custom_complex(x, - y);",
            "  }",
            "  custom_complex operator/(const custom_complex &r ) const{",
            "    T norm = r.x * r.x + r.y * r.y;",
            "    custom_complex cc = (*this) * r.conjugate();",
            "    cc.x /= norm;",
            "    cc.y /= norm;",
            "    return cc;",
            "  }",
            "  custom_complex& operator*=(const custom_complex &r){",
            "    T xp = x, yp = y;",
            "    x = xp * r.x - yp * r.y;",
            "    y = xp * r.y + yp * r.x;",
            "    return *this;",
            "  }",
            "  T real() const{",
            "    return x;",
            "  }",
            "  T imag() const{",
            "    return y;",
            "  }",
            "};",
            "",
            "template <typename T>",
            "custom_complex<T> pol(T r, T theta){",
            "  return custom_complex<T>(r * cosl(theta), r * sinl(theta));",
            "}",
            "",
            "using dbase = long double;",
            "using cd = custom_complex<dbase>;",
            "// f.size() should be the power of 2.",
            "void rec_fft(vector<cd> &f, bool inv=false){",
            "  int n = f.size();",
            "  if(n == 1)return;",
            "  vector<cd> f0(n / 2), f1(n / 2);",
            "  for(int i = 0; i < n / 2; i++){",
            "    f0[i] = f[i * 2];",
            "    f1[i] = f[i * 2 + 1];",
            "  }",
            "  rec_fft(f0, inv);",
            "  rec_fft(f1, inv);",
            "  dbase th = m_pi * 2 / n;",
            "  if(inv)th = - th;",
            "  cd u(cos(th), sin(th)), ui(1., 0);",
            "  for(int i = 0; i < n; i++){",
            "    f[i] = f0[i%(n/2)] + ui * f1[i%(n/2)];",
            "    ui = ui * u;",
            "  }",
            "}",
            "",
            "// f.size() should be the power of 2.",
            "void fft(vector<cd> &f, bool inv=false){",
            "  int n = f.size(), mask = n - 1;",
            "  vector<cd> tmp(n);",
            "  for(int i = n >> 1; i >= 1; i >>= 1){",
            "    cd zeta = pol<dbase>(1., 2. * m_pi * i * (inv ? -1.: 1.) / n);",
            "    cd w = cd(1., 0);",
            "    for(int j = 0; j < n; j += i){",
            "      for(int k = 0; k < i; k++){",
            "        tmp[j + k] = f[((j<<1)&mask) + k] + w * f[(((j<<1)+i)&mask)+k];",
            "      }",
            "      w *= zeta;",
            "    }",
            "    swap(f, tmp);",
            "  }",
            "}",
            "",
            "void dft(vector<cd> &f){",
            "  fft(f);",
            "}",
            "",
            "void idft(vector<cd> &f){",
            "  fft(f, true);",
            "  for(size_t i = 0; i < f.size(); i++)f[i] = f[i] / cd(f.size(), 0.);",
            "}",
            "",
            "template <typename T>",
            "vector<T> convolution(const vector<T> &f, const vector<T> &g){",
            "  int n = 1;",
            "  while(n < 2 * f.size() + 1)n *= 2;",
            "  vector<cd> F(n, cd(0., 0.)), G(n, cd(0., 0.));",
            "  for(int i = 0; i < f.size(); i++)F[i] = cd(f[i], 0.);",
            "  for(int i = 0; i < g.size(); i++)G[i] = cd(g[i], 0.);",
            "",
            "  dft(F);",
            "  dft(G);",
            "  vector<cd> H(n);",
            "  for(int i = 0; i < n; i++)H[i] = F[i] * G[i];",
            "  idft(H);",
            "  vector<T> h(n);",
            "  for(int i = 0; i < n; i++){",
            "    h[i] = T(round(H[i].real()));",
            "  }",
            "  return h;",
            "}",
            "",
            "vector<ll> convert_base(const vector<ll> &v, int old_b, int new_b){",
            "  vector<ll> p(max(new_b, old_b) + 1);",
            "  p[0] = 1;",
            "  for(int i = 1; i < p.size(); i++)p[i] = p[i-1] * 10;",
            "  vector<ll> res;",
            "  ll curr = 0;",
            "  int curr_b = 0;",
            "  for(int i = 0; i < v.size(); i++){",
            "    curr += v[i] * p[curr_b];",
            "    curr_b += old_b;",
            "    while(curr_b >= new_b){",
            "      res.push_back(curr % p[new_b]);",
            "      curr /= p[new_b];",
            "      curr_b -= new_b;",
            "    }",
            "  }",
            "  res.push_back(curr);",
            "  while(!res.empty() && res.back() == 0)res.pop_back();",
            "  return res;",
            "}",
            "",
            "vector<ll> simple_multiply(const vector<ll> &x, const vector<ll> &y){",
            "  vector<ll> res(x.size() + y.size() - 1, 0);",
            "  for(int i = 0; i < x.size(); i++){",
            "    for(int j = 0; j < y.size(); j++){",
            "      res[i+j] += x[i] * y[j];",
            "    }",
            "  }",
            "  while(!res.empty() && res.back() == 0)res.pop_back();",
            "  return res;",
            "}",
            "",
            "vector<ll> fft_multiply(const vector<ll> &x, const vector<ll> &y){",
            "  int n = max(x.size(), y.size());",
            "  vector<ll> a = x, b = y;",
            "  a.resize(n, 0);",
            "  b.resize(n, 0);",
            "  vector<ll> conv = convolution<ll>(a, b);",
            "  while(!conv.empty() && conv.back() == 0)conv.pop_back();",
            "  return conv;",
            "}",
            "",
            "vector<ll> karatsuba_multiply(const vector<ll> &x, const vector<ll> &y){",
            "  int n = max(x.size(), y.size());",
            "  int m = 0;",
            "  while((1 << m) < n)m++;",
            "  n = (1 << m);",
            "  vector<ll> a = x, b = y;",
            "  a.resize(n, 0);",
            "  b.resize(n, 0);",
            "  if(n <= 32){",
            "    return simple_multiply(a, b);",
            "  }",
            "",
            "  int k = n >> 1;",
            "  vector<ll> a1(a.begin(), a.begin() + k);",
            "  vector<ll> a2(a.begin() + k, a.end());",
            "  vector<ll> b1(b.begin(), b.begin() + k);",
            "  vector<ll> b2(b.begin() + k, b.end());",
            "",
            "  vector<ll> a1b1 = karatsuba_multiply(a1, b1);",
            "  vector<ll> a2b2 = karatsuba_multiply(a2, b2);",
            "  for(int i = 0; i < k; i++)a2[i] += a1[i];",
            "  for(int i = 0; i < k; i++)b2[i] += b1[i];",
            "  vector<ll> z = karatsuba_multiply(a2, b2);",
            "  for(int i = 0; i < a1b1.size(); i++)z[i] -= a1b1[i];",
            "  for(int i = 0; i < a2b2.size(); i++)z[i] -= a2b2[i];",
            "",
            "  vector<ll> res(2 * n, 0);",
            "  for(int i = 0; i < a1b1.size(); i++)res[i] += a1b1[i];",
            "  for(int i = 0; i < a2b2.size(); i++)res[i + n] += a2b2[i];",
            "  for(int i = 0; i < z.size(); i++)res[i + k] += z[i];",
            "  while(!res.empty() && res.back() == 0)res.pop_back();",
            "  return res;",
            "}",
            "",
            "struct Bigint{",
            "  const ll base = 100000000;",
            "  const ll mbase = 1000; // 1000 for FFT, 10000 otherwise",
            "  const int b = 8;",
            "  const int mb = 3; // 3 for FFT, 10000 otherwise",
            "  int sign = 1;",
            "  vector<ll> dg;",
            "  Bigint(){}",
            "  Bigint(ll x){",
            "    if(x < 0){",
            "      sign = -1;",
            "      x *= -1;",
            "    }",
            "    while(x){",
            "      dg.push_back(x % base);",
            "      x /= base;",
            "    }",
            "  }",
            "  Bigint(const string &s){",
            "    int e = 0;",
            "    if(s[0] == '-'){",
            "      sign = -1;",
            "      e++;",
            "    }",
            "    for(int i = int(s.size()) - 1; i >= e; i-=b){",
            "      int B = (i - b + 1 >= e ? b: i + 1 - e);",
            "      ll x = stoll(s.substr(max(e, i - b + 1), B));",
            "      dg.push_back(x);",
            "    }",
            "  }",
            "  Bigint& operator=(const string &s){",
            "    *this = Bigint(s);",
            "    return *this;",
            "  }",
            "  Bigint& operator=(const Bigint &x){",
            "    sign = x.sign;",
            "    dg = x.dg;",
            "    return *this;",
            "  }",
            "  Bigint& operator=(ll x){",
            "    return (*this = Bigint(x));",
            "  }",
            "  Bigint operator-() const{",
            "    Bigint res = *this;",
            "    res.sign *= -1;",
            "    return res;",
            "  }",
            "  Bigint operator+(const Bigint &x) const{",
            "    if(sign == x.sign){",
            "      Bigint res;",
            "      res.sign = sign;",
            "      res.dg.resize(max(dg.size(), x.dg.size()));",
            "      ll carry = 0;",
            "      for(int i = 0; i < max(dg.size(), x.dg.size()); i++){",
            "        ll tmp = carry;",
            "        if(i < dg.size())tmp += dg[i];",
            "        if(i < x.dg.size())tmp += x.dg[i];",
            "        res.dg[i] = (tmp % base);",
            "        carry = tmp / base;",
            "      }",
            "      while(carry){",
            "        res.dg.push_back(carry % base);",
            "        carry /= base;",
            "      }",
            "      return res;",
            "    }else{",
            "      return (*this - (- x));",
            "    }",
            "  }",
            "  void trim(){",
            "    while(!dg.empty() && dg.back() == 0)dg.pop_back();",
            "    if(dg.empty())sign = 1;",
            "  }",
            "  Bigint abs() const{",
            "    Bigint res = *this;",
            "    res.sign = 1;",
            "    return res;",
            "  }",
            "  Bigint operator-(const Bigint &x) const{",
            "    if(sign == x.sign){",
            "      if(abs() >= x.abs()){",
            "        Bigint res = *this;",
            "        ll carry = 0;",
            "        for(int i = 0; i < x.dg.size(); i++){",
            "          res.dg[i] -= carry + x.dg[i];",
            "          if(res.dg[i] < 0){",
            "            res.dg[i] += base;",
            "            carry = 1;",
            "          }else{",
            "            carry = 0;",
            "          }",
            "        }",
            "        if(carry > 0){",
            "          for(int i = x.dg.size(); i < res.dg.size() && carry > 0; i++){",
            "            res.dg[i] -= carry;",
            "            if(res.dg[i] < 0){",
            "              res.dg[i] += base;",
            "              carry = 1;",
            "            }else{",
            "              carry = 0;",
            "            }",
            "          }",
            "        }",
            "        res.trim();",
            "        return res;",
            "      }else{",
            "        return - (x - *this);",
            "      }",
            "    }else{",
            "      return (*this + (- x));",
            "    }",
            "  }",
            "  bool operator<(const Bigint &x) const{",
            "    if(sign != x.sign)return sign < x.sign;",
            "    if(dg.size() != x.dg.size())return int(dg.size()) * sign < int(x.dg.size()) * x.sign;",
            "    for(int i = int(dg.size()) - 1; i >= 0; i--){",
            "      if(dg[i] != x.dg[i])return dg[i] * sign < x.dg[i] * x.sign;",
            "    }",
            "    return false;",
            "  }",
            "  bool operator>(const Bigint &x) const{",
            "    return x < *this;",
            "  }",
            "  bool operator<=(const Bigint &x) const{",
            "    return !(*this > x);",
            "  }",
            "  bool operator>=(const Bigint &x) const{",
            "    return !(*this < x);",
            "  }",
            "  bool operator==(const Bigint &x) const{",
            "    return !(*this < x) && !(x < *this);",
            "  }",
            "  bool operator!=(const Bigint &x) const{",
            "    return (*this < x) || (x < *this);",
            "  }",
            "  friend istream& operator>>(istream &is, Bigint &x){",
            "    string s;",
            "    is >> s;",
            "    x = s;",
            "    return is;",
            "  }",
            "  friend ostream& operator<<(ostream& os, const Bigint &x){",
            "    if(x.sign < 0)os << '-';",
            "    if(x.dg.empty())os << 0;",
            "    else{",
            "      os << x.dg.back();",
            "      for(int i = int(x.dg.size()) - 2; i >= 0; i--){",
            "        os << setw(x.b) << setfill('0') << x.dg[i];",
            "      }",
            "    }",
            "    return os;",
            "  }",
            "  Bigint& operator*=(ll x){",
            "    if(x < 0){",
            "      x *= -1;",
            "      sign *= -1;",
            "    }",
            "    ll carry = 0;",
            "    for(int i = 0; i < dg.size(); i++){",
            "      carry = dg[i] * x + carry;",
            "      dg[i] = carry % base;",
            "      carry /= base;",
            "    }",
            "    while(carry){",
            "      dg.push_back(carry % base);",
            "      carry /= base;",
            "    }",
            "    trim();",
            "    return *this;",
            "  }",
            "  Bigint operator*(ll x) const{",
            "    Bigint res = *this;",
            "    res *= x;",
            "    return res;",
            "  }",
            "  Bigint operator*(const Bigint &v) const{",
            "    vector<ll> x = convert_base(dg, b, mb);",
            "    vector<ll> y = convert_base(v.dg, b, mb);",
            "",
            "    if(x.empty())x.push_back(0);",
            "    if(y.empty())y.push_back(0);",
            "    // simple multiplication",
            "    // vector<ll> mul = simple_multiply(x, y);",
            "    // FFT",
            "    vector<ll> mul = fft_multiply(x, y);",
            "    // karatsuba",
            "    // vector<ll> mul = karatsuba_multiply(x, y);",
            "",
            "    Bigint res;",
            "    res.sign = sign * v.sign;",
            "    ll carry = 0;",
            "    for(int i = 0; i < mul.size(); i++){",
            "      carry += mul[i];",
            "      res.dg.push_back(carry % mbase);",
            "      carry /= mbase;",
            "    }",
            "    while(carry){",
            "      res.dg.push_back(carry % mbase);",
            "      carry /= mbase;",
            "    }",
            "    res.dg = convert_base(res.dg, mb, b);",
            "    res.trim();",
            "    return res;",
            "  }",
            "  // a = bq + r",
            "  pair<Bigint, Bigint> divmod(const Bigint &a1, const Bigint &b1) const{",
            "    ll norm = base / (b1.dg.back() + 1);",
            "    Bigint q, r;",
            "    q.sign = a1.sign * b1.sign;",
            "    r.sign = a1.sign;",
            "",
            "    Bigint a = a1.abs() * norm;",
            "    Bigint b = b1.abs() * norm;",
            "    q.dg.resize(a.dg.size());",
            "",
            "    for(int i = int(a.dg.size()) - 1; i >= 0; i--){",
            "      r = r * base + a.dg[i];",
            "      ll s1 = (r.dg.size() <= b.dg.size() ? 0: r.dg[b.dg.size()]);",
            "      ll s2 = (r.dg.size() <= int(b.dg.size()) - 1 ? 0: r.dg[int(b.dg.size()) - 1]);",
            "      // temporary solution",
            "      ll d = (base * s1 + s2) / b.dg.back();",
            "      r -= b * d;",
            "      // feedback",
            "      while(r < 0)r += b, d--;",
            "      q.dg[i] = d;",
            "    }",
            "",
            "    q.trim();",
            "    r.trim();",
            "    return make_pair(q, r / norm);",
            "  }",
            "  Bigint operator/(const Bigint &x) const{",
            "    return divmod(*this, x).first;",
            "  }",
            "  Bigint operator%(const Bigint &x) const{",
            "    return divmod(*this, x).second;",
            "  }",
            "  Bigint& operator/=(ll x){",
            "    if(x < 0){",
            "      x *= -1;",
            "      sign *= -1;",
            "    }",
            "    ll rem = 0;",
            "    for(int i = int(dg.size()) - 1; i >= 0; i--){",
            "      rem = dg[i] + rem * base;",
            "      dg[i] = rem / x;",
            "      rem = rem % x;",
            "    }",
            "    trim();",
            "    return *this;",
            "  }",
            "  Bigint operator/(ll x) const{",
            "    Bigint res = *this;",
            "    res /= x;",
            "    return res;",
            "  }",
            "  Bigint operator%(ll x) const{",
            "    if(x < 0)x *= -1;",
            "    ll m = 0;",
            "    for(int i = int(dg.size()) - 1; i >= 0; i--){",
            "      m = (dg[i] + m * base) % x;",
            "    }",
            "    return m * sign;",
            "  }",
            "  Bigint& operator+=(const Bigint &x){",
            "    *this = *this + x;",
            "    return *this;",
            "  }",
            "  Bigint& operator-=(const Bigint &x){",
            "    *this = *this - x;",
            "    return *this;",
            "  }",
            "  Bigint& operator*=(const Bigint &x){",
            "    *this = *this * x;",
            "    return *this;",
            "  }",
            "  Bigint& operator/=(const Bigint &x){",
            "    *this = *this / x;",
            "    return *this;",
            "  }",
            "  bool iszero(){",
            "    trim();",
            "    if(dg.empty())return true;",
            "    return false;",
            "  }",
            "  ll long_value() const {",
            "    ll res = 0;",
            "    for(int i = int(dg.size()) - 1; i >= 0; i--){",
            "      res = res * base + dg[i];",
            "    }",
            "    return res * sign;",
            "  }",
            "};",
            ""
        ]
    },
    "bigint_use": {
        "prefix": "bigint_use",
        "body": [
            "Bigint b = x;",
            ""
        ]
    },
    "bipartile_def": {
        "prefix": "bipartile_def",
        "body": [
            "struct Graph {",
            "  int n = 0;",
            "  vector<int> color;",
            "  vector<vector<int> > edges;",
            "  explicit Graph(int n): n(n) {",
            "    color.resize(n, 0);",
            "    edges.resize(n);",
            "  }",
            "  void adde(int at, int to){",
            "    edges[at].push_back(to);",
            "  }",
            "  bool is_bipartile(){",
            "    for(int i = 0; i < n; i++){",
            "      if(color[i] == 0){",
            "        if(!dfs(i, 1)){",
            "          return false;",
            "        }",
            "      }",
            "    }",
            "    return true;",
            "  }",
            "  bool dfs(int v, int c){",
            "    color[v] = c;",
            "    for(int i: edges[v]){",
            "      if(color[i] == c){",
            "        return false;",
            "      }",
            "      if(color[i] == 0 && !dfs(i, -c))return false;",
            "    }",
            "    return true;",
            "  }",
            "};",
            ""
        ]
    },
    "bipartile_use": {
        "prefix": "bipartile_use",
        "body": [
            "Graph g(n);",
            "g.adde(u, v);",
            "bool b = g.is_bipartile();",
            ""
        ]
    },
    "warshall_floyd_def": {
        "prefix": "warshall_floyd_def",
        "body": [
            "template <typename T>",
            "struct Graph {",
            "  int n;",
            "  vector<vector<T> > d;",
            "  vector<vector<int> > path;",
            "  Graph(int n): n(n) {",
            "    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));",
            "    path = vector<vector<int>>(n, vector<int>(n, -1));",
            "    for(int i = 0; i < n; i++)d[i][i] = 0;",
            "  }",
            "  void warshall_floyd(){",
            "    for(int k = 0; k < n; k++){",
            "      for(int i = 0; i < n; i++){",
            "        for(int j = 0; j < n; j++){",
            "          if(d[i][j] > d[i][k] + d[k][j]){",
            "            d[i][j] = d[i][k] + d[k][j];",
            "            path[i][j] = k;",
            "          }",
            "        }",
            "      }",
            "    }",
            "  }",
            "  void adde(int at, int to, T cost){",
            "    d[at][to] = cost;",
            "  }",
            "  vector<T>& operator[](size_t i){",
            "    return d[i];",
            "  }",
            "};",
            "",
            "using GraphI = Graph<int>;",
            "using GraphL = Graph<ll>;",
            ""
        ]
    },
    "warshall_floyd_use": {
        "prefix": "warshall_floyd_use",
        "body": [
            "graph.warshall_floyd()",
            ""
        ]
    },
    "dijkstra_def": {
        "prefix": "dijkstra_def",
        "body": [
            "template <typename T>",
            "struct Graph {",
            "  int n;",
            "  vector<vector<pair<int, T> > > edge;",
            "  vector<T> dis;",
            "  Graph(int n): n(n) {",
            "    edge.resize(n);",
            "    dis.resize(n);",
            "  }",
            "  void dijkstra(int s){",
            "    dijkstra(s, 0);",
            "  }",
            "  T dijkstra(int s, int t){",
            "    // initialize",
            "    fill(dis.begin(), dis.end(), -1);",
            "    vector<bool> used(n, false);",
            "    dis[s] = 0;",
            "    // dijkstra",
            "    priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > q;",
            "    q.push(make_pair(0, s));",
            "    while(!q.empty()){",
            "      pair<T, int> p = q.top(); q.pop();",
            "      int at = p.second;",
            "      T distance = p.first;",
            "      if(used[at])continue;",
            "      used[at] = true;",
            "      for(auto itr = edge[at].begin(); itr != edge[at].end(); ++itr){",
            "        int to = (*itr).first;",
            "        T cost = (*itr).second;",
            "        if(used[to])continue;",
            "        if(dis[to] == -1 || dis[to] > distance + cost){",
            "          q.push(make_pair(distance + cost, to));",
            "          dis[to] = distance + cost;",
            "        }",
            "      }",
            "    }",
            "    return dis[t];",
            "  }",
            "  void adde(int at, int to, T cost){",
            "    edge[at].push_back(make_pair(to, cost));",
            "  }",
            "  [[deprecated(\"This function takes O(|edge[at]|).\")]]",
            "  void remove(int at, int to){",
            "    int index = -1;",
            "    for(int i = 0; i < edge[at].size(); i++){",
            "      if(edge[at][i].first == to){",
            "        index = i;",
            "        break;",
            "      }",
            "    }",
            "    edge[at].erase(edge[at].begin() + index);",
            "  }",
            "};",
            "",
            "using GraphI = Graph<int>;",
            "using GraphL = Graph<ll>;",
            "using GraphD = Graph<double>;",
            ""
        ]
    },
    "dijkstra_use": {
        "prefix": "dijkstra_use",
        "body": [
            "graph.dijkstra(x);",
            ""
        ]
    },
    "topological_sort_def": {
        "prefix": "topological_sort_def",
        "body": [
            "struct Graph{",
            "  int n = 0;",
            "  vector<vector<int> > edge;",
            "  vector<int> in_deg;",
            "  explicit Graph(int n): n(n){",
            "    edge.resize(n);",
            "    in_deg.resize(n, 0);",
            "  }",
            "  void adde(int at, int to){",
            "    edge[at].push_back(to);",
            "    in_deg[to]++;",
            "  }",
            "  vector<int> topological_sort(){",
            "    stack<int> st;",
            "    for(int i = 0; i < n; i++){",
            "      if(in_deg[i] == 0)st.push(i);",
            "    }",
            "    vector<int> res;",
            "    while(st.size()){",
            "      int at = st.top(); st.pop();",
            "      res.push_back(at);",
            "      for(int j: edge[at]){",
            "        in_deg[j]--;",
            "        if(in_deg[j] == 0)st.push(j);",
            "      }",
            "    }",
            "",
            "    return res;",
            "  }",
            "};",
            ""
        ]
    },
    "topological_sort_use": {
        "prefix": "topological_sort_use",
        "body": [
            "Graph g(n);",
            "g.adde(u, v);",
            "auto t = g.topological_sort();",
            ""
        ]
    },
    "bellman_ford_def": {
        "prefix": "bellman_ford_def",
        "body": [
            "template <typename T>",
            "struct edge{int from, to; T cost;};",
            "",
            "template <typename T>",
            "struct Graph{",
            "  int n;",
            "  vector<T> d;",
            "  vector<edge<T>> es;",
            "  Graph(int n): n(n){",
            "    d.resize(n, numeric_limits<T>::max());",
            "  }",
            "  void adde(int from, int to, T cost){",
            "    adde(edge<T>{from, to, cost});",
            "  }",
            "  void adde(edge<T> e){",
            "    es.push_back(e);",
            "  }",
            "  bool bellman_ford(int s){",
            "    T maxim = numeric_limits<T>::max();",
            "    fill(d.begin(), d.end(), maxim);",
            "    d[s] = 0;",
            "    for(int i = 0; i < n; i++){",
            "      bool update = false;",
            "      for(auto e: es){",
            "        if(d[e.from] != maxim && d[e.to] > d[e.from] + e.cost){",
            "          d[e.to] = d[e.from] + e.cost;",
            "          update = true;",
            "          if(i == n - 1)return false;",
            "        }",
            "      }",
            "      if(!update)break;",
            "    }",
            "    return true;",
            "  }",
            "};",
            "",
            "using GraphL = Graph<ll>;",
            "using GraphI = Graph<int>;",
            ""
        ]
    },
    "bellman_ford_use": {
        "prefix": "bellman_ford_use",
        "body": [
            "bool b = graph.bellman_ford(x);",
            ""
        ]
    },
    "convert_def": {
        "prefix": "convert_def",
        "body": [
            "int ato_int(char c){",
            "  return int(c - 'a');",
            "}",
            "",
            "char to_achar(int i){",
            "  return char(i + 'a');",
            "}",
            "",
            "int Ato_int(char c){",
            "  if('a' <= c && c <= 'z')return int(c - 'a');",
            "  return int(c - 'A') + 26;",
            "}",
            "",
            "char to_Achar(int i){",
            "  if(i < 26)return char(i + 'a');",
            "  return char(i - 26 + 'A');",
            "}",
            "",
            "int dto_int(char c){",
            "  return int(c - '0');",
            "}",
            "",
            "char to_dchar(int i){",
            "  return char(i + '0');",
            "}",
            ""
        ]
    },
    "convert_use": {
        "prefix": "convert_use",
        "body": [
            "int d = dto_int(c);",
            ""
        ]
    },
    "zarray_def": {
        "prefix": "zarray_def",
        "body": [
            "vector<int> zarray(const string &s){",
            "  int n = s.size();",
            "  vector<int> z(n, 0);",
            "  int c = 0;",
            "  for(int i = 1; i < n; i++){",
            "    if(i + z[i - c] < c + z[c]){",
            "      z[i] = z[i - c];",
            "    }else{",
            "      int j = max(0, c + z[c] - i);",
            "      while(i + j < n && s[j] == s[i + j])j++;",
            "      z[i] = j;",
            "      c = i;",
            "    }",
            "  }",
            "  z[0] = n;",
            "  return z;",
            "}",
            ""
        ]
    },
    "zarray_use": {
        "prefix": "zarray_use",
        "body": [
            "vector<int> z = zarray(s);",
            ""
        ]
    },
    "mergable_range_set_def": {
        "prefix": "mergable_range_set_def",
        "body": [
            "template <typename T>",
            "struct MergableRangeSet{",
            "  using PT = pair<T, T>;",
            "  set<PT> st;",
            "  MergableRangeSet(){}",
            "  // [l, r)",
            "  void add(T l, T r){",
            "    if(r <= l)return;",
            "    auto itr = st.upper_bound(make_pair(l, 0));",
            "    if(itr != st.begin()){",
            "      auto litr = itr;",
            "      --litr;",
            "      if(litr->second >= r){",
            "        return;",
            "      }else if(litr->second >= l){",
            "        l = litr->first;",
            "        st.erase(litr);",
            "      }",
            "    }",
            "    if(itr != st.end()){",
            "      if(r < itr->first)st.insert(make_pair(l, r));",
            "      else {",
            "        PT p = make_pair(l, max(r, itr->second));",
            "        st.erase(itr);",
            "        st.insert(p);",
            "      }",
            "    }else{",
            "      st.insert(make_pair(l, r));",
            "    }",
            "  }",
            "  typename set<PT>::iterator begin() noexcept{",
            "    return st.begin();",
            "  }",
            "  typename set<PT>::iterator end() noexcept{",
            "    return st.end();",
            "  }",
            "  size_t size(){",
            "    return st.size();",
            "  }",
            "};",
            ""
        ]
    },
    "mergable_range_set_use": {
        "prefix": "mergable_range_set_use",
        "body": [
            "MergableRangeSet<ll> mrs;",
            "mrs.add(l, r);",
            ""
        ]
    },
    "segment_tree_def": {
        "prefix": "segment_tree_def",
        "body": [
            "template <class Monoid>",
            "class SegmentTree{",
            "  public:",
            "    int n;",
            "    using T = typename Monoid::value_type;",
            "    vector<T> val;",
            "    T identity;",
            "",
            "    SegmentTree(){}",
            "    SegmentTree(int n_, vector<T> v=vector<T>()){",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      identity = Monoid::identity;",
            "      val.assign(2*n-1, identity);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void update(int k, const T &t){",
            "      k = k + n - 1;",
            "      val[k] = t;",
            "      while(k > 0){",
            "        k = (k - 1) / 2;",
            "        val[k] = Monoid::operation(val[2*k+1], val[2*k+2]);",
            "      }",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return val[i+n-1];",
            "    }",
            "};",
            ""
        ]
    },
    "segment_tree_use": {
        "prefix": "segment_tree_use",
        "body": [
            "SegmentTree<Monoid> seg(n);",
            ""
        ]
    },
    "RSQ_def": {
        "prefix": "RSQ_def",
        "body": [
            "template <class Monoid>",
            "class SegmentTree{",
            "  public:",
            "    int n;",
            "    using T = typename Monoid::value_type;",
            "    vector<T> val;",
            "    T identity;",
            "",
            "    SegmentTree(){}",
            "    SegmentTree(int n_, vector<T> v=vector<T>()){",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      identity = Monoid::identity;",
            "      val.assign(2*n-1, identity);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void update(int k, const T &t){",
            "      k = k + n - 1;",
            "      val[k] = t;",
            "      while(k > 0){",
            "        k = (k - 1) / 2;",
            "        val[k] = Monoid::operation(val[2*k+1], val[2*k+2]);",
            "      }",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return val[i+n-1];",
            "    }",
            "};",
            "",
            "template <typename T>",
            "class RSQ{",
            "  public:",
            "    const static T identity = 0;",
            "    using value_type = T;",
            "",
            "    RSQ(){}",
            "    static T operation(T &l, T &r){",
            "      return l + r;",
            "    }",
            "};",
            ""
        ]
    },
    "RSQ_use": {
        "prefix": "RSQ_use",
        "body": [
            "SegmentTree<RSQ<ll>> seg(n);",
            ""
        ]
    },
    "RMQ_def": {
        "prefix": "RMQ_def",
        "body": [
            "template <class Monoid>",
            "class SegmentTree{",
            "  public:",
            "    int n;",
            "    using T = typename Monoid::value_type;",
            "    vector<T> val;",
            "    T identity;",
            "",
            "    SegmentTree(){}",
            "    SegmentTree(int n_, vector<T> v=vector<T>()){",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      identity = Monoid::identity;",
            "      val.assign(2*n-1, identity);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void update(int k, const T &t){",
            "      k = k + n - 1;",
            "      val[k] = t;",
            "      while(k > 0){",
            "        k = (k - 1) / 2;",
            "        val[k] = Monoid::operation(val[2*k+1], val[2*k+2]);",
            "      }",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return val[i+n-1];",
            "    }",
            "};",
            "",
            "template <typename T>",
            "class RMQ{",
            "  public:",
            "    const static T identity = numeric_limits<T>::max();",
            "    using value_type = T;",
            "",
            "    RMQ(){}",
            "    static T operation(T &l, T &r){",
            "      return min(l, r);",
            "    }",
            "};",
            ""
        ]
    },
    "RMQ_use": {
        "prefix": "RMQ_use",
        "body": [
            "SegmentTree<RMQ<ll>> seg(n);",
            ""
        ]
    },
    "int128_t_def": {
        "prefix": "int128_t_def",
        "body": [
            "ostream& operator<<(ostream& dest, __int128_t value) {",
            "  ostream::sentry s(dest);",
            "  if(s){",
            "    __uint128_t tmp = value < 0 ? - value: value;",
            "    char buf[128];",
            "    char *d = end(buf);",
            "    do{",
            "      --d;",
            "      *d = \"0123456789\"[tmp % 10];",
            "      tmp /= 10;",
            "    }while(tmp != 0);",
            "    if(value < 0)--d, *d='-';",
            "    int len = end(buf) - d;",
            "    if(dest.rdbuf()->sputn(d, len) != len){",
            "      dest.setstate(ios_base::badbit);",
            "    }",
            "  }",
            "  return dest;",
            "}",
            "",
            "__int128_t to_int128(string s){",
            "  __int128_t res = 0;",
            "  for(size_t i = 0; i < s.size(); i++){",
            "    res = res * 10 + (s[i] - '0');",
            "  }",
            "  return res;",
            "}",
            ""
        ]
    },
    "int128_t_use": {
        "prefix": "int128_t_use",
        "body": [
            "__int128_t t = to_int128(s);",
            "os << t;",
            ""
        ]
    },
    "weighted_unionfind_def": {
        "prefix": "weighted_unionfind_def",
        "body": [
            "template <typename T>",
            "struct WeightedUnionFind_{",
            "  int n;",
            "  vector<int> par;",
            "  vector<int> rank;",
            "  vector<T> diff_weight;",
            "  WeightedUnionFind_(int n, T def=0): n(n){",
            "    par.resize(n);",
            "    rank.resize(n);",
            "    diff_weight.resize(n);",
            "    for(int i = 0; i < n; i++){",
            "      par[i] = i;",
            "      rank[i] = 0;",
            "      diff_weight[i] = def;",
            "    }",
            "  }",
            "  int find(int x){",
            "    if(par[x] == x)return x;",
            "    int r = find(par[x]);",
            "    diff_weight[x] += diff_weight[par[x]];",
            "    return par[x] = r;",
            "  }",
            "  T weight(int x){",
            "    find(x);",
            "    return diff_weight[x];",
            "  }",
            "  bool same(int x, int y){",
            "    return find(x) == find(y);",
            "  }",
            "  bool unite(int x, int y, T w){",
            "    w += weight(x), w -= weight(y);",
            "    x = find(x), y = find(y);",
            "    if(x == y)return false;",
            "    if(rank[x] < rank[y])swap(x, y), w = - w;",
            "    if(rank[x] == rank[y])rank[x]++;",
            "    par[y] = x;",
            "    diff_weight[y] = w;",
            "    return true;",
            "  }",
            "  T diff(int x, int y){",
            "    return weight(y) - weight(x);",
            "  }",
            "};",
            ""
        ]
    },
    "weighted_unionfind_use": {
        "prefix": "weighted_unionfind_use",
        "body": [
            "WeightedUnionFind<ll> wuf(n);",
            "wuf.find(x);",
            "weight(x);",
            "same(x, y);",
            "unite(x, y, w);",
            "diff(x, y);",
            ""
        ]
    },
    "unionfind_def": {
        "prefix": "unionfind_def",
        "body": [
            "typedef struct UnionFind_ {",
            "\tvector<int> par, rank_, siz;",
            "  UnionFind_(){}",
            "\texplicit UnionFind_(int n): rank_(n, 0), siz(n, 1) {",
            "    par.resize(n);",
            "    for(int i = 0; i < n; i++)par[i] = i;",
            "\t}",
            "\tint find(int x) {",
            "    if(par[x] == x)return x;",
            "    else return par[x] = find(par[x]);",
            "\t}",
            "\tbool same(int x, int y) {",
            "    if(find(x) == find(y))return true;",
            "    else return false;",
            "\t}",
            "\tbool unite(int x, int y){",
            "    int xp = find(x);",
            "    int yp = find(y);",
            "    if(xp == yp)return false;",
            "    if(rank_[xp] > rank_[yp]){",
            "      par[yp] = xp;",
            "      siz[xp] += siz[yp];",
            "    }",
            "    else if(rank_[xp] < rank_[yp]){",
            "      par[xp] = yp;",
            "      siz[yp] += siz[xp];",
            "    }",
            "    else {",
            "      par[yp] = xp;",
            "      siz[xp] += siz[yp];",
            "      rank_[xp]++;",
            "    }",
            "    return true;",
            "\t}",
            "  int size(int i){",
            "    return siz[find(i)];",
            "  }",
            "} UnionFind;",
            ""
        ]
    },
    "unionfind_use": {
        "prefix": "unionfind_use",
        "body": [
            "UnionFind uf(n);",
            "uf.unite(a, b);",
            "uf.same(a, b);",
            "uf.find(a);",
            ""
        ]
    },
    "lazy_segment_tree_def": {
        "prefix": "lazy_segment_tree_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            ""
        ]
    },
    "lazy_segment_tree_use": {
        "prefix": "lazy_segment_tree_use",
        "body": [
            ""
        ]
    },
    "RSQRUQ_def": {
        "prefix": "RSQRUQ_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            "",
            "template <typename T, typename E>",
            "class RSQRUQ{",
            "  public:",
            "    using value_type = T;",
            "    using lazy_type = E;",
            "    const static T identity = 0;",
            "    const static E lazy_def = numeric_limits<E>::min();",
            "    RSQRUQ(){}",
            "    static T operation(T &l, T &r){",
            "      return l + r;",
            "    }",
            "    static E lazy_accumulate(E &l, E &r){",
            "      return r;",
            "    }",
            "    static T lazy_update(T &t, E &e, int len){",
            "      return e * len;",
            "    }",
            "};",
            ""
        ]
    },
    "RSQRUQ_use": {
        "prefix": "RSQRUQ_use",
        "body": [
            "LazySegmentTree<RSQRUQ<ll, ll>> seg(n);",
            ""
        ]
    },
    "RMQRAQ_def": {
        "prefix": "RMQRAQ_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            "",
            "template <typename T, typename E>",
            "class RMQRAQ{",
            "  public:",
            "    using value_type = T;",
            "    using lazy_type = E;",
            "    const static T identity = numeric_limits<T>::max();",
            "    const static E lazy_def = 0;",
            "    RMQRAQ(){}",
            "    static T operation(T &l, T &r){",
            "      return min(l, r);",
            "    }",
            "    static E lazy_accumulate(E &l, E &r){",
            "      return l + r;",
            "    }",
            "    static T lazy_update(T &t, E &e, int len){",
            "      return t + e;",
            "    }",
            "};",
            ""
        ]
    },
    "RMQRAQ_use": {
        "prefix": "RMQRAQ_use",
        "body": [
            "LazySegmentTree<RMQRAQ<ll, ll>> seg(n);",
            ""
        ]
    },
    "RSQRAQ_def": {
        "prefix": "RSQRAQ_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            "",
            "template <typename T, typename E>",
            "class RSQRAQ{",
            "  public:",
            "    using value_type = T;",
            "    using lazy_type = E;",
            "    const static T identity = 0;",
            "    const static E lazy_def = 0;",
            "    RSQRAQ(){}",
            "    static T operation(T &l, T &r){",
            "      return l + r;",
            "    }",
            "    static E lazy_accumulate(E &l, E &r){",
            "      return l + r;",
            "    }",
            "    static T lazy_update(T &t, E &e, int len){",
            "      return t + e * len;",
            "    }",
            "};",
            ""
        ]
    },
    "RSQRAQ_use": {
        "prefix": "RSQRAQ_use",
        "body": [
            "LazySegmentTree<RSQRAQ<ll, ll>> seg(n);",
            ""
        ]
    },
    "RMQRUQ_def": {
        "prefix": "RMQRUQ_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            "",
            "template <typename T, typename E>",
            "class RMQRUQ{",
            "  public:",
            "    using value_type = T;",
            "    using lazy_type = E;",
            "    const static T identity = numeric_limits<T>::max();",
            "    const static E lazy_def = numeric_limits<E>::min();",
            "    RMQRUQ(){}",
            "    static T operation(T &l, T &r){",
            "      return min(l, r);",
            "    }",
            "    static E lazy_accumulate(E &l, E &r){",
            "      return r;",
            "    }",
            "    static T lazy_update(T &t, E &e, int len){",
            "      return e;",
            "    }",
            "};",
            ""
        ]
    },
    "RMQRUQ_use": {
        "prefix": "RMQRUQ_use",
        "body": [
            "LazySegmentTree<RMQRUQ<ll, ll>> seg(n);",
            ""
        ]
    },
    "RAQ_def": {
        "prefix": "RAQ_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            "",
            "template <typename T, typename E>",
            "class RAQ{",
            "  public:",
            "    using value_type = T;",
            "    using lazy_type = E;",
            "    const static T identity = 0;",
            "    const static E lazy_def = 0;",
            "    RAQ(){}",
            "    static T operation(T &l, T &r){",
            "      return l + r;",
            "    }",
            "    static E lazy_accumulate(E &l, E &r){",
            "      return l + r;",
            "    }",
            "    static T lazy_update(T &t, E &e, int len){",
            "      return t + e * len;",
            "    }",
            "};",
            ""
        ]
    },
    "RAQ_use": {
        "prefix": "RAQ_use",
        "body": [
            "LazySegmentTree<RAQ<ll, ll>> seg(n);",
            ""
        ]
    },
    "RUQ_def": {
        "prefix": "RUQ_def",
        "body": [
            "template <typename Monoid>",
            "class LazySegmentTree{",
            "  public:",
            "    using T = typename Monoid::value_type;",
            "    using E = typename Monoid::lazy_type;",
            "    int n;",
            "    T identity;",
            "    E lazy_def;",
            "    vector<T> val;",
            "    vector<E> lazy;",
            "",
            "    LazySegmentTree(){}",
            "    LazySegmentTree(int n_, vector<T> v=vector<T>()){",
            "      identity = Monoid::identity;",
            "      lazy_def = Monoid::lazy_def;",
            "      n = 1;",
            "      while(n < n_)n *= 2;",
            "      val.assign(2*n-1, identity);",
            "      lazy.assign(2*n-1, lazy_def);",
            "",
            "      for(size_t i = 0; i < v.size(); i++){",
            "        val[i+n-1] = v[i];",
            "      }",
            "      for(int i = n - 2; i >= 0; i--){",
            "        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);",
            "      }",
            "    }",
            "    void eval(int k, int len){",
            "      if(lazy[k] == lazy_def)return;",
            "      if(k < n - 1){",
            "        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);",
            "        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);",
            "      }",
            "      val[k] = Monoid::lazy_update(val[k], lazy[k], len);",
            "      lazy[k] = lazy_def;",
            "    }",
            "    T update(int a,int b, E &e, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return val[k];",
            "      else if(a <= l && r <= b){",
            "        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);",
            "        eval(k, r - l);",
            "        return val[k];",
            "      }else{",
            "        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);",
            "        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);",
            "        return val[k] = Monoid::operation(lv, rv);",
            "      }",
            "    }",
            "    T update(int a, int b, E e){",
            "      return update(a, b, e, 0, 0, n);",
            "    }",
            "    T query(int a, int b, int k, int l, int r){",
            "      eval(k, r - l);",
            "      if(r <= a || b <= l)return identity;",
            "      if(a <= l && r <= b)return val[k];",
            "      T lv = query(a, b, 2*k+1, l, (l+r)/2);",
            "      T rv = query(a, b, 2*k+2, (l+r)/2, r);",
            "      return Monoid::operation(lv, rv);",
            "    }",
            "    T query(int a, int b){",
            "      return query(a, b, 0, 0, n);",
            "    }",
            "    T get(int i){",
            "      return query(i, i + 1);",
            "    }",
            "};",
            "",
            "template <typename T, typename E>",
            "class RUQ{",
            "  public:",
            "    using value_type = T;",
            "    using lazy_type = E;",
            "    const static T identity = 0;",
            "    const static E lazy_def = numeric_limits<E>::min();",
            "    RUQ(){}",
            "    static T operation(T &l, T &r){",
            "      return l + r;",
            "    }",
            "    static E lazy_accumulate(E &l, E &r){",
            "      return r;",
            "    }",
            "    static T lazy_update(T &t, E &e, int len){",
            "      return e * len;",
            "    }",
            "};",
            ""
        ]
    },
    "RUQ_use": {
        "prefix": "RUQ_use",
        "body": [
            "LazySegmentTree<RUQ<ll, ll>> seg(n);",
            ""
        ]
    },
    "diameter_def": {
        "prefix": "diameter_def",
        "body": [
            "template <typename T>",
            "struct edge{",
            "  int from, to;",
            "  T w;",
            "  edge(){}",
            "  edge(int from, int to, T w): from(from), to(to), w(w){}",
            "};",
            "",
            "template <typename T>",
            "struct Tree{",
            "  int n = 0;",
            "  vector<vector<edge<T>>> edges;",
            "  vector<T> dis;",
            "  Tree(){}",
            "  explicit Tree(int n): n(n){",
            "    edges.resize(n);",
            "    dis.resize(n);",
            "  }",
            "  void adde(int from, int to, T cost){",
            "    edges[from].emplace_back(from, to, cost);",
            "  }",
            "  void dfs(int i){",
            "    for(auto e: edges[i]){",
            "      if(dis[e.to] == -1){",
            "        dis[e.to] = dis[i] + e.w;",
            "        dfs(e.to);",
            "      }",
            "    }",
            "  }",
            "  T diameter(){",
            "    dis.assign(n, -1);",
            "    dis[0] = 0;",
            "    dfs(0);",
            "    int at = 0;",
            "    T maxi = -1;",
            "    for(int i = 0; i < n; i++){",
            "      if(maxi < dis[i]){",
            "        maxi = dis[i];",
            "        at = i;",
            "      }",
            "    }",
            "    dis.assign(n, -1);",
            "    dis[at] = 0;",
            "    dfs(at);",
            "    T res = -1;",
            "    for(int i = 0; i < n; i++){",
            "      res = max(res, dis[i]);",
            "    }",
            "    return res;",
            "  }",
            "};",
            ""
        ]
    },
    "diameter_use": {
        "prefix": "diameter_use",
        "body": [
            "Tree<long long> t = Tree<long long>(n);",
            "t.adde(u, v, w);",
            "t.diameter();",
            ""
        ]
    },
    "heavy_light_decomposition_def": {
        "prefix": "heavy_light_decomposition_def",
        "body": [
            "template <typename T>",
            "struct HeavyLightDecomposition{",
            "  struct edge{",
            "    int to;",
            "    T w;",
            "    edge(int to, T w): to(to), w(w){}",
            "  };",
            "  int n, cid;",
            "  vector<vector<edge>> edges;",
            "  vector<int> par, chain, depth, siz, pos_seg, head;",
            "  vector<T> parw;",
            "  HeavyLightDecomposition(){}",
            "  explicit HeavyLightDecomposition(int n): n(n){",
            "    edges.resize(n);",
            "    par.resize(n, -1);",
            "    chain.resize(n, -1);",
            "    depth.resize(n, -1);",
            "    siz.resize(n, 1);",
            "    pos_seg.resize(n, -1);",
            "    head.resize(n, -1);",
            "    parw.resize(n);",
            "  }",
            "  void adde(int from, int to, T w){",
            "    edges[from].emplace_back(to, w);",
            "  }",
            "  void build(int r = 0){",
            "    par.assign(n, -1);",
            "    chain.assign(n, -1);",
            "    depth.assign(n, -1);",
            "    siz.assign(n, -1);",
            "    pos_seg.assign(n, -1);",
            "",
            "    dfs(r);",
            "",
            "    hld(r);",
            "  }",
            "  void dfs(int r = 0){",
            "    par[r] = r;",
            "    depth[r] = 0;",
            "    deque<int> dq;",
            "    dq.push_back(r);",
            "",
            "    int l = 0;",
            "    while(l < (int)dq.size()){",
            "      int i = dq[l];",
            "      siz[i] = 1;",
            "      for(auto &e: edges[i]){",
            "        if(par[e.to] != -1)continue;",
            "        par[e.to] = i;",
            "        parw[e.to] = e.w;",
            "        depth[e.to] = depth[i] + 1;",
            "        dq.push_back(e.to);",
            "      }",
            "      l++;",
            "    }",
            "    while(!dq.empty()){",
            "      int i = dq.back(); dq.pop_back();",
            "      if(par[i] != i){",
            "        siz[par[i]] += siz[i];",
            "      }",
            "    }",
            "  }",
            "  void hld(int r = 0){",
            "    cid = 0;",
            "    chain[r] = cid;",
            "    pos_seg[r] = 0;",
            "    head[r] = r;",
            "",
            "    stack<int> st;",
            "    st.push(r);",
            "",
            "    while(!st.empty()){",
            "      int i = st.top(); st.pop();",
            "      int max_siz = 0;",
            "      int idx = -1;",
            "      for(auto &e: edges[i]){",
            "        if(par[e.to] != i)continue;",
            "        if(max_siz < siz[e.to]){",
            "          max_siz = siz[e.to];",
            "          idx = e.to;",
            "        }",
            "      }",
            "      if(idx == -1)continue;",
            "      for(auto &e: edges[i]){",
            "        if(par[e.to] != i)continue;",
            "        if(idx == e.to){",
            "          chain[e.to] = chain[i];",
            "          pos_seg[e.to] = pos_seg[i] + 1;",
            "          head[e.to] = head[i];",
            "          st.push(e.to);",
            "        }else{",
            "          chain[e.to] = ++cid;",
            "          pos_seg[e.to] = 0;",
            "          head[e.to] = e.to;",
            "          st.push(e.to);",
            "        }",
            "      }",
            "    }",
            "  }",
            "  int lca(int u, int v){",
            "    while(true){",
            "      if(chain[u] == chain[v]){",
            "        if(depth[u] < depth[v])return u;",
            "        else return v;",
            "      }",
            "      if(depth[head[u]] > depth[head[v]])swap(u, v);",
            "      v = par[head[v]];",
            "    }",
            "  }",
            "};",
            ""
        ]
    },
    "heavy_light_decomposition_use": {
        "prefix": "heavy_light_decomposition_use",
        "body": [
            "HeavyLightDecomposition<int> hld(n);",
            "hld.adde(u, v, w);",
            "hld.lca(u, v);",
            ""
        ]
    },
    "euler_tour_def": {
        "prefix": "euler_tour_def",
        "body": [
            "struct EulerTourTree{",
            "  int n = 0;",
            "  vector<vector<int>> edges;",
            "  vector<int> b, e;",
            "  vector<int> v;",
            "  EulerTourTree(){}",
            "  explicit EulerTourTree(int n): n(n){",
            "    edges.resize(n);",
            "    b.resize(n);",
            "    e.resize(n);",
            "    v.reserve(2 * n - 1);",
            "  }",
            "  void adde(int from, int to){",
            "    edges[from].emplace_back(to);",
            "  }",
            "  void dfs(int i){",
            "    v.emplace_back(i);",
            "    b[i] = int(v.size()) - 1;",
            "    for(auto c: edges[i]){",
            "      if(b[c] == -1){",
            "        dfs(c);",
            "        v.emplace_back(i);",
            "      }",
            "    }",
            "    e[i] = int(v.size()) - 1;",
            "  }",
            "  void build(int r = 0){",
            "    b.assign(n, -1);",
            "    e.assign(n, -1);",
            "    v.resize(0);",
            "    dfs(r);",
            "  }",
            "};",
            ""
        ]
    },
    "euler_tour_use": {
        "prefix": "euler_tour_use",
        "body": [
            "EulerTourTree ett(n);",
            "ett.adde(u, v);",
            "ett.build();",
            ""
        ]
    },
    "lowest_common_ancestor_def": {
        "prefix": "lowest_common_ancestor_def",
        "body": [
            "struct LCATree{",
            "  int n = 0, m = 0;",
            "  vector<vector<int>> edge;",
            "  vector<vector<int>> par;",
            "  vector<bool> vis;",
            "  vector<int> h;",
            "  LCATree(){}",
            "  LCATree(int n): n(n){",
            "    while((1LL<<m) <= n)m++;",
            "    edge.resize(n);",
            "    par.assign(m + 1, vector<int>(n, 0));",
            "    vis.resize(n, false);",
            "    h.resize(n);",
            "  }",
            "  void adde(int from, int to){",
            "    edge[from].emplace_back(to);",
            "  }",
            "  void dfs(int i){",
            "    vis[i] = true;",
            "    for(auto e: edge[i]){",
            "      if(!vis[e]){",
            "        par[0][e] = i;",
            "        h[e] = h[i] + 1;",
            "        dfs(e);",
            "      }",
            "    }",
            "  }",
            "  void build(){",
            "    fill(vis.begin(), vis.end(), false);",
            "    fill(h.begin(), h.end(), 0);",
            "    par[0][0] = 0;",
            "    h[0] = 0;",
            "    dfs(0);",
            "    for(int i = 1; i <= m; i++){",
            "      for(int j = 0; j < n; j++){",
            "        par[i][j] = par[i-1][par[i-1][j]];",
            "      }",
            "    }",
            "  }",
            "  int go_up(int u, int k){",
            "    int i = 0;",
            "    while(k){",
            "      if(k % 2 == 1){",
            "        u = par[i][u];",
            "      }",
            "      i++;",
            "      k /= 2;",
            "    }",
            "    return u;",
            "  }",
            "  int lca(int u, int v){",
            "    if(h[u] > h[v])u = go_up(u, h[u] - h[v]);",
            "    if(h[u] < h[v])v = go_up(v, h[v] - h[u]);",
            "    if(u == v)return u;",
            "    int ld = 0, rd = n;",
            "    while(rd - ld > 1){",
            "      int k = (rd + ld) / 2;",
            "      int uk = go_up(u, k);",
            "      int vk = go_up(v, k);",
            "      if(uk == vk)rd = k;",
            "      else ld = k;",
            "    }",
            "    return go_up(u, rd);",
            "  }",
            "};",
            ""
        ]
    },
    "lowest_common_ancestor_use": {
        "prefix": "lowest_common_ancestor_use",
        "body": [
            "LCATree t(n);",
            "t.adde(u, v);",
            "t.build();",
            "t.lca(a, b);",
            ""
        ]
    },
    "procontemplate": {
        "prefix": "procontemplate",
        "body": [
            "// includes",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "// macros",
            "#define pb emplace_back",
            "#define mk make_pair",
            "#define FOR(i, a, b) for(int i=(a);i<(b);++i)",
            "#define rep(i, n) FOR(i, 0, n)",
            "#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)",
            "#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)",
            "#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)",
            "#define whole(x) (x).begin(),(x).end()",
            "#define sz(x) ((int)(x).size())",
            "#define bit(n) (1LL<<(n))",
            "// functions",
            "template <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}",
            "template <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}",
            "template <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}",
            "template <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}",
            "template <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}",
            "template <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}",
            "template <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}",
            "template <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}",
            "template <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}",
            "template <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}",
            "template <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}",
            "template <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}",
            "//  types",
            "using ll = long long int;",
            "using P = pair<int, int>;",
            "// constants",
            "const int inf = 1e9;",
            "const ll linf = 1LL << 50;",
            "const double EPS = 1e-10;",
            "const int mod = 1000000007;",
            "const int dx[4] = {-1, 0, 1, 0};",
            "const int dy[4] = {0, -1, 0, 1};",
            "// io",
            "struct fast_io{",
            "  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}",
            "} fast_io_;",
            "",
            "",
            "int main(int argc, char const* argv[])",
            "{",
            "",
            "  return 0;",
            "}",
            ""
        ]
    }
}