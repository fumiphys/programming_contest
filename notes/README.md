# notes

## 括弧
 - (: +1, ): -1で累積和をとる. (非負かつ総和が0)
 - stackに入れていく.
 
## 最小の操作数
 - グラフにできる場合がある. Dijkstra. (辺の長さが全て1ならBFS)

## 数学
 - 約数列挙が複数必要 -> エラストテレスでO(nlogn)
 - 二項係数はパスカルの三角形でも計算できる(素数でない時など)
 - どの桁が異なるかみる -> 各桁に異なる素数を対応させて積の和をとる(sum(d[i]*p[i])) -> 差がどの素数の倍数かでわかる.

## 組み合わせ
 - (i - j) -> i (i - k <= j < i)のような遷移: k項間のフィボナッチ(行列塁累乗, きたまさ)
 - 方程式を満たすものの個数: (l) = (r)(l, rが独立)の形にして, (lがiになる個数) * (rがiになる個数) (かけたり引いたりするとうまくできる)
 - N=30, 40なら半分全列挙かも
 - 順列は挿入DP(dp[i][j]: i番目まででj個assignした時の組み合わせ)
 - NGな組み合わせがある場合は包除原理かも (撹乱順列の可能性もある?)
 
## 漸化式
 - 第k項についてkが大きすぎるときは行列累乗か一般項など
 - 間に合いそうになければきたまさ
 - 多項式でかけそうなら多項式補間 (ex. dp[x][i] = dp[x-1][i] + dp[x][i-k])
 - 値に制限があれば周期性があるかも

## DP
 - 順番の全列挙で階乗の計算量が必要になる場合はbitDPができる可能性がある.
 - boolを値としてもつDPはindexを一つ減らせるかも

## 二分探索
 - 答えが決まった時にすぐわかるなら二分探索

## グラフ
 - 平面グラフ -> オイラーの定理
 
## ゲーム
 - N言っちゃダメ -> (N - 1)言いたい

## マッチング
 - 貪欲にできる場合が多い
 - 厳しそうならフロー
 - 2SATが使える場合もあるらしい(https://yukicoder.me/problems/no/483)

## 辞書順
 - 貪欲に使えるかどうかを計算していく

## 素数
 - 3以上の偶数は素数の和で表せる(ゴールドバッハ予想)

## その他
 - -1で初期化した配列に対して最後にminをとる時に-1にならないように気をつける.
 - 埋め込み
 - 日付系はpythonでやると楽
 - 数字を入れ替えて大きくする -> 右に自分より大きいものがあればswap

### __int128_t
 - どうしてもオーバーフローしてしまうとき
 - operator<<は自分で定義する必要がある
