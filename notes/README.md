# notes

## 括弧
 - (: +1, ): -1で累積和をとる. (非負かつ総和が0)
 - stackに入れていく.
 
## 最小の操作数
 - グラフにできる場合がある. Dijkstra. (辺の長さが全て1ならBFS)

## 数学
 - 約数列挙が複数必要 -> エラストテレスでO(nlogn)
 - 二項係数はパスカルの三角形でも計算できる(素数でない時など)
 - どの桁が異なるかみる -> 各桁に異なる素数を対応させて積の和をとる(sum(d[i]*p[i])) -> 差がどの素数の倍数かでわかる.
 - 3を使わない場合各桁の和が3の倍数になるのは2/3個
 - 数式で困ったらwolfram alpha
 - 数列で困ったらOEIS
 -　無限和\sum_n=1^infの誤差を推定する時, ∫x=n+1^infで積分した値で近似できる
 - 三次方程式は異なる実数解が3つあることが保証されているときは右端, 左端をニュートン法, 真ん中を二分探索で求められる.
 (極値を二次方程式といて求めて3つの区間で二分探索でも良い)
 - 整式=0の方程式で, 解の範囲が|x|<Hとわかっているときは, mod sqrt(H)で方程式をといて, sqrt(H)+αの形を全探索できる.
 - 格子点上の三角形の面積: |ad-bc|=Sとなるときs=ceil(S)とすると, a=s, b=1とすると, sd-c=Sとなり商と余りみたいになる

## 文字列
 - 前後に文字を追加していく系の問題はどこで切れるか考えると良いかも

## 組み合わせ
 - (i - j) -> i (i - k <= j < i)のような遷移: k項間のフィボナッチ(行列塁累乗, きたまさ)
 - 方程式を満たすものの個数: (l) = (r)(l, rが独立)の形にして, (lがiになる個数) * (rがiになる個数) (かけたり引いたりするとうまくできる)
 - N=30, 40なら半分全列挙かも
 - 順列は挿入DP(dp[i][j]: i番目まででj個assignした時の組み合わせ)
 - NGな組み合わせがある場合は包除原理かも (撹乱順列の可能性もある?)
 - A以上B以下のものの中で -> (B以下) - (A-1以下)
 
## 漸化式
 - 第k項についてkが大きすぎるときは行列累乗か一般項など
 - 間に合いそうになければきたまさ
 - 多項式でかけそうなら多項式補間 (ex. dp[x][i] = dp[x-1][i] + dp[x][i-k])
 - 値に制限があれば周期性があるかも

## DP
 - 順番の全列挙で階乗の計算量が必要になる場合はbitDPができる可能性がある.
 - boolを値としてもつDPはindexを一つ減らせるかも
 - 桁DPでnの倍数を考えるとき, 3の倍数以外はsum <- sum * 10 + iになる

## 二分探索
 - 答えが決まった時にすぐわかるなら二分探索

## グラフ
 - 平面グラフ -> オイラーの定理

## 木
 - 頂点と頂点の間のパスについて操作するのは根と頂点, LCAとの操作に置き換えられる
 - 葉同士のパスで操作をする時に葉以外の次数が3以上なら葉と任意の頂点とで操作できる
 (leaf1とnode1の間の操作で, node1とleaf2, 3が繋がっているならleaf1:leaf2+leaf1:leaf3-leaf2:leaf3)
 
## ゲーム
 - N言っちゃダメ -> (N - 1)言いたい

## マッチング
 - 貪欲にできる場合が多い
 - 厳しそうならフロー
 - 2SATが使える場合もあるらしい(https://yukicoder.me/problems/no/483)

## 辞書順
 - 貪欲に使えるかどうかを計算していく

## 素数
 - 3以上の偶数は素数の和で表せる(ゴールドバッハ予想)

## その他
 - -1で初期化した配列に対して最後にminをとる時に-1にならないように気をつける.
 - 埋め込み
 - 日付系はpythonでやると楽
 - 数字を入れ替えて大きくする -> 右に自分より大きいものがあればswap

### __int128_t
 - どうしてもオーバーフローしてしまうとき
 - operator<<は自分で定義する必要がある
