# notes

## links
 - [theorem](./theorem.md)
 - [algorithm](./algorithm.md)
 - [data\_structure](./data_structure.md)

## 括弧
 - (: +1, ): -1で累積和をとる. (非負かつ総和が0)
 - stackに入れていく.
 
## 最小の操作数
 - グラフにできる場合がある. Dijkstra. (辺の長さが全て1ならBFS)

## 数学
 - 約数列挙が複数必要 -> エラストテレスでO(nlogn)
 - 二項係数はパスカルの三角形でも計算できる(素数でない時など)
 - どの桁が異なるかみる -> 各桁に異なる素数を対応させて積の和をとる(sum(d[i]*p[i])) -> 差がどの素数の倍数かでわかる.
 - 3を使わない場合各桁の和が3の倍数になるのは2/3個
 - 数式で困ったらwolfram alpha
 - 数列で困ったらOEIS
 -　無限和\sum_n=1^infの誤差を推定する時, ∫x=n+1^infで積分した値で近似できる
 - 三次方程式は異なる実数解が3つあることが保証されているときは右端, 左端をニュートン法, 真ん中を二分探索で求められる.
 (極値を二次方程式といて求めて3つの区間で二分探索でも良い)
 - 整式=0の方程式で, 解の範囲が|x|<Hとわかっているときは, mod sqrt(H)で方程式をといて, sqrt(H)+αの形を全探索できる.
 - 格子点上の三角形の面積: |ad-bc|=Sとなるときs=ceil(S)とすると, a=s, b=1とすると, sd-c=Sとなり商と余りみたいになる
 - floor((k-1)*n/k) = n - floor(n/k) - 1 (n/kでまとめた数が同じなら mod (floor(n/k)+1)をとることで計算量が削減できる)
 - 2倍は1ビットシフト
 - aまたはbで割れるかずはLCM(GCDではない)
 - A以上B以下などの範囲でbitを考えるときは, 先頭からどこまで1が立っているかを考えると良い場合が多い
 - k個の平均をとる場合(とくに平均をとる値が0, 1の時), k進数で考えると和と桁を一つずらすと考えることができる

## 素数
 - 3以上の偶数は素数の和で表せる(ゴールドバッハ予想)

## 数列
 - 数列でi<jならa[i]<a[j]なるような列に数列を分解するとき, 最小の列の数は元の数列の最小非減少部分列の長さに等しい(数列をDAG(i<jかつa[i]<a[j]なら辺を貼る)にした時のdilworthの定理から従う.
 - 数列のk個以下の要素を-1倍して総和などを出す -> 元の総和 - 2 * (数列からk個以下選んで総和をとる)
 - 2項間漸化式は解ける

## クエリ
 - 先読みできる場合は座標圧縮して大きい方か小さい方か見れる

## 中央値
 - 中央値は(a[(n-1)/2]+a[n/2])/2
 - Σ|x-a[i]|の最小値は偶数なら(indexがn/2以上のものの和) - (indexがn/2より小さいものの和)
                    奇数なら(indexがn/2+1以上のものの和) - (indexがn/2より小さいものの和)

## 文字列
 - 前後に文字を追加していく系の問題はどこで切れるか考えると良いかも
 - 先頭または末尾の文字が決まっている場合は文字列を前後に追加すると良い場合がある.
 (ex: 文字列をIOI...OIにするときの編集距離が欲しい -> 前後にIOとOIを追加して, 同じ文字が奇数個なら偶数番目を変える, 偶数個なら1文字消す)

## 組み合わせ
 - (i - j) -> i (i - k <= j < i)のような遷移: k項間のフィボナッチ(行列塁累乗, きたまさ)
 - 方程式を満たすものの個数: (l) = (r)(l, rが独立)の形にして, (lがiになる個数) * (rがiになる個数) (かけたり引いたりするとうまくできる)
 - N=30, 40なら半分全列挙かも
 - 順列は挿入DP(dp[i][j]: i番目まででj個assignした時の組み合わせ)
 - NGな組み合わせがある場合は包除原理かも (撹乱順列の可能性もある?)
 - A以上B以下のものの中で -> (B以下) - (A-1以下)

## 数え上げ
 - 状態をまとめる: 遷移先が同じ, 遷移につく係数が同じ, 状態の全てが問題の条件を満たす, または満たさない -> 状態をまとめられるかも
 - 集合の数などを考えるときは, 勝手に順番を決めてあげるとうまくいくことがある
 - 順列は適当な順番に並べて順に挿入していく
 - 区間は終点でソートしてDP
 - 条件を言い換える(必要条件が実は十分条件になっていることもある)
 - 最終的にできるもののdistinctな個数を数えるような問題 -> 操作列と最終結果が1対1に対応しない.
 最終結果と1対1に対応するような操作列のみに制限して数える (例えばgreedyに)
 ある最終結果が得られるか判定するために必要な情報などをDPのindexにする
 - 個数制限がないナップサックや部分和問題 -> 2^i個まとめて考えれば01になる.
 
## 漸化式
 - 第k項についてkが大きすぎるときは行列累乗か一般項など
 - 間に合いそうになければきたまさ
 - 多項式でかけそうなら多項式補間 (ex. dp[x][i] = dp[x-1][i] + dp[x][i-k])
 - 値に制限があれば周期性があるかも

## DP
 - 順番の全列挙で階乗の計算量が必要になる場合はbitDPができる可能性がある.
 - boolを値としてもつDPはindexを一つ減らせるかも
 - DPのindexと値を入れ替えるとうまくいく場合がある. 
 (例: dp[i][j]: i番目までで重さjの時の最大価値, dp2[i][j]: i番目までで価値jを達成するための最小重み)
 - 桁DPでnの倍数を考えるとき, 3の倍数以外はsum <- sum * 10 + iになる
 - 期待値を求める問題は漸化式を変形すると良い (dp[i] = p * dp[i] + (1-p) * dp[k] + 1 -> (1-p)dp[i] = (1-p)dp[k] + 1)

## 二分探索
 - 答えが決まった時にすぐわかるなら二分探索

## グラフ
 - 平面グラフ -> オイラーの定理
 - ループ検出してループ内の何かの値を足すような操作 -> 強連結成分分解でできる(単純なループじゃない場合もできる)
 - 閉路検出や連結成分はUnionFindでできる

## 木
 - 頂点と頂点の間のパスについて操作するのは根と頂点, LCAとの操作に置き換えられる
 - 葉同士のパスで操作をする時に葉以外の次数が3以上なら葉と任意の頂点とで操作できる
 (leaf1とnode1の間の操作で, node1とleaf2, 3が繋がっているならleaf1:leaf2+leaf1:leaf3-leaf2:leaf3)
 - 各頂点でdp[i][j]: i個目の子までで, j(<=i個目の部分木までの頂点数)というDPができるなら二乗の木DP. (各頂点でのDPは配るDPにするのが安全)

## グリッド
 - グリッドは2部グラフ(マンハッタン距離の偶奇)
 - グリッドを直線で分断するような問題: 90度回転を4回すれば場合分けがいらない
 - 片方のグリッド幅が小さい時は列ごとにbitDPできる可能性がある. (行ごとの更新で0(4^WHW), 1マスごとの更新でO(2^WHW))
 - 同じ列, 同じ行に2つ駒が並ばないようにNxNグリッドにN個の駒を並べる -> 行の順, または列の順に見ると順列.他の条件を満たすように並べるなら挿入DP
 
## ゲーム
 - N言っちゃダメ -> (N - 1)言いたい

## マッチング
 - 貪欲にできる場合が多い
 - 厳しそうならフロー
 - 2SATが使える場合もあるらしい(https://yukicoder.me/problems/no/483)

## 辞書順
 - 貪欲に使えるかどうかを計算していく

## その他
 - -1で初期化した配列に対して最後にminをとる時に-1にならないように気をつける.
 - 埋め込み
 - 日付系はpythonでやると楽
 - 多倍長がめんどくさい時はpythonでもいいがfloatは無限精度ではない.
 - 数字を入れ替えて大きくする -> 右に自分より大きいものがあればswap
 - priority_queueは便利
 - Ax+By<=Cとい条件を満たすy(整数)を求める時に, y<=(C-Ax)/Bだが, C-Ax<0でも(C-Ax)/B=0となることがあるので注意
 - HW<=Nの時少なくとも片方は<=sqrt(N)

### __int128_t
 - どうしてもオーバーフローしてしまうとき
 - operator<<は自分で定義する必要がある
