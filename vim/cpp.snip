snippet bw_def
  string bwt_sa(string s) {
    SAManberMyers sa = SAManberMyers(s);
    string res = "";
    for(int i = 0; i <= s.size(); i++){
      if(sa.sa[i] == 0)res += '$';
      else res += s[sa.sa[i] - 1];
    }
    return res;
  }

  string inverse_bwt(string s) {
    string res = "";
    vector<int> C = vector<int>(27, 0);
    vector<int> psi = vector<int>(s.size(), 0);
    int p = 0;

    for(int i = 0; i < s.size(); i++){
      if(s[i] == '$'){
        C[0]++;
      }
      else C[s[i] - 'a' + 1]++;
    }
    int sum = 0;
    for(int i = 0; i <= 26; i++){
      int tmp = C[i];
      C[i] = sum;
      sum += tmp;
    }

    for(int i = 0; i < s.size(); i++){
      int c;
      if(s[i] == '$')c = 0;
      else c = int(s[i] - 'a' + 1);
      psi[C[c]] = i;
      C[c]++;
    }

    for(int i = 0; i < s.size(); i++){
      p = psi[p];
      res += s[p];
    }

    return res.substr(1, res.size() - 1);
  }

snippet bw_use
  string tb = bwt_sa(s);

snippet suffixarray_use
  SAManberMyers sa = SAManberMyers(s);

snippet suffixarray_def
  typedef struct SAManberMyers_ {
    string s;
    vector<int> rank;
    vector<int> tmp;
    vector<int> sa;
    int n, k;
    SAManberMyers_(string ss){
      s = ss;
      n = s.size();
      rank.resize(n + 1);
      tmp.resize(n + 1);
      sa.resize(n + 1);
      k = 0;

      // construct suffix array
      construct();
    }
    bool comp(const int &a, const int &b){
      if(rank[a] != rank[b])return rank[a] < rank[b];
      int ra = a + k <= n ? rank[a + k] : -1;
      int rb = b + k <= n ? rank[b + k] : -1;
      return ra < rb;
    }
    void construct(){
      for(int i = 0; i <= n; i++){
        sa[i] = i;
        rank[i] = i < n ? s[i] : -1;
      }

      for(k = 1; k <= n; k *= 2){
        sort(sa.begin(), sa.end(), [this] (const int &a, const int &b) {return comp(a, b);});

        tmp[sa[0]] = 0;
        for(int i = 1; i <= n; i++){
          tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1], sa[i]) ? 1 : 0);
        }
        for(int i = 0; i <= n; i++){
          rank[i] = tmp[i];
        }
      }
    }
  } SAManberMyers;

snippet brute_search_use
  res = find_text(s, t);

snippet kmp_search_use
  res = kmp_search(s, t);

snippet bm_search_use
  res = bm_search(s, t);

snippet sa_search_use
  res = sa_search(s, t);

snippet brute_search_def
  vector<int> find_text(string s, string t) {
    vector<int> res;
    for(int i = 0; i + t.size() <= s.size(); i++){
      bool flag = true;
      for(int j = 0; j < t.size(); j++){
        if(s[i + j] != t[j]){
          flag = false;
          break;
        }
      }
      if(flag)res.push_back(i);
    }
    return res;
  }

snippet kmp_search_def
  vector<int> kmp_table(string t){
    vector<int> res = vector<int>(t.size(), 0);
    int j = 0;
    for(int i = 1; i < t.size(); i++){
      if(t[i] == t[j]){
        j++;
      }else{
        j = 0;
      }
      res[i] = j;
    }
    return res;
  }

  // s: text, t: pattern
  vector<int> kmp_search(string s, string t){
    vector<int> res;
    vector<int> shift = kmp_table(t);

    // i: text index, p: pattern index
    int i = 0, p = 0;
    while(i < s.size() && p < t.size()){
      if(s[i] == t[p]){
        i++;
        p++;
      }else if(p == 0){
        i++;
      }else{
        p = shift[p - 1];
      }
      if(p == t.size()){
        res.push_back(i - p);
        p = shift[p - 1];
      }
    }

    return res;
  }

snippet bm_search_def
  // s: text, t: pattern
  vector<int> bm_search(string s, string t){
    vector<int> res;
    unordered_map<char, int> mp;
    for(int i = 0; i < t.size(); i++){
      mp[t[i]] = t.size() - 1 - i;
    }
    // i: text index, p: pattern index
    int i = t.size() - 1, p = t.size() - 1;
    while(i < s.size() && p < t.size()){
      if(s[i] == t[p]){
        i--;
        p--;
      }else{
        if(mp.find(s[i]) == mp.end()){
          i += t.size();
        }else{
          if(p >= t.size() - 1 - mp[s[i]])i += mp[s[i]];
          else i += t.size() - p + 1;
        }
        p = t.size() - 1;
      }
      if(p < 0){
        res.push_back(i + 1);
        i += t.size() + 1;
        p = t.size() - 1;
      }
    }

    return res;
  }

snippet sa_search_def
  vector<int> sa_search_(SAManberMyers &sa, string s, string t){
    vector<int> res;
    t += "$";
    s += "$";
    int ld = -1;
    int rd = sa.sa.size() - 1;
    while(rd - ld > 1){
      int md = (rd + ld) / 2;
      if(s.substr(sa.sa[md]) < t)ld = md;
      else rd = md;
    }
    t = t.substr(0, t.size() - 1);
    while(rd < sa.sa.size()){
      if(s.substr(sa.sa[rd], t.size()) != t)break;
      res.push_back(sa.sa[rd]);
      rd++;
    }
    sort(res.begin(), res.end());
    return res;
  }

  vector<int> sa_search(string s, string t){
    SAManberMyers sa(s);
    vector<int> res = sa_search_(sa, s, t);
    return res;
  }

snippet BIT_use
  BITI bt(10);

snippet BIT_def
  template<typename T>
  struct BIT_{
    int n;
    vector<T> bit;
    BIT_(){}
    BIT_(int n_){
      n = n_;
      bit = vector<T>(n+1, 0);
    }
    void add(int a, T w){
      for(int x = a; x < n; x |= (x + 1)){
        bit[x] += w;
      }
    }
    T sum(int a){
      T res = 0;
      for(int x = a; x >= 0; x = (x & (x + 1)) - 1){
        res += bit[x];
      }
      return res;
    }
    int lower_bound(T w){
      int x = 0;
      int m = 1;
      while(m <= n)m *= 2;
      for(int k = m; k > 0; k /= 2){
        if(x + k <= n && bit[x+k-1] < w){
          w -= bit[x+k-1];
          x += k;
        }
      }
      return x;
    }
  };

  typedef struct BIT_<int> BITI;
  typedef struct BIT_<long long> BITL;

snippet segtree_use
  SegmentTreeI seg = SegmentTreeI(n, [](int a, int b){return min(a, b);},
      [](int a,int b){return b;}, INT_MAX, v);

snippet segtree_def
  template<typename T, typename E>
  struct SegmentTree_ {
    function<T(T, T)> f;
    function<T(T, E)> g;
    int n;
    T def;
    vector<T> vec;
    SegmentTree_(){}
    SegmentTree_(int n_, function<T(T, T)> f_, function<T(T, E)> g_, T def_, vector<T> v=vector<T>()){
      f = f_;
      g = g_;
      def = def_;

      // initialize vector
      n = 1;
      while(n < n_){
        n *= 2;
      }
      vec = vector<T>(2*n -1, def);

      // initialize segment tree
      for(int i = 0; i < v.size(); i++){
        vec[i + n - 1] = v[i];
      }
      for(int i = n - 2; i >= 0; i--){
        vec[i] = f(vec[2*i+1], vec[2*i+2]);
      }
    }
    void update(int k, E val){
      k = k + n - 1;
      vec[k] = g(vec[k], val);
      while(k > 0){
        k = (k - 1) / 2;
        vec[k] = f(vec[2*k+1], vec[2*k+2]);
      }
    }
    // [l, r) -> [a, b) (at k)
    T query(int a, int b, int k, int l, int r){
      if(r <= a || b <= l)return def;
      if(a <= l && r <= b)return vec[k];
      T ld = query(a, b, 2*k+1, l, (l+r)/2);
      T rd = query(a, b, 2*k+2, (l+r)/2, r);
      return f(ld, rd);
    }
    T query(int a, int b){
      return query(a, b, 0, 0, n);
    }
  };

  template<typename T, typename E>
  using SegmentTree = struct SegmentTree_<T, E>;
  using SegmentTreeI = SegmentTree<int, int>;
  using SegmentTreeL = SegmentTree<long long, long long>;

snippet unionfind_use
  UnionFind uf(10);

snippet unionfind_def
  typedef struct UnionFind_ {
    vector<int> par;
    vector<int> rank_;
    UnionFind_(int n): rank_(n, 0) {
      for(int i = 0; i < n; i++)par.push_back(i);
    }
    int find(int x) {
      if(par[x] == x)return x;
      else return par[x] = find(par[x]);
    }
    bool same(int x, int y) {
      if(find(x) == find(y))return true;
      else return false;
    }
    bool unite(int x, int y){
      int xp = find(x);
      int yp = find(y);
      if(xp == yp)return false;
      if(rank_[xp] > rank_[yp])par[yp] = xp;
      else if(rank_[xp] < rank_[yp])par[xp] = yp;
      else {
        par[yp] = xp;
        rank_[xp]++;
      }
      return true;
    }
  } UnionFind;

snippet fordfulkerson_use
  GraphI graph(5);
  int res = graph.max_flow(0, 4);

snippet fordfulkerson_def
  template <typename T>
  struct edge {int to; T cap; int rev;};

  template <typename T>
  struct Graph_ {
    int n;
    vector<bool> used;
    vector<vector<edge<T>> > vec;
    Graph_(){}
    Graph_(int ns) {
      n = ns;
      used.resize(n);
      vec.resize(n);
    }
    void adde(int at, int to, T cap){
      vec[at].pb((edge<T>){to, cap, (int)vec[to].size()});
      vec[to].pb((edge<T>){at, 0, (int)vec[at].size() - 1});
    }
    T dfs(int s, int t, T f){
      if(s == t)return f;
      used[s] = true;
      for(int i = 0; i < vec[s].size(); i++){
        edge<T> &e = vec[s][i];
        if(!used[e.to] && e.cap > 0){
          int d = dfs(e.to, t, min(f, e.cap));
          if(d > 0){
            e.cap -= d;
            vec[e.to][e.rev].cap += d;
            return d;
          }
        }
      }
      return 0;
    }
    T min_cut(int s, int t){
      return max_flow(s, t);
    }
    T max_flow(int s, int t){
      T inf = numeric_limits<T>::max();
      T flow = 0;

      while(true){
        fill(used.begin(), used.end(), false);
        int f = dfs(s, t, inf);
        if(f == 0)return flow;
        flow += f;
      }
    }
  };

  typedef Graph_<int> GraphI;
  typedef Graph_<ll> GraphL;

snippet dijkstra_use
  GraphI graphi(4);
  graphi.dijkstra(1, 3);

snippet dijkstra_def
  template <typename T>
  struct Graph_ {
    int n;
    vector<vector<pair<int, T> > > edge;
    vector<T> dis;
    Graph_(int ns) {
      n = ns;
      edge.resize(n);
      dis.resize(n);
    }
    void dijkstra(int s){
      dijkstra(s, 0);
    }
    T dijkstra(int s, int t){
      // initialize
      fill(dis.begin(), dis.end(), -1);
      vector<bool> used;
      used.resize(n);
      fill(used.begin(), used.end(), false);
      dis[s] = 0;
      // dijkstra
      priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > q;
      q.push(make_pair(0, s));
      while(!q.empty()){
        pair<T, int> p = q.top(); q.pop();
        int at = p.second;
        T distance = p.first;
        if(used[at])continue;
        used[at] = true;
        for(auto itr = edge[at].begin(); itr != edge[at].end(); ++itr){
          int to = (*itr).first;
          T cost = (*itr).second;
          if(used[to])continue;
          if(dis[to] == -1 || dis[to] > distance + cost){
            q.push(make_pair(distance + cost, to));
            dis[to] = distance + cost;
          }
        }
      }
      return dis[t];
    }
    void adde(int at, int to, T cost){
      edge[at].push_back(make_pair(to, cost));
    }
    [[deprecated("This function takes O(edge[at].size()).")]]
    void remove(int at, int to){
      int index = -1;
      for(int i = 0; i < edge[at].size(); i++){
        if(edge[at][i].first == to){
          index = i;
          break;
        }
      }
      edge[at].erase(edge[at].begin() + index);
    }
  };

  typedef struct Graph_<int> GraphI;
  typedef struct Graph_<ll> GraphL;
  typedef struct Graph_<double> GraphD;

snippet warshallfloyd_use
  GraphI graphi(4);
  graphi.warshall_floyd();

snippet warshallfloyd_def
  template <typename T>
  struct Graph_ {
    int n;
    vector<vector<T> > d;
    vector<vector<int> > path;
    Graph_(int ns) {
      n = ns;
      d = vector<vector<T> >(n, vector<T>(n, numeric_limits<T>::max() / 10));
      path = vector<vector<int> >(n, vector<int>(n, -1));
      for(int i = 0; i < n; i++)d[i][i] = 0;
    }
    void warshall_floyd(){
      for(int k = 0; k < n; k++){
        for(int i = 0; i < n; i++){
          for(int j = 0; j < n; j++){
            if(d[i][j] > d[i][k] + d[k][j]){
              d[i][j] = d[i][k] + d[k][j];
              path[i][j] = k;
            }
          }
        }
      }
    }
    void adde(int at, int to, T cost){
      d[at][to] = cost;
    }
  };

  typedef struct Graph_<int> GraphI;
  typedef struct Graph_<ll> GraphL;

snippet gcd_use
  gcd<int>(2, 3);

snippet extgcd_use
  extgcd<int>(3, 2, x, y);

snippet chinesereminder_use
  pair<int, int> p = chinese_reminder_theorem(b, m);

snippet gcd_def
  template<typename T>
  T gcd(T a, T b) {
    if(a > b)return gcd(b, a);
    if(a == 0)return b;
    return gcd(b % a, a);
  }

snippet extgcd_def
  template<typename T>
  T extgcd(T a, T b, T &x, T &y){
    T d = a;
    if(b != 0){
      d = extgcd(b, a % b, y, x);
      y -= (a / b) * x;
    }else{
      x = 1, y = 0;
    }
    return d;
  }

snippet chinesereminder_def
  template<typename T>
  pair<T, T> chinese_reminder_theorem(vector<T> b, vector<T> m){
    T r = 0, M = 1;
    for(int i = 0; i < b.size(); i++){
      T x, y;
      T d = extgcd<T>(M, m[i], x, y);
      if((b[i] - r) % d != 0)return make_pair(0, -1);
      T tmp = (b[i] - r) / d * x % (m[i] / d);
      r += M * tmp;
      M *= m[i] / d;
    }
    r %= M;
    if(r < 0)r += M;
    return make_pair(r % M, M);
  }

snippet convexhulltrick_use
  ConvexHullTrickI cht;
  cht.add(make_pair(2, 0));
  cht.val(2);

snippet convexhulltrick_def
  template <typename T>
  struct ConvexHullTrick_ {
    vector<pair<T, T> > lines;
    function<bool(T l, T r)> comp;
    ConvexHullTrick_(function<bool(T l, T r)> comp_=[](T l, T r){return l >= r;}): comp(comp_){}
    bool isnot_require(pair<T, T> l1, pair<T, T> l2, pair<T, T> l3){
      if(l1 < l3)swap(l1, l3);
      return (l3.second - l2.second) * (l2.first - l1.first) >= (l2.second - l1.second) * (l3.first - l2.first);
    }
    void add(pair<T, T> p){
      while(lines.size() >= 2 && isnot_require(*(lines.end()-2), *(lines.end()-1), p))lines.pop_back();
      lines.push_back(p);
    }
    T f(int i, T x){
      return lines[i].first * x + lines[i].second;
    }
    T val(T x){
      int ld = -1;
      int rd = lines.size() - 1;
      while(rd - ld > 1){
        int md = (rd + ld) / 2;
        if(comp(f(md, x), f(md + 1, x)))ld = md;
        else rd = md;
      }
      return f(rd, x);
    }
  };

  using ConvexHullTrickI = ConvexHullTrick_<int>;
  using ConvexHullTrickL = ConvexHullTrick_<long long>;

snippet convexhull_use
  vector<point2d> ch = convex_hull(vec);

snippet convex_hull_def
  double cross(const point2d &o, const point2d &a, const point2d &b){
    return outer_product(a - o, b - o);
  }

  vector<point2d> convex_hull(vector<point2d> vec){
    int n = vec.size(), k = 0;
    if(n < 3)return vec;

    vector<point2d> ch(2 * n);
    sort(vec.begin(), vec.end());

    // lower
    for(int i = 0; i < n; i++){
      while(k >= 2 && cross(ch[k-2], ch[k-1], vec[i]) <= 0.)k--;
      ch[k++] = vec[i];
    }

    // upper
    for(int i = n - 1, t = k + 1; i > 0; i--){
      while(k >= t && cross(ch[k-2], ch[k-1], vec[i-1]) <= 0.)k--;
      ch[k++] = vec[i-1];
    }

    ch.resize(k-1);
    return ch;
  }

snippet power_use
  power(2, 3, mod);

snippet inverse_use
  inverse(1, mod);

snippet power_def
  template <typename T>
  T power(T a, T n, T mod) {
    T res = 1;
    T tmp = n;
    T curr = a;
    while(tmp){
      if(tmp % 2 == 1){
        res = (T)((ll)res * curr % mod);
      }
      curr = (T)((ll)curr * curr % mod);
      tmp >>= 1;
    }
    return res;
  }

snippet inverse_def
  // this function can be used when x and mod is coprime
  template <typename T>
  T inverse(T x, T mod) {
    return power<T>(x, mod - 2, mod);
  }

snippet is_prime_use
  is_prime(23);

snippet list_prime_use
  vector<int> p = list_prime(15);

snippet is_prime_def
  template <typename T>
  bool is_prime(T x){
    if(x == 1)return false;
    for(ll i = 2; i * i <= x; i++){
      if(x % i == 0)return false;
    }
    return true;
  }

snippet list_prime_def
  template <typename T>
  vector<T> list_prime(T n){
    vector<T> res;
    vector<bool> i_prime = vector<bool>(n+1, true);
    for(ll i = 2; i <= n; i++){
      if(i_prime[i]){
        res.push_back(i);
        for(ll j = 2; j * i <= n; j++){
          i_prime[i * j] = false;
        }
      }
    }
    return res;
  }

snippet excout_use
  excout("a", "b", "c", 1);

snippet excout_def
  void excout(){
    cout << endl;
  }

  template <class Head, class... Tail>
  void excout(Head&& head, Tail&&... tail){
    if(sizeof...(tail) != 0)cout << head << " ";
    else cout << head;
    excout(forward<Tail>(tail)...);
  }

snippet succinctbitvector_use
  SuccinctBitVector sbv(9);

snippet succinctbitvector_def
  typedef struct SuccinctBitVector_ {
    int size;
    int block = 32;
    int l = 256;
    vector<uint32_t> B;
    vector<unsigned> L, S;
    SuccinctBitVector_(){}
    SuccinctBitVector_(int size_){
      size = size_;
      B.assign((size + block - 1) / block, 0U);
      L.assign((size + l - 1) / l, 0U);
      S.assign((size + block - 1) / block, 0U);
    }
    void set_bit(int at){
      B[at / block] |= (1U << (at % block));
    }
    void build(){
      int true_count = 0;
      for(int i = 0; i < ((size + block - 1) / block) * block; i+=block){
        if(i % l == 0)L[i / l] = true_count;
        S[i / block] = true_count - L[i / l];
        true_count += __builtin_popcount(B[i / block]);
      }
    }
    bool access(int at){
      return (B[at / block] >> (at % block)) & 1U;
    }
    bool operator[](int at){
      return access(at);
    }
    // this is rank1
    int rank(int at){
      return L[at / l] + S[at / block] + __builtin_popcount((B[at / block] & ((1U << (at % block)) - 1)));
    }
    int rank(bool val, int at){
      return (val ? rank(at): at - rank(at));
    }
    int select(bool val, int x){
      if(x < 0 || x >= rank(val, size))return -1;
      int ld = 0, rd = size;
      while(rd - ld > 1){
        int md = (rd + ld) / 2;
        if(rank(val, md) >= x + 1)rd = md;
        else ld = md;
      }
      return rd - 1;
    }
    int select(int x){
      return select(1, x);
    }
    int select(bool val, int x, int l){
      return select(val, x + rank(val, l));
    }
  } SuccinctBitVector;

snippet louds_use
  GraphI graphi(8);
  LOUDS louds = construct_louds(graphi);

snippet louds_def
  typedef struct LOUDS_: SuccinctBitVector{
    LOUDS_(int n): SuccinctBitVector(2 * n + 2){}
    int select0(int x){
      // binary search for L
      int lld = 0, lrd = L.size();
      while(lrd - lld > 1){
        int md = (lld + lrd) / 2;
        if(md * l - L[md] <= x)lld = md;
        else lrd = md;
      }
      // binary search for S
      int sld = lld * l / block;
      int srd = min((lld + 1) * l / block, (int)S.size());
      while(srd - sld > 1){
        int md = (sld + srd) / 2;
        if(md * block - L[lld] - S[md] <= x)sld = md;
        else srd = md;
      }
      int tcount = sld * block - L[lld] - S[sld];
      for(int i = 0; i < block; i++){
        if(((B[sld] >> i) & 1U) == 0)tcount++;
        if(tcount == x + 1)return sld * block + i;
      }
      return -1;
    }
    int par(int x){
      int zero_x = select0(x);
      return rank(zero_x) - 1;
    }
    pair<int, int> child(int x){
      if(select(x) + 1 == select(x + 1))return make_pair(-1, -1);
      int ld = select(x) + 1;
      int rd = select(x + 1);
      return make_pair(ld - rank(ld), rd - 1 - rank(rd));
    }
  } LOUDS;


  LOUDS construct_louds(GraphI graph){
    LOUDS louds(graph.n);
    int curr = 2;
    louds.set_bit(1);
    queue<int> q;
    q.push(0);
    vector<bool> used = vector<bool>(graph.n, false);
    used[0] = true;
    while(!q.empty()){
      int p = q.front(); q.pop();
      for(pair<int, int> c: graph.edge[p]){
        if(!used[c.first]){
          used[c.first] = true;
          q.push(c.first);
          curr++;
        }
      }
      louds.set_bit(curr);
      curr++;
    }
    louds.build();
    return louds;
  }

snippet lazyseg_def
  template<typename T, typename E>
  struct LazySegmentTree_ {
    function<T(T, T)> f;
    function<E(E, E)> h;
    function<T(T, E, int)> p;
    int n;
    T def;
    E l_def;
    vector<T> vec;
    vector<E> lazy;
    LazySegmentTree_(){}
    LazySegmentTree_(int n_, function<T(T, T)> f_, T def_,
        function<E(E, E)> h_, E l_def_, function<T(T, E, int)> p_, vector<T> v=vector<T>()){
      f = f_;
      h = h_;
      p = p_;
      def = def_;
      l_def = l_def_;

      // initialize vector
      n = 1;
      while(n < n_){
        n *= 2;
      }
      vec = vector<T>(2*n-1, def);
      lazy = vector<E>(2*n-1, l_def);

      // initialize segment tree
      for(int i = 0; i < v.size(); i++){
        vec[i + n - 1] = v[i];
      }
      for(int i = n - 2; i >= 0; i--){
        vec[i] = f(vec[2*i+1], vec[2*i+2]);
      }
    }
    void eval(int k, int len){
      if(lazy[k] != l_def){
        if(k < n - 1){
          lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);
          lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);
        }
        vec[k] = p(vec[k], lazy[k], len);
        lazy[k] = l_def;
      }
    }
    E update(int a, int b, const E &val, int k, int l, int r){
      eval(k, r - l);
      if(r <= a || b <= l){
        return vec[k];
      }else if(a <= l && r <= b){
        lazy[k] = h(lazy[k], val);
        eval(k, r - l);
        return vec[k];
      }else{
        return vec[k] = f(update(a, b, val, 2*k+1, l, (l+r)/2),
            update(a, b, val, 2*k+2, (l+r)/2, r));
      }
    }
    E update(int a, int b, E val){
      return update(a, b, val, 0, 0, n);
    }
    // [l, r) -> [a, b) (at k)
    T query(int a, int b, int k, int l, int r){
      eval(k, r - l);
      if(r <= a || b <= l)return def;
      if(a <= l && r <= b)return vec[k];
      T ld = query(a, b, 2*k+1, l, (l+r)/2);
      T rd = query(a, b, 2*k+2, (l+r)/2, r);
      return f(ld, rd);
    }
    T query(int a, int b){
      return query(a, b, 0, 0, n);
    }
  };

  template<typename T, typename E>
  using LazySegmentTree = struct LazySegmentTree_<T, E>;
  using LazySegmentTreeI = LazySegmentTree<int, int>;
  using LazySegmentTreeL = LazySegmentTree<long long, long long>;

snippet lazyseg_use
  LazySegmentTreeI seg = LazySegmentTreeI(n, [](int a, int b){return a + b;},
      0, [](int a, int b){return a + b;}, 0, [](int a, int b, int c){return a + b * c;}, v);

snippet bipartile_def
  struct GraphI {
    int n;
    vector<int> color;
    vector<vector<int> > vec;
    GraphI(int ns) {
      n = ns;
      color.resize(n, 0);
      vec.resize(n);
    }
    void adde(int at, int to){
      vec[at].push_back(to);
    }
    bool is_bipartile(){
      for(int i = 0; i < n; i++){
        if(color[i] == 0){
          if(!dfs(i, 1)){
            return false;
          }
        }
      }
      return true;
    }
    bool dfs(int v, int c){
      color[v] = c;
      for(int i: vec[v]){
        if(color[i] == c){
          return false;
        }
        if(color[i] == 0 && !dfs(i, -c))return false;
      }
      return true;
    }
  };

snippet bipartile_use
  GraphI graph(3);
  graph.is_bipartile();

snippet topologicaldag_def
  struct Graph{
    int n;
    vector<vector<int> > edge;
    vector<int> in_deg;
    Graph(int n_){
      n = n_;
      edge.resize(n);
      in_deg.resize(n, 0);
    }
    void adde(int at, int to){
      edge[at].push_back(to);
      in_deg[to]++;
    }
    vector<int> topological_sort(){
      stack<int> st;
      for(int i = 0; i < n; i++){
        if(in_deg[i] == 0)st.push(i);
      }
      vector<int> res;
      while(st.size()){
        int at = st.top(); st.pop();
        res.push_back(at);
        for(int j: edge[at]){
          in_deg[j]--;
          if(in_deg[j] == 0)st.push(j);
        }
      }

      return res;
    }
  };

snippet topologicaldag_use
  Graph graph(7);
  vector<int> ts = graph.topological_sort();

snippet bellmanford_def
  template <typename T>
  struct edge{int from, to; T cost;};

  template <typename T>
  struct Graph{
    int n;
    vector<T> d;
    vector<edge<T>> es;
    Graph(int n_){
      n = n_;
      d.resize(n, numeric_limits<T>::max());
    }
    void adde(edge<T> e){
      es.push_back(e);
    }
    bool bellman_ford(int s){
      T maxim = numeric_limits<T>::max();
      fill(d.begin(), d.end(), maxim);
      d[s] = 0;
      for(int i = 0; i < n; i++){
        bool update = false;
        for(auto e: es){
          if(d[e.from] != maxim && d[e.to] > d[e.from] + e.cost){
            d[e.to] = d[e.from] + e.cost;
            update = true;
            if(i == n - 1)return false;
          }
        }
        if(!update)break;
      }
      return true;
    }
  };

snippet bellmanford_use
  Graph<ll> graphl(5);
  graphl.bellman_ford(0);

snippet prim_def
  template <typename T>
  struct Graph{
    int n;
    vector<vector<pair<int, T> > > es;
    vector<T> mincost;
    vector<bool> used;
    Graph(int n_){
      n = n_;
      es.resize(n);
      mincost.resize(n);
      used.resize(n);
    }
    void adde(int from, int to, T cost){
      es[from].push_back(make_pair(to, cost));
      es[to].push_back(make_pair(from, cost));
    }
    T prim(){
      fill(mincost.begin(), mincost.end(), numeric_limits<T>::max());
      fill(used.begin(), used.end(), false);
      T res = 0;
      priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > pq;
      mincost[0] = 0;
      pq.push(make_pair(0, 0));
      while(!pq.empty()){
        pair<T, int> p = pq.top(); pq.pop();
        if(used[p.second])continue;
        used[p.second] = true;
        res += p.first;
        for(auto e: es[p.second]){
          if(!used[e.first] && mincost[e.first] > e.second){
            mincost[e.first] = e.second;
            pq.push(make_pair(mincost[e.first], e.first));
          }
        }
      }
      return res;
    }
  };

  using GraphI = Graph<int>;

snippet prim_use
  GraphI graph(7);
  int cost = graph.prim();

snippet kruskal_def
  typedef struct UnionFind_ {
    vector<int> par;
    vector<int> rank_;
    UnionFind_(int n): rank_(n, 0) {
      for(int i = 0; i < n; i++)par.push_back(i);
    }
    int find(int x) {
      if(par[x] == x)return x;
      else return par[x] = find(par[x]);
    }
    bool same(int x, int y) {
      if(find(x) == find(y))return true;
      else return false;
    }
    bool unite(int x, int y){
      int xp = find(x);
      int yp = find(y);
      if(xp == yp)return false;
      if(rank_[xp] > rank_[yp])par[yp] = xp;
      else if(rank_[xp] < rank_[yp])par[xp] = yp;
      else {
        par[yp] = xp;
        rank_[xp]++;
      }
      return true;
    }
  } UnionFind;

  template <typename T>
  struct edge{
    int from;
    int to;
    T cost;
  };

  template <typename T>
  bool comp(const edge<T> &a, const edge<T> &b){
    return a.cost < b.cost;
  }

  template <typename T>
  struct Graph {
    int n;
    vector<edge<T>> es;
    Graph(int n_){
      n = n_;
    }
    void adde(int from, int to, T cost){
      es.push_back((edge<T>){from, to, cost});
    }
    T kruskal(){
      T res = 0;
      UnionFind uf(n);
      sort(es.begin(), es.end(), comp<T>);
      for(auto e: es){
        int from = e.from;
        int to = e.to;
        T cost = e.cost;
        if(uf.same(from, to))continue;
        res += cost;
        uf.unite(from, to);
      }

      return res;
    }
  };

  using GraphI = Graph<int>;

snippet kruskal_use
  GraphI graphi(7);
  graphi.kruskal();

snippet merge_def
  template <typename T>
  void merge(vector<T> &a, int l, int m, int r){
    int n1 = m - l;
    int n2 = r - m;
    vector<T> L, R;
    for(int i = 0; i < n1; i++)L.push_back(a[l+i]);
    for(int i = 0; i < n2; i++)R.push_back(a[m+i]);
    L.push_back(numeric_limits<T>::max());
    R.push_back(numeric_limits<T>::max());
    int i = 0, j = 0;
    for(int k = l; k < r; k++){
      if(L[i] <= R[j]){
        a[k] = L[i];
        i++;
      }else{
        a[k] = R[j];
        j++;
      }
    }
  }

  template <typename T>
  void merge_sort(vector<T> &a, int l, int r){
    if(l + 1 < r){
      int m = (l + r) / 2;
      merge_sort<T>(a, l, m);
      merge_sort<T>(a, m, r);
      merge<T>(a, l, m, r);
    }
  }

  template <typename T>
  void merge_sort(vector<T> &a){
    merge_sort<T>(a, 0, a.size());
  }

snippet merge_use
  merge_sort(vec);

snippet devisor_def
  template <typename T>
  vector<T> devisor(T n){
    vector<T> res;
    for(T i = 1; i * i <= n; i++){
      if(n % i == 0){
        res.push_back(i);
        if(n != i * i)res.push_back(n / i);
      }
    }
    sort(res.begin(), res.end());
    return res;
  }

snippet devisor_use
  vector<int> d = devisor(n);

snippet factorize_def
  template <typename T>
  map<T, int> factorize(T n){
    map<T, int> res;
    T tmp = n;
    for(T i = 2; i * i <= n; i++){
      while(tmp % i == 0){
        ++res[i];
        tmp /= i;
      }
    }
    if(tmp != 1)res[tmp] = 1;
    return res;
  }

snippet factorize_use
  map<int, int> mp = factorize(n);

snippet millar_rabin_def
  template <typename T>
  bool suspect(T a, int s, T d, T n){
    T x = power<T>(a, d, n);
    if(x == 1)return true;
    for(int r = 0; r < s; r++){
      if(x == n - 1)return true;
      x = x * x % n;
    }
    return false;
  }

  template <typename T>
  bool millar_rabin(T n){
    if(n <= 1 || (n > 2 && n % 2 == 0))return false;
    vector<ll> test = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    T d = n - 1;
    int s = 0;
    while(d % 2 == 0)s++, d /= 2;
    for(int i = 0; i < test.size() && test[i] < n; i++){
      if(!suspect<T>(test[i], s, d, n))return false;
    }
    return true;
  }

snippet millar_rabin_use
  bool b = millar_rabin(n)

snippet gauss_jordan_def
  template <typename T>
  struct Matrix{
    T EPS = (T)1e-10;
    vector<vector<T> > val;
    Matrix(int n, int m, T def = 0): val(n, vector<T>(m, def)){}
    inline vector<T> &operator[](size_t i){return val[i];};
    size_t size() const {return val.size();}
    int gauss_jordan(bool is_extended = false){
      int m = val.size(), n = val[0].size();
      int rank = 0;
      for(int col = 0; col < n; col++){
        if(col == n - 1 && is_extended)break;

        int pivot = -1;
        T ma = EPS;
        for(int row = rank; row < m; row++){
          if(abs(val[row][col]) > ma){
            ma = abs(val[row][col]);
            pivot = row;
          }
        }
        if(pivot == -1)continue;
        swap(val[rank], val[pivot]);

        T fac = val[rank][col];
        for(int col2 = 0; col2 < n; col2++){
          val[rank][col2] /= fac;
        }

        for(int row = 0; row < m; row++){
          if(row != rank && abs(val[row][col]) > EPS){
            T fac = val[row][col];
            for(int col2 = 0; col2 < n; col2++){
              val[row][col2] -= val[rank][col2] * fac;
            }
          }
        }

        rank++;
      }
      return rank;
    }
  };

snippet linear_eq_def
  template <typename T>
  vector<T> linear_eq(Matrix<T>& A, vector<T>& b){
    int m = A.size(), n = A[0].size();
    Matrix<T> M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);
    vector<T> res;
    for(int row = rank; row < m; row++){
      if(abs(M[row][n]) > M.EPS)return res;
    }
    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return res;
  }

snippet gauss_jordan_use
  int rank = M.gauss_jordan();

snippet linear_eq_use
  vector<T> res = linear_eq(A, b);

snippet gauss_jordanp_def
  template <typename T, int mod = int(1e9+7)>
  struct MatrixP{
    vector<vector<T> > val;
    MatrixP(int n, int m, T def = 0): val(n, vector<T>(m, def)){}
    inline vector<T> &operator[](size_t i){return val[i];};
    size_t size() const {return val.size();}
    int gauss_jordan(bool is_extended = false){
      int m = val.size(), n = val[0].size();
      int rank = 0;
      for(int row = 0; row < m; row++){
        for(int col = 0; col < n; col++){
          val[row][col] = (val[row][col] % mod + mod) % mod;
        }
      }
      for(int col = 0; col < n; col++){
        if(col == n - 1 && is_extended)break;

        int pivot = -1;
        for(int row = rank; row < m; row++){
          if(val[row][col] != 0){
            pivot = row;
            break;
          }
        }
        if(pivot == -1)continue;
        swap(val[rank], val[pivot]);

        T fac = power(val[rank][col], mod - 2, mod);
        for(int col2 = 0; col2 < n; col2++){
          val[rank][col2] * fac % mod;
        }

        for(int row = 0; row < m; row++){
          if(row != rank && val[row][col] != 0){
            T fac = val[row][col];
            for(int col2 = 0; col2 < n; col2++){
              val[row][col2] -= val[rank][col2] * fac % mod;
              if(val[row][col2])val[row][col2] += mod;
            }
          }
        }

        rank++;
      }
      return rank;
    }
  };

snippet gauss_jordanp_use
  int rank = M.gauss_jordan();

snippet linear_eqp_def
  template <typename T, int mod = int(1e9+7)>
  int linear_eq(MatrixP<T>& A, vector<T>& b, vector<T> &res){
    int m = A.size(), n = A[0].size();
    MatrixP<T, mod> M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);
    for(int row = rank; row < m; row++){
      if(M[row][n] != 0)return -1;
    }
    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return rank;
  }

snippet linear_eqp_use
  int rank = linear_eq(A, b, res);

snippet gauss_jordanb_def
  const int MAX_H = 510, MAX_W = 510;
  struct MatrixB {
    int H, W;
    bitset<MAX_W> val[MAX_H];
    MatrixB(int m = 1, int n = 1): H(m), W(n){}
    inline bitset<MAX_W>& operator[](size_t i){return val[i];}
    int gauss_jordan(bool is_extended = false){
      int rank = 0;
      for(int col = 0; col < W; col++){
        if(col == W - 1 && is_extended)break;
        int pivot = -1;
        for(int row = rank; row < H; row++){
          if(val[row][col]){
            pivot = row;
            break;
          }
        }
        if(pivot == -1)continue;
        swap(val[pivot], val[rank]);
        for(int row = 0; row < H; row++){
          if(row != rank && val[row][col])val[row] ^= val[rank];
        }
        rank++;
      }
      return rank;
    }
  };

snippet gauss_jordanb_use
  int rank = M.gauss_jordan();

snippet linear_eqb_def
  int linear_eq(MatrixB &A, vector<int> b, vector<int> & res){
    int m = A.H, n = A.W;
    MatrixB M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);

    for(int row = rank; row < m; row++){
      if(M[row][n])return -1;
    }

    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return rank;
  }

snippet linear_eqb_use
  int rank = M.linear_eq(A, b, res);

snippet treap_def
  template <typename T>
  struct Treap{
    random_device rnd;
    struct Node{
      T key;
      int pri;
      Node *l, *r;
      Node(T key, int pri): key(key), pri(pri), l(nullptr), r(nullptr){}
      ~Node(){
        delete l;
        delete r;
      }
    };
    using Tree = Node *;
    Tree root = nullptr;
    size_t _size = 0;

    Treap(){}
    size_t size(){
      return _size;
    }
    void split(Tree t, T key, Tree &l, Tree &r){
      if(!t){
        l = r = nullptr;
      }else if(key < t->key){
        split(t->l, key, l, t->l);
        r = t;
      }else{
        split(t->r, key, t->r, r);
        l = t;
      }
    }
    void merge(Tree &t, Tree l, Tree r){
      if(!l)return r;
      if(!r)return l;
      if(l->pri > r->pri){
        merge(l->r, l->r, r);
        t = l;
      }else{
        merge(r->l, l, r->l);
        t = r;
      }
    }
    void insert(Tree &t, Tree n){
      if(!t)t = n;
      else if(n->pri > t->pri){
        split(t, n->key, n->l, n->r);
        t = n;
      }else{
        if(n->key < t->key)insert(t->l, n);
        else insert(t->r, n);
      }
    }
    void insert(T key){
      insert(root, new Node(key, rnd()));
      _size++;
    }
    void erase(Tree &t, T key){
      if(t->key == key){
        merge(t, t->l, t->r);
        _size--;
      }else{
        if(key < t->key)erase(t->l, key);
        else erase(t->r, key);
      }
    }
    void erase(T key){
      erase(root, key);
    }
    bool find(Tree &t, T key){
      if(!t)return false;
      else if(t->key == key)return true;
      else{
        if(key < t->key)return find(t->l, key);
        else return find(t->r, key);
      }
    }
    bool find(T key){
      return find(root, key);
    }
  };

snippet treap_use
  Treap<int> tr;

snippet fast_zeta_def
  /*
   * f(U) = \sum_{U\in T}f(T)
   * for f(U) = \sum_{T\in U}f(T), use f[j | i] += f[j];
   */
  template <typename T>
  void fast_zeta(vector<T> &f){
    int n = f.size();
    for(int i = 1; i < n; i<<=1){
      for(int j = 0; j < n; j++){
        if((j & i) == 0){
          f[j] += f[j | i];
        }
      }
    }
  }

snippet fast_zeta_use
  fast_zeta(vec);

snippet fast_moebius_def
  /*
   * f(U) = \sum_{U\in T}(-1)^(|T\U|)f(T)
   * for f(U) = \sum_{T\in U}f(T), use f[j | i] -= f[j];
   */
  template <typename T>
  void fast_moebius(vector<T> &f){
    int n = f.size();
    for(int i = 1; i < n; i<<=1){
      for(int j = 0; j < n; j++){
        if((j & i) == 0){
          f[j] -= f[j | i];
        }
      }
    }
  }

snippet fast_moebius_use
  fast_moebius(vec);

snippet implicit_treap_def
  template <typename T, typename E>
  struct ImplicitTreap{
    random_device rnd;
    T def = 0;
    E l_def = 0;
    function<T(T, T)> f;
    function<E(E, E)> g;
    function<T(T, E, int)> p;

    struct Node{
      T val, acc;
      E lazy;
      int cnt, pri;
      bool rev;
      Node *l, *r;
      Node(T val, int pri, T def, E l_def): val(val), acc(def), lazy(l_def), cnt(1), pri(pri), rev(false), l(nullptr), r(nullptr){}
    };
    using Tree = Node *;
    Tree root = nullptr;
    ImplicitTreap(T def, E l_def, function<T(T, T)> f, function<E(E, E)> g, function<T(T, E, int)> p): def(def), l_def(l_def), f(f), g(g), p(p){}
    int cnt(Tree t){
      if(!t)return 0;
      return t->cnt;
    }
    T acc(Tree t){
      if(!t)return def;
      return t->acc;
    }
    void update_cnt(Tree t){
      if(t){
        t->cnt = 1 + cnt(t->l) + cnt(t->r);
      }
    }
    void update_acc(Tree t){
      if(t){
        t->acc = f(t->val, f(acc(t->l), acc(t->r)));
      }
    }
    void pushup(Tree t){
      update_cnt(t);
      update_acc(t);
    }
    void pushdown(Tree t){
      if(t){
        if(t->rev){
          t->rev = false;
          swap(t->l, t->r);
          if(t->l)t->l->rev ^= 1;
          if(t->r)t->r->rev ^= 1;
        }
        if(t->lazy != l_def){
          if(t->l){
            t->l->lazy = g(t->l->lazy, t->lazy);
            t->l->acc = p(t->l->acc, t->lazy, cnt(t->l));
          }
          if(t->r){
            t->r->lazy = g(t->r->lazy, t->lazy);
            t->r->acc = p(t->r->acc, t->lazy, cnt(t->r));
          }
          t->val = p(t->val, t->lazy, 1);
          t->lazy = l_def;
        }
      }
      pushup(t);
    }
    void split(Tree t, int key, Tree &l, Tree &r){
      if(!t){
        l = r = nullptr;
        return;
      }
      pushdown(t);
      int ikey = cnt(t->l) + 1;
      if(key < ikey)split(t->l, key, l, t->l), r = t;
      else split(t->r, key - ikey, t->r, r), l = t;
      pushup(t);
    }
    void merge(Tree &t, Tree l, Tree r){
      pushdown(l);
      pushdown(r);
      if(!l || !r){
        if(l)t = l;
        else t = r;
        return;
      }
      if(l->pri > r->pri){
        merge(l->r, l->r, r), t = l;
      }else{
        merge(r->l, l, r->l), t = r;
      }
      pushup(t);
    }
    void insert(Tree &t, int key, Tree item){
      Tree t1, t2;
      split(t, key, t1, t2);
      merge(t1, t1, item);
      merge(t, t1, t2);
    }
    void erase(Tree &t, int key){
      Tree t1, t2, t3;
      split(t, key + 1, t1, t2);
      split(t1, key, t1, t3);
      merge(t, t1, t2);
      delete t2;
    }
    void update(Tree t, int l, int r, E x){
      Tree t1, t2, t3;
      split(t, l, t1, t2);
      split(t2, r - l, t2, t3);
      t2->lazy = g(t2->lazy, x);
      t2->acc = p(t2->acc, x, cnt(t2));
      merge(t2, t2, t3);
      merge(t, t1, t2);
    }
    T query(Tree t, int l, int r){
      Tree t1, t2, t3;
      split(t, l, t1, t2);
      split(t2, r - l, t2, t3);
      T res = t2->acc;
      merge(t2, t2, t3);
      merge(t, t1, t2);
      return res;
    }
    int find(Tree t, T x, int of, bool left=true){
      if(f(t->acc, x) == x)return -1;
      if(left){
        if(t->l && f(t->l->acc, x) != x)return find(t->l, x, of, left);
        if(f(t->val, x) != x)return of + cnt(t->l);
        return find(t->r, x, of + cnt(t->l) + 1, left);
      }else{
        if(t->r && f(t->r->acc, x) != x)return find(t->r, x, of + cnt(t->l) + 1, left);
        if(f(t->val, x) != x)return of + cnt(t->l);
        return find(t->l, x, of, left);
      }
    }
    void reverse(Tree t, int l, int r){
      if(l > r)return;
      Tree t1, t2, t3;
      split(t, l, t1, t2);
      split(t2, r - l, t2, t3);
      t2->rev ^= 1;
      merge(t2, t2, t3);
      merge(t, t1, t2);
    }
    // m is top
    void rotate(Tree t, int l, int m, int r){
      reverse(t, l, r);
      reverse(t, l, l + r - m);
      reverse(t, l + r - m, r);
    }
    int size(){
      return cnt(root);
    }
    void insert(int pos, T x){
      insert(root, pos, new Node(x, rnd(), def, l_def));
    }
    void update(int l, int r, T x){
      update(root, l, r, x);
    }
    T query(int l, int r){
      return query(root, l, r);
    }
    int find(int l, int r, T x, bool left=true){
      Tree t1, t2, t3;
      split(root, l, t1, t2);
      split(t2, r - l, t2, t3);
      int res = find(t2, x, l, left);
      merge(t2, t2, t3);
      merge(root, t1, t2);
      return res;
    }
    void erase(int pos){
      erase(root, pos);
    }
    void reverse(int l, int r){
      reverse(root, l, r);
    }
    void rotate(int l, int m, int r){
      rotate(root, l, m, r);
    }
    T operator[](int pos){
      Tree t1, t2, t3;
      split(root, pos + 1, t1, t2);
      split(t1, pos, t1, t3);
      T res = t3->acc;
      merge(t1, t1, t3);
      merge(root, t1, t2);
      return res;
    }
  };

snippet implicit_treap_use
  ImplicitTreap<int, int> itr(0, 0, [](int a, int b){return a + b;},
      [](int a, int b){return a + b;}, [](int a, int b, int c){return a + b * c;});

snippet rolling_hash_def
  template <int MS = 2>
  struct RollingHash{
    const long long mod[2] = {999999937LL, 1000000007L};
    const long long base[2] = {9973, 10007};
    vector<long long> hash[MS], power[MS];
    int n = 0;
    RollingHash(){}
    RollingHash(const string &s){
      n = s.size();
      for(int i = 0; i < MS; i++){
        hash[i].assign(n + 1, 0);
        power[i].assign(n + 1, 0);
        hash[i][0] = 0;
        power[i][0] = 1;
        for(int j = 0; j < n; j++){
          power[i][j+1] = power[i][j] * base[i] % mod[i];
          hash[i][j+1] = (hash[i][j] * base[i] + s[j]) % mod[i];
        }
      }
    }
    long long get(int l, int r, int i) const{
      return ((hash[i][r] - hash[i][l] * power[i][r-l]) % mod[i] + mod[i]) % mod[i];
    }
    bool match(int l1, int r1, int l2, int r2) const{
      bool res = true;
      for(int i = 0; i < MS; i++){
        res &= (get(l1, r1, i) == get(l2, r2, i));
      }
      return res;
    }
    bool match(int l1, int r1, const RollingHash<MS> &rs, int l2, int r2){
      bool res = true;
      for(int i = 0; i < MS; i++){
        res &= (get(l1, r1, i) == rs.get(l2, r2, i));
      }
      return res;
    }
  };

snippet rolling_hash_use
  RollingHash<> rs(s);

snippet rh_search_def
  vector<int> rh_search(string s, string t){
    RollingHash<> rs = RollingHash<>(s);
    RollingHash<> rt = RollingHash<>(t);
    vector<int> res;
    for(int i = 0; i + t.size() <= s.size(); i++){
      if(rs.match(i, i + t.size(), rt, 0, t.size()))res.push_back(i);
    }
    return res;
  }

snippet rh_search_use
  vector<int> res = rh_search(s, t);
snippet cout_int128_def
  ostream& operator<<(ostream& dest, __int128_t value) {
    ostream::sentry s(dest);
    if(s){
      __uint128_t tmp = value < 0 ? - value: value;
      char buf[128];
      char *d = end(buf);
      do{
        --d;
        *d = "0123456789"[tmp % 10];
        tmp /= 10;
      }while(tmp != 0);
      if(value < 0)--d, *d='-';
      int len = end(buf) - d;
      if(dest.rdbuf()->sputn(d, len) != len){
        dest.setstate(ios_base::badbit);
      }
    }
    return dest;
  }

  __int128_t to_int128(string s){
    __int128_t res = 0;
    for(int i = 0; i < s.size(); i++){
      res = res * 10 + (s[i] - '0');
    }
    return res;
  }

snippet bigint_def
  const ll B = 10000;
  const int BW = 4;
  struct BigInt{
    vector<ll> digit;
    BigInt(ll a = 0){
      digit.emplace_back(a);
      normalize();
    }
    BigInt(const string &s){
      from_string(s);
    }
    void from_string(const string &s){
      digit.clear();
      int i;
      for(i = (int)s.size() - BW; i >= 0; i-=BW){
        digit.emplace_back(stol(s.substr(i, BW)));
      }
      i += BW;
      if(i > 0)digit.emplace_back(stol(s.substr(0, i)));
    }
    void normalize(){
      ll c = 0;
      for(int i = 0; i < digit.size(); i++){
        while(digit[i] < 0){
          if(i + 1 == digit.size())digit.emplace_back(0);
          digit[i+1]--;
          digit[i] += B;
        }
        ll a = digit[i] + c;
        digit[i] = a % B;
        c = a / B;
      }
      while(c){
        digit.emplace_back(c % B);
        c /= B;
      }
      for(int i = (int)digit.size() - 1; i >= 1; i--){
        if(digit[i] == 0){
          digit.pop_back();
        }else{
          break;
        }
      }
    }
    size_t size(){
      return digit.size();
    }
    BigInt& operator=(ll a){
      digit.resize(1, a);
      normalize();
      return *this;
    }
    BigInt& operator=(const string &s){
      from_string(s);
      return *this;
    }
  } ZERO(0), ONE(1);

  ostream &operator<<(ostream &os, const BigInt &b){
    os << b.digit[b.digit.size() - 1];
    for(int i = (int)b.digit.size() - 2; i >= 0; i--){
      os << setw(BW) << setfill('0') << b.digit[i];
    }
    return os;
  }

  istream & operator>>(istream &is, BigInt &b){
    string s;
    is >> s;
    b.from_string(s);
    return is;
  }

  bool operator<(const BigInt &x, const BigInt &y){
    if(x.digit.size() != y.digit.size())return x.digit.size() < y.digit.size();
    for(int i = x.digit.size() - 1; i >= 0; i--){
      if(x.digit[i] != y.digit[i])return x.digit[i] < y.digit[i];
    }
    return false;
  }

  bool operator>(const BigInt &x, const BigInt y){
    return y < x;
  }

  bool operator<=(const BigInt &x, const BigInt &y){
    return !(y < x);
  }

  bool operator>=(const BigInt &x, const BigInt &y){
    return !(x < y);
  }

  bool operator!=(const BigInt &x, const BigInt &y){
    return x < y || y < x;
  }

  bool operator==(const BigInt &x, const BigInt &y){
    return !(x < y) && !(y < x);
  }

  BigInt operator+(const BigInt &x, ll a){
    BigInt res = x;
    res.digit[0] += a;
    res.normalize();
    return res;
  }

  BigInt operator+(const BigInt &x, const BigInt &y){
    BigInt res = x;
    while(res.digit.size() < y.digit.size())res.digit.emplace_back(0);
    for(int i = 0; i < y.digit.size(); i++)res.digit[i] += y.digit[i];
    res.normalize();
    return res;
  }

  BigInt operator-(const BigInt &x, const BigInt &y){
    BigInt res = x;
    assert(res.digit.size() >= y.digit.size());
    for(int i = 0; i < y.digit.size(); i++)res.digit[i] -= y.digit[i];
    res.normalize();
    return res;
  }

  BigInt operator*(const BigInt &x, const BigInt &y){
    BigInt z;
    z.digit.assign(x.digit.size() + y.digit.size(), 0);
    for(int i = 0; i < x.digit.size(); i++){
      for(int j = 0; j < y.digit.size(); j++){
        z.digit[i+j] += x.digit[i] * y.digit[j];
      }
    }
    z.normalize();
    return z;
  }

  BigInt operator*(const BigInt &x, ll a){
    BigInt res = x;
    for(int i = 0; i < res.digit.size(); i++)res.digit[i] *= a;
    res.normalize();
    return res;
  }

  pair<BigInt, ll> divmod(const BigInt &x, ll a){
    ll c = 0;
    BigInt res = x;
    for(int i = (int)res.digit.size() - 1; i >= 0; i--){
      ll t = B * c + res.digit[i];
      res.digit[i] = t / a;
      c = t % a;
    }
    res.normalize();
    return make_pair(res, c);
  }

  BigInt operator/(const BigInt &x, ll a){
    return divmod(x, a).first;
  }

  BigInt operator%(const BigInt &x, ll a){
    return divmod(x, a).second;
  }

  pair<BigInt, BigInt> divmod(const BigInt &x, const BigInt &y){
    BigInt rx = x, ry = y;
    if(x.digit.size() < y.digit.size())return make_pair(ZERO, x);
    int F = B / (y.digit[y.digit.size() - 1] + 1);
    rx = rx * F; ry = ry * F;
    BigInt z;
    z.digit.assign(rx.digit.size() - ry.digit.size() + 1, 0);
    for(int k = (int)z.digit.size() - 1, i = (int)rx.digit.size() - 1; k >= 0; k--, i--){
      z.digit[k] = (i + 1 < rx.digit.size() ? rx.digit[i+1]: 0) * B + rx.digit[i];
      z.digit[k] /= ry.digit[ry.digit.size() - 1];
      BigInt t;
      t.digit.assign(k + ry.digit.size(), 0);
      for(int m = 0; m < ry.digit.size(); m++){
        t.digit[k+m] = z.digit[k] * ry.digit[m];
      }
      t.normalize();
      while(rx < t){
        z.digit[k] -= 1;
        for(int m = 0; m < ry.digit.size(); m++){
          t.digit[k+m] -= ry.digit[m];
        }
        t.normalize();
      }
      rx = rx - t;
    }
    z.normalize();
    return make_pair(z, rx / F);
  }

  BigInt operator/(const BigInt &x, const BigInt &y){
    return divmod(x, y).first;
  }

  BigInt operator%(const BigInt &x, const BigInt &y){
    return divmod(x, y).second;
  }

  BigInt& operator+=(BigInt &x, ll a){
    x = x + a;
    return x;
  }

  BigInt &operator+=(BigInt &x, const BigInt &y){
    x = x + y;
    return x;
  }

  BigInt &operator-=(BigInt &x, const BigInt &y){
    x = x - y;
    return x;
  }

  BigInt& operator*=(BigInt &x, const BigInt &y){
    x = x * y;
    return x;
  }

  BigInt& operator/=(BigInt &x, const BigInt &y){
    x = x / y;
    return x;
  }

  BigInt& operator%=(BigInt &x, const BigInt &y){
    x = x % y;
    return x;
  }

  BigInt& operator/=(BigInt &x, ll a){
    x = x / a;
    return x;
  }

  BigInt& operator%=(BigInt &x, ll a){
    x = x % a;
    return x;
  }

  BigInt sqrt(const BigInt &x){
    BigInt l = 1;
    BigInt r = x;
    while(r - l > BigInt(1)){
      BigInt m = (r + l) / 2;
      if(m * m > x)r = m;
      else l = m;
    }
    return l;
  }

snippet bigint_use
  BigInt b = BigInt("123");

snippet mergable_range_set_def
  template <typename T>
  struct MergableRangeSet{
    using PT = pair<T, T>;
    set<PT> st;
    MergableRangeSet(){}
    // [l, r)
    void add(T l, T r){
      st.insert(make_pair(l, r));
      merge();
    }
    void merge(){
      auto itr = st.begin();
      while(itr != st.end()){
        int l1 = itr->first;
        int r1 = itr->second;
        ++itr;
        if(itr == st.end())break;
        int l2 = itr->first;
        int r2 = itr->second;
        if(l2 <= r1){
          auto prev = itr;
          --prev;
          st.erase(itr);
          st.erase(prev);
          st.insert(make_pair(l1, r2));
          itr = st.lower_bound(make_pair(l1, r2));
        }
      }
    }
    auto begin() noexcept{
      return st.begin();
    }
    auto end() noexcept{
      return st.end();
    }
    size_t size(){
      return st.size();
    }
  };

snippet mergable_range_set_use
  MergableRangeSet<int> mrs;

snippet trie_def
  const int N_AL = 52;
  struct Trie{
    Trie *next[N_AL];
    bool exists = false;
    Trie(){
      for(int i = 0; i < N_AL; i++)next[i] = nullptr;
    }
    int get_index(const char c){
      if('a' <= c && c <= 'z')return int(c - 'a');
      else return 26 + int(c - 'A');
    }
    void insert(const string &s, int i){
      if(i == s.size()){
        exists = true;
        return;
      }
      int index = get_index(s[i]);
      if(!next[index]){
        next[index] = new Trie();
      }
      next[index]->insert(s, i+1);
    }
    void insert(const string &s){
      insert(s, 0);
    }
    bool find(const string &s, int i){
      if(i == s.size()){
        return exists;
      }
      int index = get_index(s[i]);
      if(next[index])return next[index]->find(s, i+1);
      return false;
    }
    bool find(const string &s){
      return find(s, 0);
    }
  };

snippet trie_use
  Trie *root = new Trie();
  root->insert("abc");

snippet lagrangeinterpolationdouble_def
  struct LagrangeInterpolationD{
    int n = 0;
    using T = double;
    vector<T> x, y;
    vector<T> nume;
    LagrangeInterpolationD(const vector<T> &x, const vector<T> &y): x(x), y(y){
      n = x.size() - 1;
      nume.resize(n + 1);
      for(int i = 0; i < n + 1; i++){
        T t = 1.;
        for(int j = 0; j < n + 1; j++){
          if(i == j)continue;
          t = t * (x[i] - x[j]);
        }
        nume[i] = 1. / t;
      }
    }
    T val(T t){
      T a = 1.;
      for(int i = 0; i < n + 1; i++){
        if(t == x[i])return y[i];
        a = a * (t - x[i]);
      }
      T res = 0.;
      for(int i = 0; i < n + 1; i++){
        res += y[i] * nume[i] * (a / (t - x[i]));
      }
      return res;
    }
  };

  using LID = LagrangeInterpolationD;

snippet lagrangeinterpolationdouble_use
  LID lid(x, y);
  lid.val(1.);

snippet modint_def
  template <int MOD>
  struct ModInt {
    ll x = 0;
    ModInt(){}
    ModInt(ll x_){
      x = int(x_ % MOD);
      if(x < 0)x += MOD;
    }
    ModInt(const ModInt &m){
      x = m.x;
    }
    ModInt& operator+=(const ModInt &y){
      x = (x + y.x) % MOD;
      if(x < 0)x += MOD;
      return *this;
    }
    ModInt& operator-=(const ModInt &y){
      x = (x - y.x) % MOD;
      if(x < 0)x += MOD;
      return *this;
    }
    ModInt& operator*=(const ModInt &y){
      x = (x * y.x) % MOD;
      return *this;
    }
    ModInt& operator/=(const ModInt &y){
      x = (x * y.inverse().x) % MOD;
      return *this;
    }
    ModInt inverse() const{
      ll res = 1;
      ll tmp = MOD - 2;
      ll curr = x;
      while(tmp){
        if(tmp % 2 == 1)res = res * curr % MOD;
        curr = curr * curr % MOD;
        tmp /= 2;
      }
      return ModInt(res);
    }
    ModInt operator-() const{
      return ModInt(-x);
    }
    ModInt operator+(const ModInt &y) const{
      return ModInt(*this) += y;
    }
    ModInt operator-(const ModInt &y) const{
      return ModInt(*this) -= y;
    }
    ModInt operator*(const ModInt &y) const{
      return ModInt(*this) *= y;
    }
    ModInt operator/(const ModInt &y) const{
      return ModInt(*this) /= y;
    }
    bool operator==(const ModInt &y) const{
      return x == y.x;
    }
    bool operator!=(const ModInt &y) const{
      return x != y.x;
    }
    friend ostream& operator<<(ostream &os, const ModInt<MOD> &m){
      return os << m.x;
    }
    friend istream& operator>>(istream &is, ModInt<MOD> &m){
      long t;
      is >> t;
      m = ModInt<MOD>(t);
      return is;
    }
  };

snippet modint_use
  ModInt m(3);

snippet lagrangeinterpolationN_def
  template <typename T>
  struct LagrangeInterpolationN{
    int n = 0;
    vector<T> ifrac;
    vector<T> y;
    vector<T> coeff;
    LagrangeInterpolationN(const vector<T> &y): y(y){
      n = y.size() - 1;
      ifrac.resize(n + 1);
      coeff.resize(n + 1);
      ifrac[0] = T(1);
      for(int i = 1; i <= n; i++){
        ifrac[i] = T(i) * ifrac[i-1];
      }
      for(int i = 0; i <= n; i++)ifrac[i] = ifrac[i].inverse();
      for(int i = 0; i <= n; i++){
        T tmp = y[i] * ifrac[i] * ifrac[n-i];
        if((n-i) % 2 == 1)tmp *= T(-1);
        coeff[i] = tmp;
      }
    }
    T val(int t){
      if(t >= 0 && t <= n)return y[t];
      T a = T(1);
      for(int i = 0; i <= n; i++){
        a = a * T(t - i);
      }
      T res = T(0);
      for(int i = 0; i <= n; i++){
        res += a * coeff[i] / T(t - i);
      }
      return res;
    }
  };

snippet lagrangeinterpolation_use
  LagrangeInterpolationN<ModInt<mod>> lin(a);
  lin.val(3);

snippet zalgo_def
  vector<int> zarray(const string &s){
    int n = s.size();
    vector<int> z(n, 0);
    int c = 0;
    for(int i = 1; i < n; i++){
      if(i + z[i - c] < c + z[c]){
        z[i] = z[i - c];
      }else{
        int j = max(0, c + z[c] - i);
        while(i + j < n && s[j] == s[i + j])j++;
        z[i] = j;
        c = i;
      }
    }
    z[0] = n;
    return z;
  }

snippet zalgo_use
  auto p = zarray(s);

snippet z_search_def
  vector<int> z_search(string s, string t){
    string u = t;
    u += "$";
    u += s;
    vector<int> z = zarray(u);
    vector<int> res;
    for(int i = 1; i < u.size(); i++){
      if(z[i] >= t.size())res.push_back(i - int(t.size()) - 1);
    }
    return res;
  }

snippet z_search_use
  auto p = z_search(s, t);

snippet factorial_def
  struct Factorial{
    int n;
    const int MOD = 1e9 + 7;
    vector<long long> fac;
    vector<long long> inv_;
    Factorial(int n): n(n){
      fac.resize(n + 1);
      inv_.resize(n + 1);
      calc_factorial();
      calc_inv();
    }
    void calc_factorial(){
      fac[0] = 1;
      for(int i = 1; i <= n; i++){
        fac[i] = i * fac[i-1] % MOD;
      }
    }
    void calc_inv(){
      inv_[n] = power<long long>(fac[n], MOD - 2, MOD);
      for(int i = n - 1; i >= 0; i--){
        inv_[i] = (i + 1) * inv_[i+1] % MOD;
      }
    }
    long long& operator[](size_t i){
      if(i < 0 || i > n){
        cerr << "list index out of range" << endl;
        abort();
      }
      return fac[i];
    }
    long long inv(size_t i){
      if(i < 0 || i > n){
        cerr << "list index out of range" << endl;
        abort();
      }
      return inv_[i];
    }
    long long comb(int n, int k){
      if(n < k)return 0;
      long long res = fac[n];
      res = res * inv_[n-k] % MOD;
      res = res * inv_[k] % MOD;
      return res;
    }
    long long perm(int n, int k){
      if(n < k)return 0;
      long long res = fac[n];
      res = res * inv_[n-k] % MOD;
      return res;
    }
    long long h(int n, int k){
      if(n == 0 && k == 0)return 1;
      return comb(n + k - 1, k);
    }
  };

snippet factorial_use
  Factorial fac(n);

snippet sbigint_def
  struct SBigInt{
    bool neg = false;
    BigInt b = 0;
    SBigInt(){}
    SBigInt(ll a): b(BigInt(abs(a))){
      if(a < 0)neg = true;
    }
    SBigInt(const string &s){
      string t = s;
      if(t[0] == '-'){
        neg = true;
        t = t.substr(1, t.size() - 1);
      }
      b = BigInt(t);
    }
    void check_zero(){
      if(b == ZERO)neg = false;
    }
    bool operator==(const SBigInt &r) const{
      return (neg == r.neg) && (b == r.b);
    }
    bool operator!=(const SBigInt &r) const{
      return (neg != r.neg) || (b != r.b);
    }
    SBigInt operator-() const{
      SBigInt res = *this;
      res.neg = !res.neg;
      res.check_zero();
      return res;
    }
  };

  SBigInt operator+(const SBigInt &x, const SBigInt &y){
    SBigInt res;
    if(x.neg == y.neg){
      res.b = x.b + y.b;
      res.neg = x.neg;
    }else{
      if(x.b > y.b){
        res.b = x.b - y.b;
        res.neg = x.neg;
      }else{
        res.b = y.b - x.b;
        res.neg = y.neg;
      }
    }
    res.check_zero();
    return res;
  }

  SBigInt operator-(const SBigInt &x, const SBigInt &y){
    SBigInt res = x + (- y);
    res.check_zero();
    return res;
  }

  SBigInt operator*(const SBigInt &x, const SBigInt &y){
    SBigInt res;
    res.neg = !(x.neg == y.neg);
    res.b = x.b * y.b;
    res.check_zero();
    return res;
  }

  SBigInt operator/(const SBigInt &x, const SBigInt &y){
    SBigInt res;
    res.neg = !(x.neg == y.neg);
    res.b = x.b / y.b;
    res.check_zero();
    return res;
  }

  ostream &operator<<(ostream &os, const SBigInt &b){
    if(b.neg)os << "-";
    os << b.b;
    return os;
  }

snippet sbigint_use
  SBigInt("-3");

snippet modinv_def
  template <typename T>
  T modinv(T a, T m){
    long long x = 0, y = 0;
    extgcd<long long>(a, m, x, y);
    x %= m;
    if(x < 0)x += m;
    return x;
  }

snippet modinv_use
  ll res = modinv(a, mod);

snippet modlog_def
  long long modlog(long long a, long long b, long long m){
    a %= m;
    b %= m;

    long long l = -1, r = m;
    while(r - l > 1){
      long long md = (l + r) / 2;
      if(md * md >= m)r = md;
      else l = md;
    }
    long long sm = r;

    map<long long, long long> mp;
    long long curr = 1;
    for(long long i = 0; i < sm; i++){
      mp[curr] = max(mp[curr], i);
      curr = curr * a % m;
    }

    long long A = power<long long>(modinv(a, m), sm, m);
    curr = b;
    for(long long i = 0; i < sm; i++){
      if(mp.find(curr) != mp.end()){
        long long res = i * sm + mp[curr];
        if(res > 0)return res;
      }
      curr = curr * A % m;
    }
    return -1;
  }

snippet modlog_use
  ll res = modlog(a, b, mod);

snippet garner_def
  template <typename T>
  long long garner(vector<T> b, vector<T> m, T MOD){
    m.emplace_back(MOD);
    vector<long long> coef(m.size(), 1);
    vector<long long> consts(m.size(), 0);
    for(int i = 0; i < b.size(); i++){
      long long t = ((b[i] - consts[i]) % m[i]) * modinv<long long>(coef[i], m[i]) % m[i];
      for(int j = i + 1; j < m.size(); j++){
        consts[j] = (consts[j] + t * coef[j] % m[j]) % m[j];
        coef[j] = coef[j] * m[i] % m[j];
      }
    }
    return consts.back();
  }

snippet garner_use
  long long res = garner(b, m, MOD);

snippet fft_def
  // f.size() should be the power of 2.
  void fft(vector<cd> &f, bool inv=false){
    int n = f.size(), mask = n - 1;
    vector<cd> tmp(n);
    for(int i = n >> 1; i >= 1; i >>= 1){
      cd zeta = polar(1., 2. * M_PI * i * (inv ? -1.: 1.) / n);
      cd w = 1;
      for(int j = 0; j < n; j += i){
        for(int k = 0; k < i; k++){
          tmp[j + k] = f[((j<<1)&mask) + k] + w * f[(((j<<1)+i)&mask)+k];
        }
        w *= zeta;
      }
      swap(f, tmp);
    }
  }

  void dft(vector<cd> &f){
    fft(f);
  }

  void idft(vector<cd> &f){
    fft(f, true);
    for(int i = 0; i < f.size(); i++)f[i] = f[i] / cd(f.size());
  }

snippet fft_use
  dft(f);
  idft(f);

snippet convolution_def
  template <typename T>
  vector<T> convolution(vector<T> &f, vector<T> &g){
    int n = 1;
    while(n < 2 * f.size() + 1)n *= 2;
    vector<cd> F(n, 0), G(n, 0);
    for(int i = 0; i < f.size(); i++)F[i] = cd(f[i]);
    for(int i = 0; i < g.size(); i++)G[i] = cd(g[i]);

    dft(F);
    dft(G);
    vector<cd> H(n);
    for(int i = 0; i < n; i++)H[i] = F[i] * G[i];
    idft(H);
    vector<T> h(n);
    for(int i = 0; i < n; i++){
      h[i] = T(round(H[i].real()));
    }
    return h;
  }

snippet convolution_use
  auto h = convolution(f, g);

snippet weightedunionfind_def
  template <typename T>
  struct WeightedUnionFind_{
    int n;
    vector<int> par;
    vector<int> rank;
    vector<T> diff_weight;
    WeightedUnionFind_(int n, T def=0): n(n){
      par.resize(n);
      rank.resize(n);
      diff_weight.resize(n);
      for(int i = 0; i < n; i++){
        par[i] = i;
        rank[i] = 0;
        diff_weight[i] = def;
      }
    }
    int find(int x){
      if(par[x] == x)return x;
      int r = find(par[x]);
      diff_weight[x] += diff_weight[par[x]];
      return par[x] = r;
    }
    T weight(int x){
      find(x);
      return diff_weight[x];
    }
    bool same(int x, int y){
      return find(x) == find(y);
    }
    bool unite(int x, int y, T w){
      w += weight(x), w -= weight(y);
      x = find(x), y = find(y);
      if(x == y)return false;
      if(rank[x] < rank[y])swap(x, y), w = - w;
      if(rank[x] == rank[y])rank[x]++;
      par[y] = x;
      diff_weight[y] = w;
      return true;
    }
    T diff(int x, int y){
      return weight(y) - weight(x);
    }
  };

  using WeightedUnionFind = WeightedUnionFind_<int>;

snippet weightedunionfind_use
  WeightedUnionFind wuf(n);

snippet bipartile_matching_def
  struct BGraph{
    int n, m;
    GraphI graph;
    BGraph(int n, int m): n(n), m(m){
      graph = GraphI(n + m + 2);
      for(int i = 0; i < n; i++){
        graph.adde(0, get_left_index(i), 1);
      }
      for(int i = 0; i < m; i++){
        graph.adde(get_right_index(i), n + m + 1, 1);
      }
    }
    int get_left_index(int i){
      return i + 1;
    }
    int get_right_index(int i){
      return i + n + 1;
    }
    void adde(int at, int to){
      graph.adde(get_left_index(at), get_right_index(to), 1);
    }
    int maximum_matching(){
      return graph.max_flow(0, n + m + 1);
    }
  };

snippet bipartile_matching_use
  BGraph graph(n);
  graph.maximum_matching();

snippet boruvka_def
  template <typename T>
  struct Graph{
    struct edge{
      int to;
      T cost;
      edge(int to, T cost): to(to), cost(cost){}
    };
    int n;
    vector<vector<edge>> edges;
    Graph(int n): n(n){ edges.resize(n);
    }
    void adde(int from, int to, T cost){
      edges[from].push_back(edge(to, cost));
      edges[to].push_back(edge(from, cost));
    }
    T boruvka(){
      T ans = 0;
      vector<vector<edge>> res(n);
      UnionFind uf(n);

      while(true){
        vector<pair<int, edge>> f;
        int c = 0;
        vector<int> id(n, -1);
        for(int i = 0; i < n; i++){
          if(id[i] == -1){
            id[i] = c;
            vector<int> C;
            queue<int> q;
            q.push(i);
            while(!q.empty()){
              int v = q.front(); q.pop();
              C.push_back(v);
              for(auto e: res[v]){
                if(id[e.to] == -1){
                  id[e.to] = c;
                  q.push(e.to);
                }
              }
            }
            c++;
            int from = -1, to = -1;
            T cost = -1;
            for(int j = 0; j < C.size(); j++){
              int v = C[j];
              for(auto e: edges[v]){
                if(id[e.to] != id[i]){
                  if(cost == -1 || cost > e.cost){
                    cost = e.cost;
                    to = e.to;
                    from = v;
                  }
                }
              }
            }
            if(cost != -1)f.push_back(make_pair(from, edge(to, cost)));
          }
        }
        if(c == 1)break;
        for(int i = 0; i < f.size(); i++){
          int u = f[i].first;
          int v = f[i].second.to;
          T cost = f[i].second.cost;
          if(!uf.same(u, v)){
            uf.unite(u, v);
            ans += cost;
            res[u].push_back(edge(v, cost));
            res[v].push_back(edge(u, cost));
          }
        }
      }
      return ans;
    }
  };

  using GraphI = Graph<int>;
  using GraphL = Graph<long long>;

snippet boruvka_use
  GraphI graph(n);
  graph.adde(from, to, cost);
  graph.boruvka();

snippet RMQ_use
  SegmentTreeL seg = SegmentTreeL(n, [](ll a, ll b){return min(a, b);},
      [](ll a,ll b){return b;}, INF, V);

snippet RSQ_use
  SegmentTreeL seg = SegmentTreeL(n, [](ll a, ll b){return a + b;},
      [](ll a,ll b){return a + b;}, 0, V);

snippet RUQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return b;}, NAN, [](ll a, ll b, int c){return b * c;}, vector<ll>(n, DEF));

snippet RAQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return a + b;}, 0, [](ll a, ll b, int c){return a + b * c;}, vector<ll>(n, DEF));

snippet RMQRUQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return min(a, b);},
      INF, [](ll a, ll b){return b;}, NAN, [](ll a, ll b, int c){return b;}, vector<ll>(n, DEF));

snippet RSQRAQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return a + b;}, 0, [](ll a, ll b, int c){return a + b * c;}, vector<ll>(n, DEF));

snippet RMQRAQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return min(a, b);},
      INF, [](ll a, ll b){return a + b;}, 0, [](ll a, ll b, int c){return a + b;}, vector<ll>(n, DEF));

snippet RSQRUQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return b;}, NAN, [](ll a, ll b, int c){return b * c;}, vector<ll>(n, DEF));

snippet euler_phi_def
  long long euler_phi(long long n){
    ll res = n;
    auto mp = factorize(n);
    const int MOD = 1e9 + 7;
    for(auto itr = mp.begin(); itr != mp.end(); ++itr){
      long long p = itr->first;
      res = res * ((p-1) * modinv<long long>(p, MOD) % MOD) % MOD;
    }
    return res;
  }

snippet euler_phi_use
  long long k = euler_phi(n);

snippet coordinate_compression_def
  template <typename T>
  struct CoordinateCompression{
    map<T, int> mp;
    vector<T> v;
    CoordinateCompression(vector<T> &x){
      v.resize(x.size());
      copy(x.begin(), x.end(), v.begin());
      sort(v.begin(), v.end());
      v.erase(unique(v.begin(), v.end()), v.end());
      for(int i = 0; i < v.size(); i++){
        mp[v[i]] = i;
      }
    }
  };

  using CoordinateCompressionI = CoordinateCompression<int>;
  using CoordinateCompressionL = CoordinateCompression<long long>;

snippet coordinate_compression_use
  CoordinateCompressionL cc(v);

snippet lmatrix_def
  template <int MOD = int(1e9+7)>
  struct LMatrix{
    vector<vector<long long>> v;
    int n, m;
    LMatrix(int n_, int m_ = -1): n(n_), m(m_){
      if(m < 0)m = n;
      v.resize(n);
      for(int i = 0; i < n; i++)v[i].resize(m);
    }
    void identity(){
      assert(n == m);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
          v[i][j] = (i == j ? 1: 0);
        }
      }
    }
    vector<long long> &operator[](size_t i){
      return v[i];
    }
    const vector<long long> &operator[](size_t i) const{
      return v[i];
    }
    LMatrix operator*(const LMatrix &r) const{
      assert(m == r.n);
      int l = r.m;
      LMatrix res(n, l);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < l; j++){
          res.v[i][j] = 0;
          for(int k = 0; k < m; k++){
            res.v[i][j] = (res.v[i][j] + v[i][k] * r.v[k][j] % MOD) % MOD;
          }
        }
      }
      return res;
    }
    LMatrix operator+(const LMatrix &r) const{
      assert(n == r.n);
      assert(m == r.m);
      LMatrix res(n, m);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
          res[i][j] = (v[i][j] + r[i][j]) % MOD;
        }
      }
      return res;
    }
    LMatrix operator-(const LMatrix &r) const{
      assert(n == r.n);
      assert(m == r.m);
      LMatrix res(n, m);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
          res[i][j] = (v[i][j] - r[i][j]) % MOD;
          if(res[i][j] < 0)res[i][j] += MOD;
        }
      }
      return res;
    }
    template <typename T>
    LMatrix operator*(T a) const{
      LMatrix res = *this;
      for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
          res[i][j] = a * res[i][j] % MOD;
        }
      }
      return res;
    }
    LMatrix inv2() const{
      assert(n == 2 && m == 2);
      long long det = v[0][0] * v[1][1] % MOD - v[0][1] * v[1][0] % MOD;
      if(det < 0)det += MOD;
      assert(det != 0);
      LMatrix res(2, 2);
      long long inv = modinv(det, (long long)MOD);
      res[0][0] = v[1][1];
      res[1][1] = v[0][0];
      res[1][0] = - v[1][0];
      res[0][1] = - v[0][1];
      for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
          res[i][j] %= MOD;
          res[i][j] = res[i][j] * inv % MOD;
          if(res[i][j] < 0)res[i][j] += MOD;
        }
      }
      return res;
    }
  };

  template <typename T, int MOD = int(1e9+7)>
  LMatrix<MOD> operator*(T a, const LMatrix<MOD> b){
    return b * a;
  }

  template <int MOD = int(1e9+7)>
  LMatrix<MOD> powerm(LMatrix<MOD> &a, long long n){
    long long tmp = n;
    LMatrix<MOD> curr = a;
    LMatrix<MOD> res(a.n);
    res.identity();
    while(tmp){
      if(tmp % 2 == 1){
        res = res * curr;
      }
      curr = curr * curr;
      tmp /= 2;
    }
    return res;
  }

snippet lmatrix_use
  LMatrix<> l(2, 2);

snippet counting_sort_def
  void counting_sort(vector<int> &x, int k){
    vector<int> v(k + 1);
    for(int i = 0; i < x.size(); i++){
      v[x[i]]++;
    }
    int at = 0;
    for(int i = 0; i < v.size(); i++){
      for(int j = 0; j < v[i]; j++){
        x[at++] = i;
      }
    }
  }

snippet counting_sort_use
  counting_sort(v);

snippet edmonds_karp_def
  template <typename T>
  struct edge {int to; T cap; int rev;};

  template <typename T>
  struct Graph{
    int n;
    vector<vector<edge<T>>> vec;
    Graph(int n): n(n){
      vec.resize(n);
    }
    void adde(int at, int to, T cap){
      vec[at].push_back((edge<T>){to, cap, (int)vec[to].size()});
      vec[to].push_back((edge<T>){at, 0, (int)vec[at].size() - 1});
    }
    T max_flow(int s, int t){
      T f = 0;
      while(true){
        queue<int> q;
        q.push(s);
        vector<pair<int, int>> prev(n, make_pair(-1, -1));
        prev[s] = make_pair(s, -1);
        while(!q.empty() && prev[t].first < 0){
          auto p = q.front(); q.pop();
          for(int i = 0; i < vec[p].size(); i++){
            auto e = vec[p][i];
            if(prev[e.to].first < 0 && e.cap > 0){
              prev[e.to] = make_pair(p, i);
              q.push(e.to);
            }
          }
        }
        if(prev[t].first < 0)return f;
        T mini = numeric_limits<T>::max();
        for(int i = t; prev[i].first != i; i = prev[i].first){
          int p = prev[i].first;
          auto e = vec[p][prev[i].second];
          mini = min(mini, e.cap);
        }
        for(int i = t; prev[i].first != i; i = prev[i].first){
          int p = prev[i].first;
          auto& e = vec[p][prev[i].second];
          e.cap -= mini;
          vec[i][e.rev].cap += mini;
        }
        f += mini;
      }
    }
    T min_cut(int s, int t){
      return max_flow(s, t);
    }
  };

  using GraphI = Graph<int>;
  using GraphL = Graph<long long>;

snippet edmonds_karp_use
  GraphI graph(n);
  graph.max_flow();

snippet dinic_def
  template <typename T>
  struct edge {int to; T cap; int rev;};

  template <typename T>
  struct Graph{
    int n;
    vector<vector<edge<T>>> vec;
    vector<int> level;
    vector<int> iter;
    Graph(int n): n(n){
      vec.resize(n);
      level.resize(n);
      iter.resize(n);
    }
    void adde(int at, int to, T cap){
      vec[at].push_back((edge<T>){to, cap, (int)vec[to].size()});
      vec[to].push_back((edge<T>){at, 0, (int)vec[at].size() - 1});
    }
    void bfs(int s){
      fill(level.begin(), level.end(), -1);
      level[s] = 0;
      queue<int> q;
      q.push(s);
      while(!q.empty()){
        auto p = q.front(); q.pop();
        for(auto e: vec[p]){
          if(level[e.to] < 0 && e.cap > 0){
            level[e.to] = level[p] + 1;
            q.push(e.to);
          }
        }
      }
    }
    T dfs(int v, int t, T f){
      if(v == t)return f;
      int st = iter[v];
      for(int i = st; i < vec[v].size(); i++){
        iter[v] = i;
        auto& e = vec[v][i];
        if(level[v] < level[e.to] && e.cap > 0){
          auto d = dfs(e.to, t, min(f, e.cap));
          if(d > 0){
            e.cap -= d;
            vec[e.to][e.rev].cap += d;
            return d;
          }
        }
      }
      return 0;
    }
    T max_flow(int s, int t){
      T flow = 0;
      while(true){
        bfs(s);
        if(level[t] < 0)return flow;
        fill(iter.begin(), iter.end(), 0);
        T inf = numeric_limits<T>::max();
        T f = dfs(s, t, inf);
        while(f > 0){
          flow += f;
          f = dfs(s, t, inf);
        }
      }
    }
    T min_cut(int s, int t){
      return max_flow(s, t);
    }
  };

  using GraphI = Graph<int>;
  using GraphL = Graph<long long>;

snippet dinic_use
  GraphI graph(n);
  graph.max_flow();

snippet primal_dual_def
  template <typename T>
  struct edge {int to; T cap; T cost; int rev;};

  template <typename T>
  struct Graph{
    int n;
    vector<vector<edge<T>>> vec;
    Graph(int n): n(n){
      vec.resize(n);
    }
    void adde(int at, int to, T cap, T cost){
      vec[at].push_back((edge<T>){to, cap, cost, (int)vec[to].size()});
      vec[to].push_back((edge<T>){at, 0, -cost, (int)vec[at].size() - 1});
    }
    T min_cost_flow(int s, int t, T f){
      T res = 0;
      vector<T> h(n, 0), dis(n, 0);
      vector<int> prevv(n), preve(n);
      T inf = numeric_limits<T>::max();
      while(f > 0){
        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;
        fill(dis.begin(), dis.end(), inf);
        dis[s] = 0;
        pq.push(make_pair(0, s));
        while(!pq.empty()){
          auto p = pq.top(); pq.pop();
          int v = p.second;
          if(dis[v] < p.first)continue;
          for(int i = 0; i < vec[v].size(); i++){
            auto& e = vec[v][i];
            if(e.cap > 0 && dis[e.to] > dis[v] + e.cost + h[v] - h[e.to]){
              dis[e.to] = dis[v] + e.cost + h[v] - h[e.to];
              prevv[e.to] = v;
              preve[e.to] = i;
              pq.push(make_pair(dis[e.to], e.to));
            }
          }
        }

        if(dis[t] == inf)return -1;
        for(int i = 0; i < n; i++)h[i] += dis[i];
        T d = f;
        for(int i = t; i != s; i = prevv[i]){
          d = min(d, vec[prevv[i]][preve[i]].cap);
        }
        f -= d;
        res += d * h[t];
        for(int i = t; i != s; i = prevv[i]){
          auto& e = vec[prevv[i]][preve[i]];
          e.cap -= d;
          vec[i][e.rev].cap += d;
        }
      }
      return res;
    }
  };

  using GraphI = Graph<int>;
  using GraphL = Graph<long long>;

snippet primal_dual_use
  GraphI graph(n);
  graph.min_cost_flow(s, t, f);

snippet successive_shortest_path_def
  template <typename T>
  struct edge {int to; T cap; T cost; int rev;};

  template <typename T>
  struct Graph{
    int n;
    vector<vector<edge<T>>> vec;
    Graph(int n): n(n){
      vec.resize(n);
    }
    void adde(int at, int to, T cap, T cost){
      vec[at].push_back((edge<T>){to, cap, cost, (int)vec[to].size()});
      vec[to].push_back((edge<T>){at, 0, -cost, (int)vec[at].size() - 1});
    }
    T min_cost_flow(int s, int t, T f){
      T res = 0;
      vector<T> dis(n, 0);
      vector<int> prevv(n), preve(n);
      T inf = numeric_limits<T>::max();
      while(f > 0){
        fill(dis.begin(), dis.end(), inf);
        dis[s] = 0;
        bool update = true;
        while(update){
          update = false;
          for(int i = 0; i < n; i++){
            if(dis[i] == inf)continue;
            for(int j = 0; j < vec[i].size(); j++){
              auto e = vec[i][j];
              if(e.cap > 0 && dis[e.to] > dis[i] + e.cost){
                dis[e.to] = dis[i] + e.cost;
                prevv[e.to] = i;
                preve[e.to] = j;
                update = true;
              }
            }
          }
        }

        if(dis[t] == inf)return -1;
        T d = f;
        for(int i = t; i != s; i = prevv[i]){
          d = min(d, vec[prevv[i]][preve[i]].cap);
        }
        f -= d;
        res += d * dis[t];
        for(int i = t; i != s; i = prevv[i]){
          auto& e = vec[prevv[i]][preve[i]];
          e.cap -= d;
          vec[i][e.rev].cap += d;
        }
      }
      return res;
    }
  };

  using GraphI = Graph<int>;
  using GraphL = Graph<long long>;

snippet successive_shortest_path_use
  GraphI graph(n);
  graph.min_cost_flow(s, t, f);

snippet convert_def
  int ato_int(char c){
    return int(c - 'a');
  }

  char to_achar(int i){
    return char(i + 'a');
  }

  int Ato_int(char c){
    if('a' <= c && c <= 'z')return int(c - 'a');
    return int(c - 'A') + 26;
  }

  char to_Achar(int i){
    if(i < 26)return char(i + 'a');
    return char(i - 26 + 'A');
  }

  int dto_int(char c){
    return int(c - '0');
  }

  char to_dchar(int i){
    return char(i + '0');
  }

snippet wavelet_matrix_def
  vector<int> ato_vector(const string &s){
    vector<int> v(s.size());
    for(int i = 0; i < s.size(); i++){
      v[i] = ato_int(s[i]);
    }
    return v;
  }

  template <typename T>
  struct WaveletMatrix{
    int n = 0;
    int len = 0;
    vector<SuccinctBitVector> mat;
    vector<int> zc;
    vector<int> bl, br;
    vector<vector<T>> sum;
    WaveletMatrix(T m, vector<T> s){
      len = s.size();
      while((1LL<< n) <= m)n++;
      mat.resize(n);
      zc.resize(n);
      bl.resize(n);
      br.resize(n);
      sum.resize(n + 1, vector<T>(len + 1, 0));

      for(int i = 0; i < len; i++)sum[0][i + 1] = sum[0][i] + s[i];

      vector<T> l(len), r(len);
      for(int i = 0; i < n; i++){
        mat[i] = SuccinctBitVector(len + 1);
        int li = 0, ri = 0;
        for(int j = 0; j < len; j++){
          if((s[j] >> (n - i - 1)) & 1){
            r[ri++] = s[j];
            mat[i].set_bit(j);
          }else{
            l[li++] = s[j];
          }
        }
        zc[i] = li;
        mat[i].build();
        swap(l, s);
        for(int j = 0; j < ri; j++)s[li + j] = r[j];
        for(int j = 0; j < len; j++)sum[i+1][j+1] = sum[i+1][j] + s[j];
      }
    }
    T access(int i){
      int res = 0;
      for(int j = 0; j < n; j++){
        bool bit = mat[j][i];
        res = (res << 1) | bit;
        i = zc[j] * bit + mat[j].rank(bit, i);
      }
      return res;
    }
    T operator[](int i){
      return access(i);
    }
    int rank(T val, int i){
      int l = 0, r = i;
      for(int j = 0; j < n; j++){
        bl[j] = l, br[j] = r;
        bool bit = (val >> (n - j - 1)) & 1;
        l = zc[j] * bit + mat[j].rank(bit, l);
        r = zc[j] * bit + mat[j].rank(bit, r);
      }
      return r - l;
    }
    int select(T val, int i){
      rank(val, len);
      for(int j = n - 1; j >= 0; j--){
        bool bit = (val >> (n - j - 1)) & 1;
        i = mat[j].select(bit, i, bl[j]);
        if(i >= br[j] || i < 0)return -1;
        i -= bl[j];
      }
      return i;
    }
    int select(T val, int i, int l){
      return select(val, i + rank(val, l));
    }
    T quantile(int s, int e, int k){
      if(e - s <= k || k < 0)return -1;
      T res = 0;
      for(int i = 0; i < n; i++){
        int l = mat[i].rank(1, s);
        int r = mat[i].rank(1, e);
        if(r - l > k){
          s = zc[i] + l;
          e = zc[i] + r;
          res = res | (1LL << (n - i - 1));
        }else{
          k -= (r - l);
          s -= l;
          e -= r;
        }
      }
      return res;
    }
    // equal, lt, gt
    tuple<int, int, int> rankall(T x, int s, int e){
      if(s >= e)return make_tuple(0, 0, 0);
      int rank_lt = 0, rank_gt = 0;
      for(int i = 0; i < n && s < e; i++){
        bool bit = (x >> (n - i - 1)) & 1;
        int s0 = mat[i].rank(0, s);
        int s1 = s - s0;
        int e0 = mat[i].rank(0, e);
        int e1 = e - e0;
        if(bit){
          rank_lt += e0 - s0;
          s = zc[i] + s1;
          e = zc[i] + e1;
        }else{
          rank_gt += e1 - s1;
          s = s0;
          e = e0;
        }
      }
      return make_tuple(e - s - rank_lt - rank_gt, rank_lt, rank_gt);
    }
    int rangefreq(int s, int e, T mini, T maxi){
      tuple<int, int, int> maxi_t = rankall(maxi, s, e);
      tuple<int, int, int> mini_t = rankall(mini, s, e);
      return get<1>(maxi_t) - get<1>(mini_t);
    }
    int ranklt(T x, int s, int e){
      return get<1>(rankall(x, s, e));
    }
    int rankgt(T x, int s, int e){
      return get<2>(rankall(x, s, e));
    }
    T rangemax(int s, int e){
      return quantile(s, e, 0);
    }
    T rangemin(int s, int e){
      return quantile(s, e, e - s - 1);
    }
    vector<pair<T, int>> topk(int s, int e, int k){
      vector<pair<T, int>> res;
      using v_t = tuple<int, int, int, int, T>;
      auto comp = [](const v_t &a, const v_t &b){
        if(get<0>(a) != get<0>(b))return get<0>(a) < get<0>(b);
        if(get<3>(a) != get<3>(b))return get<3>(a) > get<3>(b);
        return get<3>(a) > get<3>(b);
      };
      priority_queue<v_t, vector<v_t>, decltype(comp)> pq(comp);
      pq.push(make_tuple(e - s, s, e, 0, 0));
      while(!pq.empty()){
        auto p = pq.top(); pq.pop();
        int width, li, ri, dep;
        T val;
        tie(width, li, ri, dep, val) = p;
        if(dep >= n){
          res.emplace_back(make_pair(val, ri - li));
          if(res.size() >= k)break;
          continue;
        }
        int l0 = mat[dep].rank(0, li);
        int r0 = mat[dep].rank(0, ri);
        if(l0 < r0)pq.push(make_tuple(r0 - l0, l0, r0, dep + 1, val));
        int l1 = zc[dep] + mat[dep].rank(1, li);
        int r1 = zc[dep] + mat[dep].rank(1, ri);
        if(l1 < r1)pq.push(make_tuple(r1 - l1, l1, r1, dep + 1, val | (1LL << (n - dep - 1))));
      }
      return res;
    }
    T rangesum(int s, int e, int depth, T val, T x, T y){
      if(s == e)return 0;
      if(depth == n){
        if(x <= val && val < y)return val * (e - s);
        return 0;
      }
      T nv = (1LL << (n - depth - 1)) | val;
      T nnv = ((1LL << (n - depth - 1)) - 1) | nv;
      if(nnv < x || y <= val)return 0;
      if(x <= val && nnv < y)return sum[depth][e] - sum[depth][s];
      int s0 = mat[depth].rank(0, s);
      int s1 = s - s0;
      int e0 = mat[depth].rank(0, e);
      int e1 = e - e0;
      return rangesum(s0, e0, depth + 1, val, x, y) + rangesum(zc[depth] + s1, zc[depth] + e1, depth + 1, nv, x, y);
    }
    T rangesum(int s, int e, T x, T y){
      return rangesum(s, e, 0, 0, x, y);
    }
    T prev(int s, int e, T x, T y){
      y--;
      using v_t = tuple<int, int, int, T, bool>;
      stack<v_t> st;
      st.push(make_tuple(s, e, 0, 0, true));
      while(!st.empty()){
        auto p = st.top(); st.pop();
        int li, ri, depth;
        T val;
        bool tight;
        tie(li, ri, depth, val, tight) = p;

        if(depth == n){
          if(val >= x)return val;
          continue;
        }
        
        bool bit = (y >> (n - depth - 1)) & 1;
        int l0 = mat[depth].rank(0, li);
        int l1 = li - l0;
        int r0 = mat[depth].rank(0, ri);
        int r1 = ri - r0;
        if(l0 != r0){
          st.push(make_tuple(l0, r0, depth + 1, (val << 1), tight && !bit));
        }
        if(l1 != r1){
          if(!tight || bit){
            st.push(make_tuple(zc[depth] + l1, zc[depth] + r1, depth + 1, ((val<<1)|1), tight));
          }
        }
      }
      return -1;
    }
    T next(int s, int e, T x, T y){
      using v_t = tuple<int, int, int, T, bool>;
      stack<v_t> st;
      st.push(make_tuple(s, e, 0, 0, true));
      while(!st.empty()){
        auto p = st.top(); st.pop();
        int li, ri, depth;
        T val;
        bool tight;
        tie(li, ri, depth, val, tight) = p;
        if(depth == n){
          if(val < y)return val;
          continue;
        }
        
        bool bit = (x >> (n - depth - 1)) & 1;
        int l0 = mat[depth].rank(0, li);
        int l1 = li - l0;
        int r0 = mat[depth].rank(0, ri);
        int r1 = ri - r0;
        if(l1 != r1){
          st.push(make_tuple(zc[depth] + l1, zc[depth] + r1, depth + 1, ((val<<1)|1), tight && bit));
        }
        if(l0 != r0){
          if(!tight || !bit){
            st.push(make_tuple(l0, r0, depth + 1, (val << 1), tight));
          }
        }
      }
      return -1;
    }
    vector<tuple<T, int, int>> intersect(int s1, int e1, int s2, int e2){
      using v_t = tuple<int, int, int, int, int, T>;
      vector<tuple<T, int, int>> res;
      queue<v_t> q;
      q.push(make_tuple(s1, e1, s2, e2, 0, 0));
      while(!q.empty()){
        auto p = q.front(); q.pop();
        int s_1, e_1, s_2, e_2, depth;
        T val;
        tie(s_1, e_1, s_2, e_2, depth, val) = p;
        if(depth == n){
          res.emplace_back(make_tuple(val, e_1 - s_1, e_2 - s_2));
          continue;
        }

        int s1_0 = mat[depth].rank(0, s_1);
        int e1_0 = mat[depth].rank(0, e_1);
        int s2_0 = mat[depth].rank(0, s_2);
        int e2_0 = mat[depth].rank(0, e_2);

        if(s1_0 != e1_0 && s2_0 != e2_0){
          q.push(make_tuple(s1_0, e1_0, s2_0, e2_0, depth + 1, val));
        }

        int s1_1 = s_1 - s1_0 + zc[depth];
        int e1_1 = e_1 - e1_0 + zc[depth];
        int s2_1 = s_2 - s2_0 + zc[depth];
        int e2_1 = e_2 - e2_0 + zc[depth];

        if(s1_1 != e1_1 && s2_1 != e2_1){
          q.push(make_tuple(s1_1, e1_1, s2_1, e2_1, depth + 1, val | (1LL << (n - depth - 1))));
        }
      }
      return res;
    }
    void max_dfs(int d, int s, int e, int &k, T val, vector<T> &vs){
      if(s >= e || !k)return;
      if(d == n){
        while(s++ < e && k > 0)vs.emplace_back(val), k--;
        return;
      }
      int l1 = mat[d].rank(1, s);
      int r1 = mat[d].rank(1, e);
      max_dfs(d + 1, zc[d] + l1, zc[d] + r1, k, (1LL<<(n-d-1))|val, vs);
      max_dfs(d + 1, s - l1, e - r1, k, val, vs);
    }
    vector<T> maximum(int s, int e, int k){
      if(e - s < k)k = e - s;
      if(k < 0)return {};
      vector<T> res;
      max_dfs(0, s, e, k, 0, res);
      return res;
    }
    void list_dfs(int d, int s, int e, T val, T a, T b, vector<pair<T, int>> &vs){
      if(val >= b || e - s <= 0)return;
      if(d == n){
        if(a <= val){
          vs.emplace_back(make_pair(val, e - s));
        }
        return;
      }
        T nv = val | (1LL<<(n-d-1)), nnv = nv | ((1LL<<(n-d-1))-1);
        if(nnv < a)return;
        int l0 = mat[d].rank(1, s);
        int r0 = mat[d].rank(1, e);
        list_dfs(d + 1, s - l0, e - r0, val, a, b, vs);
        list_dfs(d + 1, zc[d] + l0, zc[d] + r0, nv, a, b, vs);
    }
    vector<pair<T, int>> freq_list(int s, int e, T a, T b){
      vector<pair<T, int>> res;
      list_dfs(0, s, e, 0, a, b, res);
      return res;
    }
    vector<pair<int, T>> get_rect(int s, int e, T a, T b){
      vector<pair<T, int>> fl = freq_list(s, e, a, b);
      vector<pair<int, T>> res;
      for(auto &e: fl){
        for(int i = 0; i < e.second; i++){
          res.emplace_back(make_pair(select(e.first, i, s), e.first));
        }
      }
      return res;
    }
  };

snippet wavelet_matrix_use
  vector<int> c = ato_vector(s);
  WaveletMatrix<int> w(26, c);

snippet strongly_connected_components_def
  struct Graph{
    int n;
    vector<vector<int>> edge;
    vector<vector<int>> rev;
    vector<bool> used;
    vector<int> tn;
    vector<int> id;
    int cnt = 0;
    vector<vector<int>> scc_edge;
    Graph(){}
    Graph(int n): n(n){
      edge.resize(n);
      rev.resize(n);
      used.resize(n, false);
      id.resize(n);
    }
    void adde(int from, int to){
      edge[from].emplace_back(to);
      rev[to].emplace_back(from);
    }
    void dfs(int i){
      used[i] = true;
      for(auto e: edge[i]){
        if(!used[e])dfs(e);
      }
      tn.emplace_back(i);
    }
    void rev_dfs(int i, int cnt){
      used[i] = true;
      id[i] = cnt;
      for(auto e: rev[i]){
        if(!used[e]){
          rev_dfs(e, cnt);
        }
      }
    }
    int kosaraju(){
      tn.clear();
      fill(used.begin(), used.end(), false);

      for(int i = 0; i < n; i++){
        if(!used[i])dfs(i);
      }

      fill(used.begin(), used.end(), false);

      cnt = 0;
      for(int i = n - 1; i >= 0; i--){
        int v = tn[i];
        if(!used[v]){
          rev_dfs(v, cnt);
          cnt++;
        }
      }
      return cnt;
    }
    void compose(){
      scc_edge.resize(cnt);
      map<int, vector<int>> mp;
      for(int i = 0; i < n; i++)mp[id[i]].emplace_back(i);
      for(auto itr = mp.begin(); itr != mp.end(); ++itr){
        set<int> st;
        int at = id[(itr->second)[0]];
        for(auto v: itr->second){
          for(auto e: edge[v]){
            if(id[e] != at && st.find(id[e]) == st.end()){
              scc_edge[at].emplace_back(id[e]);
              st.insert(id[e]);
            }
          }
        }
      }
    }
  };

snippet strongly_connected_components_use
  Graph graph(n);
  graph.adde(u, v);
  graph.kosaraju();
  graph.compose();

snippet TwoBIT_def
  template <typename T>
  struct TwoBIT{
    int n = 0, m = 0;
    vector<vector<T>> bit;
    TwoBIT(int n, int m): n(n), m(m){
      bit.assign(n, vector<T>(m, 0));
    }
    void add(int a, int b, T w){
      for(int x = a; x < n; x |= (x + 1)){
        for(int y = b; y < m; y |= (y + 1)){
          bit[x][y] += w;
        }
      }
    }
    T sum(int a, int b){
      if(a < 0 || b < 0)return 0;
      T res = 0;
      for(int x = a; x >= 0; x = (x & (x + 1)) - 1){
        for(int y = b; y >= 0; y = (y & (y + 1)) - 1){
          res += bit[x][y];
        }
      }
      return res;
    }
  };

snippet TwoBIT_use
  TwoBIT<ll> tb(n, m);
  tb.add(i, j, k);
  tb.sum(x, y);

snippet TwoSAT_def
  struct TwoSAT{
    Graph graph;
    int n;
    TwoSAT(){}
    TwoSAT(int n): n(n){
      graph = Graph(2 * n);
    }
    int no_t(int i){
      if(i < n)return i + n;
      else return i - n;
    }
    void add_relation(int i, int j){
      graph.adde(no_t(i), j);
      graph.adde(no_t(j), i);
    }
    bool two_satisfiability(){
      graph.kosaraju();
      for(int i = 0; i < n; i++){
        if(graph.id[i] == graph.id[no_t(i)])return false;
      }
      return true;
    }
  };

snippet TwoSAT_use
  TwoSAT ts(n);
  ts.add_relation(i, ts.no_t(j));
  bool b = ts.two_satisfiability();

snippet lowest_common_ancestor_def
  struct Tree{
    int n = 0, m = 0;
    vector<vector<int>> edge;
    vector<vector<int>> par;
    vector<bool> vis;
    vector<int> h;
    Tree(){}
    Tree(int n): n(n){
      while((1LL<<m) <= n)m++;
      edge.resize(n);
      par.assign(m + 1, vector<int>(n, 0));
      vis.resize(n, false);
      h.resize(n);
    }
    void adde(int from, int to){
      edge[from].emplace_back(to);
    }
    void dfs(int i){
      vis[i] = true;
      for(auto e: edge[i]){
        if(!vis[e]){
          par[0][e] = i;
          h[e] = h[i] + 1;
          dfs(e);
        }
      }
    }
    void build(){
      fill(vis.begin(), vis.end(), false);
      fill(h.begin(), h.end(), 0);
      par[0][0] = 0;
      h[0] = 0;
      dfs(0);
      for(int i = 1; i <= m; i++){
        for(int j = 0; j < n; j++){
          par[i][j] = par[i-1][par[i-1][j]];
        }
      }
    }
    int go_up(int u, int k){
      int i = 0;
      while(k){
        if(k % 2 == 1){
          u = par[i][u];
        }
        i++;
        k /= 2;
      }
      return u;
    }
    int lca(int u, int v){
      if(h[u] > h[v])u = go_up(u, h[u] - h[v]);
      if(h[u] < h[v])v = go_up(v, h[v] - h[u]);
      if(u == v)return u;
      int ld = 0, rd = n;
      while(rd - ld > 1){
        int k = (rd + ld) / 2;
        int uk = go_up(u, k);
        int vk = go_up(v, k);
        if(uk == vk)rd = k;
        else ld = k;
      }
      return go_up(u, rd);
    }
  };

snippet lowest_common_ancestor_use
  Tree t(n);
  t.adde(u, v);
  t.build();
  t.lca(u, v);

snippet point2d_def
  struct point2d{
    double x, y;
    point2d(){}
    point2d(double x, double y): x(x), y(y){}
    point2d operator+(const point2d &r) const{
      return point2d(x + r.x, y + r.y);
    }
    point2d operator-(const point2d &r) const{
      return point2d(x - r.x, y - r.y);
    }
    point2d& operator+=(const point2d &r){
      *this = *this + r;
      return *this;
    }
    point2d& operator-=(const point2d &r){
      *this = *this - r;
      return *this;
    }
    bool operator==(const point2d &r) const{
      return abs(x - r.x) < EPS && abs(y - r.y) < EPS;
    }
    bool operator!=(const point2d &r) const{
      return !(*this == r);
    }
    bool operator<(const point2d &r) const{
      if(abs(x - r.x) >= EPS)return x < r.x;
      return y < r.y;
    }
  };

  point2d operator*(double x, const point2d &p){
    return point2d(x * p.x, x * p.y);
  }

  point2d operator/(const point2d &p, double x){
    return point2d(p.x / x, p.y / x);
  }

  double norm(const point2d &a){
    return sqrt(a.x * a.x + a.y * a.y);
  }

  double dis(const point2d &a, const point2d &b){
    point2d c = a - b;
    return norm(c);
  }

  double inner_product(const point2d &a, const point2d &b){
    return a.x * b.x + a.y * b.y;
  }

  double outer_product(const point2d &a, const point2d &b){
    return a.x * b.y - a.y * b.x;
  }

  double cosine(const point2d &a, const point2d &b){
    return inner_product(a, b) / norm(a) / norm(b);
  }

snippet point2d_use
  point2d a(1., 1.);

snippet point3d_def
  struct point3d{
    double x, y, z;
    point3d(){}
    point3d(double x, double y, double z): x(x), y(y), z(z){}
    point3d operator+(const point3d &r) const{
      return point3d(x + r.x, y + r.y, z + r.z);
    }
    point3d operator-(const point3d &r) const{
      return point3d(x - r.x, y - r.y, z - r.z);
    }
    point3d& operator+=(const point3d &r){
      *this = *this + r;
      return *this;
    }
    point3d& operator-=(const point3d &r){
      *this = *this - r;
      return *this;
    }
    bool operator==(const point3d &r) const{
      return abs(x - r.x) < EPS && abs(y - r.y) < EPS && abs(z - r.z) < EPS;
    }
    bool operator!=(const point3d &r) const{
      return !(*this == r);
    }
    bool operator<(const point3d &r) const{
      if(abs(x - r.x) >= EPS)return x < r.x;
      if(abs(y - r.y) >= EPS)return y < r.y;
      return z < r.z;
    }
  };

  point3d operator*(double x, const point3d &p){
    return point3d(x * p.x, x * p.y, x * p.z);
  }

  point3d operator/(const point3d &p, double x){
    return point3d(p.x / x, p.y / x, p.z / x);
  }

  double norm(const point3d &a){
    return sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
  }

  double dis(const point3d &a, const point3d &b){
    point3d c = a - b;
    return norm(c);
  }

  double inner_product(const point3d &a, const point3d &b){
    return a.x * b.x + a.y * b.y + a.z * b.z;
  }

  point3d outer_product(const point3d &a, const point3d &b){
    return point3d(a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  }

  double cosine(const point3d &a, const point3d &b){
    return inner_product(a, b) / norm(a) / norm(b);
  }

snippet point3d_use
  point3d(1., 1., 1.);

snippet plane3d_def
  struct plane3d{
    double a, b, c, d;
    double norm = 1.;
    plane3d(){}
    plane3d(double a, double b, double c, double d): a(a), b(b), c(c), d(d){
      build();
    }
    plane3d(const point3d pa, const point3d pb, const point3d pc){
      point3d re = outer_product(pb - pa, pc - pa);
      a = re.x, b = re.y, c = re.z;
      d = - (a * pa.x + b * pa.y + c * pa.z);
      build();
    }
    void build(){
      norm = sqrt(a * a + b * b + c * c);
    }
    double dis(point3d p){
      return abs(a * p.x + b * p.y + c * p.z + d) / norm;
    }
    double val(const point3d &p){
      return a * p.x + b * p.y + c * p.z + d;
    }
  };

snippet plane3d_use
  plane3d pl(pa, pb, pc);

snippet projection_def
  point2d projection(const point2d &p, const point2d &p1, const point2d &p2){
    point2d p2p1 = p2 - p1, pp1 = p - p1;
    if(abs(inner_product(p2p1, pp1)) < EPS)return p1;
    double cosi = cosine(p2p1, pp1);
    return p1 + (dis(p, p1) * cosi / norm(p2 - p1)) * (p2 - p1);
  }

snippet projection_use
  point2d pr = projection(p, p1, p2);

snippet reflection_def
  point2d reflection(const point2d &p, const point2d &p1, const point2d &p2){
    point2d pr = projection(p, p1, p2);
    return p + 2. * (pr - p);
  }

snippet reflection_use
  point2d pr = reflection(p, p1, p2);

snippet plane2d_def
  struct plane2d{
    double a, b, c;
    double norm;
    plane2d(){}
    plane2d(double a, double b, double c): a(a), b(b), c(c){}
    plane2d(const point2d &p, const point2d &q){
      point2d l = p - q;
      a = l.y, b = - l.x;
      c = - a * p.x - b * p.y;
      build();
    }
    void build(){
      norm = sqrt(a * a + b * b);
    }
    double dis(const point2d &p){
      return abs(a * p.x + b * p.y + c) / norm;
    }
    double val(const point2d &p){
      return a * p.x + b * p.y + c;
    }
  };

snippet plane2d_use
  plane2d pl = plane2d(pa, pb);

snippet paralell_def
  bool parallel(const plane2d &p, const plane2d &q){
    return abs(p.a * q.b - p.b * q.a) < EPS;
  }

snippet parallel_use
  bool b = parallel(pla, plb);

snippet orthogonal_def
  bool orthogonal(const plane2d &p, const plane2d &q){
    return abs(p.a * q.a + p.b * q.b) < EPS;
  }

snippet orthogonal_use
  bool b = orthogonal(pla, plb);

snippet intersection_def
  bool intersection(const point2d &p1, const point2d &p2, const point2d &p3, const point2d &p4){
    plane2d pl1(p1, p2), pl2(p3, p4);
    if(abs(pl1.val(p3)) < EPS && min(p1.x, p2.x) <= p3.x && p3.x <= max(p1.x, p2.x) &&
        min(p1.y, p2.y) <= p3.y && p3.y <= max(p1.y, p2.y))return true;
    if(abs(pl1.val(p4)) < EPS && min(p1.x, p2.x) <= p4.x && p4.x <= max(p1.x, p2.x) &&
        min(p1.y, p2.y) <= p4.y && p4.y <= max(p1.y, p2.y))return true;
    if(abs(pl2.val(p1)) < EPS && min(p3.x, p4.x) <= p1.x && p1.x <= max(p3.x, p4.x) &&
        min(p3.y, p4.y) <= p1.y && p1.y <= max(p3.y, p4.y))return true;
    if(abs(pl2.val(p2)) < EPS && min(p3.x, p4.x) <= p2.x && p2.x <= max(p3.x, p4.x) &&
        min(p3.y, p4.y) <= p2.y && p2.y <= max(p3.y, p4.y))return true;
    return pl1.val(p3) * pl1.val(p4) <= - EPS && pl2.val(p1) * pl2.val(p2) <= - EPS;
  }

snippet intersection_use
  bool b = intersection(p1, p2, p3, p4);

snippet euler_tour_def
  struct Tree{
    int n = 0;
    vector<vector<int>> edges;
    vector<int> b, e;
    vector<int> v;
    Tree(){}
    Tree(int n): n(n){
      edges.resize(n);
      b.resize(n);
      e.resize(n);
      v.reserve(2 * n - 1);
    }
    void adde(int from, int to){
      edges[from].emplace_back(to);
    }
    void dfs(int i){
      v.emplace_back(i);
      b[i] = int(v.size()) - 1;
      for(auto c: edges[i]){
        if(b[c] == -1)dfs(c);
        v.emplace_back(i);
      }
      e[i] = int(v.size()) - 1;
    }
    void build(int r = 0){
      b.assign(n, -1);
      e.assign(n, -1);
      v.resize(0);
      dfs(r);
    }
  };

snippet euler_tour_use
  Tree t(n);
  t.adde(from, to);
  t.build();

snippet diameter_def
  template <typename T>
  struct edge{
    int from, to;
    T w;
    edge(){}
    edge(int from, int to, T w): from(from), to(to), w(w){}
  };

  template <typename T>
  struct Tree{
    int n = 0;
    vector<vector<edge<T>>> edges;
    vector<T> dis;
    Tree(){}
    Tree(int n): n(n){
      edges.resize(n);
      dis.resize(n);
    }
    void adde(int from, int to, T cost){
      edges[from].emplace_back(edge<T>(from, to, cost));
    }
    void dfs(int i){
      for(auto e: edges[i]){
        if(dis[e.to] == -1){
          dis[e.to] = dis[i] + e.w;
          dfs(e.to);
        }
      }
    }
    T diameter(){
      dis.assign(n, -1);
      dis[0] = 0;
      dfs(0);
      int at = 0;
      T maxi = -1;
      for(int i = 0; i < n; i++){
        if(maxi < dis[i]){
          maxi = dis[i];
          at = i;
        }
      }
      dis.assign(n, -1);
      dis[at] = 0;
      dfs(at);
      T res = -1;
      for(int i = 0; i < n; i++){
        res = max(res, dis[i]);
      }
      return res;
    }
  };

snippet diameter_use
  Tree t(n);
  t.adde(from, to, cost);
  t.diameter();

snippet RUPQ_BIT_def
  template <typename T>
  struct RUPQ_BIT{
    int n;
    BIT_<T> bt;
    RUPQ_BIT(){}
    RUPQ_BIT(int n): n(n){
      bt = BIT_<T>(n);
    }
    void add(int a, int b, T w){
      bt.add(a, w);
      bt.add(b, - w);
    }
    T get(int i){
      return bt.sum(i);
    }
  };

snippet RUPQ_BIT_use
  RUPQ_BIT<int> rb(n);
  rb.add(a, b, w);
  rb.get(i);

snippet RURQ_BIT_def
  template <typename T>
  struct RURQ_BIT{
    int n;
    BIT_<T> btp, btq;
    RURQ_BIT(){}
    RURQ_BIT(int n): n(n){
      btp = BIT_<T>(n);
      btq = BIT_<T>(n);
    }
    void add(int a, int b, T w){
      btp.add(a, - w * a);
      btp.add(b, w * b);
      btq.add(a, w);
      btq.add(b, - w);
    }
    T sum(int i){
      return btp.sum(i) + btq.sum(i) * (i + 1);
    }
  };

snippet RURQ_BIT_use
  RURQ_BIT<int> rrb(n);
  rrb.add(a, b, w);
  rrb.sum(i);

snippet closest_pair_def
  double closest_pair(vector<point2d> &a, int l, int r){
    double d = numeric_limits<double>::max();
    if(r - l == 1)return d;

    int m = (l + r) / 2;
    double x = a[m].x;
    d = min(closest_pair(a, l, m), closest_pair(a, m, r));
    inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, [](const point2d &u, const point2d &v){
      return u.y < v.y;
      });

    vector<point2d> v;
    for(int i = l; i < r; i++){
      if(abs(x - a[i].x) >= d)continue;
      for(int j = 0; j < v.size(); j++){
        double dx = a[i].x - v[v.size()-j-1].x;
        double dy = a[i].y - v[v.size()-j-1].y;
        if(dy >= d)break;
        d = min(d, sqrt(dx * dx + dy * dy));
      }
      v.push_back(a[i]);
    }
    return d;
  }

  double closest_pair(vector<point2d> &a){
    sort(a.begin(), a.end(), [](const point2d &u, const point2d &v){
        if(u.x != v.x)return u.x < v.x;
        return u.y < v.y;
        });
    return closest_pair(a, 0, int(a.size()));
  }

snippet closest_pair_use
  closest_pair(a);

snippet ntt_def
  template <int MOD, int g>
  struct NTT{
    int get_mod(){
      return MOD;
    }
    void _ntt(vector<long long> &f, bool inv=false){
      int n = f.size(), mask = n - 1;
      int h = power<long long>(g, (MOD - 1) / n, MOD);
      if(inv)h = modinv(h, MOD);
      vector<long long> tmp(n);
      for(int i = n >> 1; i >= 1; i >>= 1){
        long long zeta = power<long long>(h, i, MOD);
        long long w = 1;
        for(int j = 0; j < n; j += i){
          for(int k = 0; k < i; k++){
            tmp[j+k] = (f[((j<<1)&mask)+k] + w * f[(((j<<1)+i)&mask)+k] % MOD) % MOD;
          }
          w = w * zeta % MOD;
        }
        swap(f, tmp);
      }
    }
    void ntt(vector<long long> &f){
      _ntt(f, false);
    }
    void intt(vector<long long> &f){
      _ntt(f, true);
      int n = f.size();
      int ni = modinv(n, MOD);
      for(int i = 0; i < n; i++)f[i] = f[i] * ni % MOD;
    }
    vector<long long> convolution(vector<long long> f, vector<long long> h){
      int n = 1;
      while(n < int(f.size() + h.size()))n *= 2;
      f.resize(n, 0); h.resize(n, 0);
      ntt(f);
      ntt(h);
      for(int i = 0; i < n; i++)f[i] = f[i] * h[i] % MOD;
      intt(f);
      return f;
    }
  };

  using NTT1 = NTT<167772161, 3>;
  using NTT2 = NTT<469762049, 3>;
  using NTT3 = NTT<1224736769, 3>;

  vector<long long> arbitrary_mod_convolution(vector<long long> f, vector<long long> g, int MOD){
    for(size_t i = 0; i < f.size(); i++)f[i] %= MOD;
    for(size_t i = 0; i < g.size(); i++)g[i] %= MOD;
    NTT1 ntt1;
    NTT2 ntt2;
    NTT3 ntt3;
    auto x1 = ntt1.convolution(f, g);
    auto x2 = ntt2.convolution(f, g);
    auto x3 = ntt3.convolution(f, g);

    vector<long long> res(x1.size());
    vector<long long> b(3), m(3);
    m[0] = ntt1.get_mod();
    m[1] = ntt2.get_mod();
    m[2] = ntt3.get_mod();
    for(size_t i = 0; i < x1.size(); i++){
      b[0] = x1[i];
      b[1] = x2[i];
      b[2] = x3[i];
      res[i] = garner<long long>(b, m, MOD);
    }
    return res;
  }

snippet ntt_use
  auto v = arbitrary_mod_convolution(f, g, MOD);
