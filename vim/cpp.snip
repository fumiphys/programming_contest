snippet bw_def
  string bwt_sa(string s) {
    SAManberMyers sa = SAManberMyers(s);
    string res = "";
    for(int i = 0; i <= s.size(); i++){
      if(sa.sa[i] == 0)res += '$';
      else res += s[sa.sa[i] - 1];
    }
    return res;
  }

  string inverse_bwt(string s) {
    string res = "";
    vector<int> C = vector<int>(27, 0);
    vector<int> psi = vector<int>(s.size(), 0);
    int p = 0;

    for(int i = 0; i < s.size(); i++){
      if(s[i] == '$'){
        C[0]++;
      }
      else C[s[i] - 'a' + 1]++;
    }
    int sum = 0;
    for(int i = 0; i <= 26; i++){
      int tmp = C[i];
      C[i] = sum;
      sum += tmp;
    }

    for(int i = 0; i < s.size(); i++){
      int c;
      if(s[i] == '$')c = 0;
      else c = int(s[i] - 'a' + 1);
      psi[C[c]] = i;
      C[c]++;
    }

    for(int i = 0; i < s.size(); i++){
      p = psi[p];
      res += s[p];
    }

    return res.substr(1, res.size() - 1);
  }

snippet bw_use
  string tb = bwt_sa(s);

snippet suffixarray_use
  SAManberMyers sa = SAManberMyers(s);

snippet suffixarray_def
  typedef struct SAManberMyers_ {
    string s;
    vector<int> rank;
    vector<int> tmp;
    vector<int> sa;
    int n, k;
    SAManberMyers_(string ss){
      s = ss;
      n = s.size();
      rank.resize(n + 1);
      tmp.resize(n + 1);
      sa.resize(n + 1);
      k = 0;

      // construct suffix array
      construct();
    }
    bool comp(const int &a, const int &b){
      if(rank[a] != rank[b])return rank[a] < rank[b];
      int ra = a + k <= n ? rank[a + k] : -1;
      int rb = b + k <= n ? rank[b + k] : -1;
      return ra < rb;
    }
    void construct(){
      for(int i = 0; i <= n; i++){
        sa[i] = i;
        rank[i] = i < n ? s[i] : -1;
      }

      for(k = 1; k <= n; k *= 2){
        sort(sa.begin(), sa.end(), [this] (const int &a, const int &b) {return comp(a, b);});

        tmp[sa[0]] = 0;
        for(int i = 1; i <= n; i++){
          tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1], sa[i]) ? 1 : 0);
        }
        for(int i = 0; i <= n; i++){
          rank[i] = tmp[i];
        }
      }
    }
  } SAManberMyers;

snippet brute_search_use
  res = find_text(s, t);

snippet kmp_search_use
  res = kmp_search(s, t);

snippet bm_search_use
  res = bm_search(s, t);

snippet sa_search_use
  res = sa_search(s, t);

snippet brute_search_def
  vector<int> find_text(string s, string t) {
    vector<int> res;
    for(int i = 0; i + t.size() <= s.size(); i++){
      bool flag = true;
      for(int j = 0; j < t.size(); j++){
        if(s[i + j] != t[j]){
          flag = false;
          break;
        }
      }
      if(flag)res.push_back(i);
    }
    return res;
  }

snippet kmp_search_def
  vector<int> kmp_table(string t){
    vector<int> res = vector<int>(t.size(), 0);
    int j = 0;
    for(int i = 1; i < t.size(); i++){
      if(t[i] == t[j]){
        j++;
      }else{
        j = 0;
      }
      res[i] = j;
    }
    return res;
  }

  // s: text, t: pattern
  vector<int> kmp_search(string s, string t){
    vector<int> res;
    vector<int> shift = kmp_table(t);

    // i: text index, p: pattern index
    int i = 0, p = 0;
    while(i < s.size() && p < t.size()){
      if(s[i] == t[p]){
        i++;
        p++;
      }else if(p == 0){
        i++;
      }else{
        p = shift[p - 1];
      }
      if(p == t.size()){
        res.push_back(i - p);
        p = shift[p - 1];
      }
    }

    return res;
  }

snippet bm_search_def
  // s: text, t: pattern
  vector<int> bm_search(string s, string t){
    vector<int> res;
    unordered_map<char, int> mp;
    for(int i = 0; i < t.size(); i++){
      mp[t[i]] = t.size() - 1 - i;
    }
    // i: text index, p: pattern index
    int i = t.size() - 1, p = t.size() - 1;
    while(i < s.size() && p < t.size()){
      if(s[i] == t[p]){
        i--;
        p--;
      }else{
        if(mp.find(s[i]) == mp.end()){
          i += t.size();
        }else{
          if(p >= t.size() - 1 - mp[s[i]])i += mp[s[i]];
          else i += t.size() - p + 1;
        }
        p = t.size() - 1;
      }
      if(p < 0){
        res.push_back(i + 1);
        i += t.size() + 1;
        p = t.size() - 1;
      }
    }

    return res;
  }

snippet sa_search_def
  vector<int> sa_search_(SAManberMyers &sa, string s, string t){
    vector<int> res;
    t += "$";
    s += "$";
    int ld = -1;
    int rd = sa.sa.size() - 1;
    while(rd - ld > 1){
      int md = (rd + ld) / 2;
      if(s.substr(sa.sa[md]) < t)ld = md;
      else rd = md;
    }
    t = t.substr(0, t.size() - 1);
    while(rd < sa.sa.size()){
      if(s.substr(sa.sa[rd], t.size()) != t)break;
      res.push_back(sa.sa[rd]);
      rd++;
    }
    sort(res.begin(), res.end());
    return res;
  }

  vector<int> sa_search(string s, string t){
    SAManberMyers sa(s);
    vector<int> res = sa_search_(sa, s, t);
    return res;
  }

snippet BIT_use
  BITI bt(10);

snippet BIT_def
  template<typename T>
  struct BIT_{
    int n;
    vector<T> bit;
    BIT_(int n_){
      n = n_;
      bit = vector<T>(n+1, 0);
    }
    void add(int a, T w){
      for(int x = a; x < n; x |= (x + 1)){
        bit[x] += w;
      }
    }
    T sum(int a){
      T res = 0;
      for(int x = a; x >= 0; x = (x & (x + 1)) - 1){
        res += bit[x];
      }
      return res;
    }
  };

  typedef struct BIT_<int> BITI;
  typedef struct BIT_<long long> BITL;

snippet segtree_use
  SegmentTreeI seg = SegmentTreeI(n, [](int a, int b){return min(a, b);},
      [](int a,int b){return b;}, INT_MAX, v);

snippet segtree_def
  template<typename T, typename E>
  struct SegmentTree_ {
    function<T(T, T)> f;
    function<T(T, E)> g;
    int n;
    T def;
    vector<T> vec;
    SegmentTree_(){}
    SegmentTree_(int n_, function<T(T, T)> f_, function<T(T, E)> g_, T def_, vector<T> v=vector<T>()){
      f = f_;
      g = g_;
      def = def_;

      // initialize vector
      n = 1;
      while(n < n_){
        n *= 2;
      }
      vec = vector<T>(2*n -1, def);

      // initialize segment tree
      for(int i = 0; i < v.size(); i++){
        vec[i + n - 1] = v[i];
      }
      for(int i = n - 2; i >= 0; i--){
        vec[i] = f(vec[2*i+1], vec[2*i+2]);
      }
    }
    void update(int k, E val){
      k = k + n - 1;
      vec[k] = g(vec[k], val);
      while(k > 0){
        k = (k - 1) / 2;
        vec[k] = f(vec[2*k+1], vec[2*k+2]);
      }
    }
    // [l, r) -> [a, b) (at k)
    T query(int a, int b, int k, int l, int r){
      if(r <= a || b <= l)return def;
      if(a <= l && r <= b)return vec[k];
      T ld = query(a, b, 2*k+1, l, (l+r)/2);
      T rd = query(a, b, 2*k+2, (l+r)/2, r);
      return f(ld, rd);
    }
    T query(int a, int b){
      return query(a, b, 0, 0, n);
    }
  };

  template<typename T, typename E>
  using SegmentTree = struct SegmentTree_<T, E>;
  using SegmentTreeI = SegmentTree<int, int>;
  using SegmentTreeL = SegmentTree<long long, long long>;

snippet unionfind_use
  UnionFind uf(10);

snippet unionfind_def
  typedef struct UnionFind_ {
    vector<int> par;
    vector<int> rank_;
    UnionFind_(int n): rank_(n, 0) {
      for(int i = 0; i < n; i++)par.push_back(i);
    }
    int find(int x) {
      if(par[x] == x)return x;
      else return par[x] = find(par[x]);
    }
    bool same(int x, int y) {
      if(find(x) == find(y))return true;
      else return false;
    }
    bool unite(int x, int y){
      int xp = find(x);
      int yp = find(y);
      if(xp == yp)return false;
      if(rank_[xp] > rank_[yp])par[yp] = xp;
      else if(rank_[xp] < rank_[yp])par[xp] = yp;
      else {
        par[yp] = xp;
        rank_[xp]++;
      }
      return true;
    }
  } UnionFind;

snippet fordfulkerson_use
  GraphI graph(5);
  int res = graph.max_flow(0, 4);

snippet fordfulkerson_def
  template <typename T>
  struct edge {int to; T cap; int rev;};

  template <typename T>
  struct Graph_ {
    int n;
    vector<bool> used;
    vector<vector<edge<T>> > vec;
    Graph_(){}
    Graph_(int ns) {
      n = ns;
      used.resize(n);
      vec.resize(n);
    }
    void adde(int at, int to, T cap){
      vec[at].pb((edge<T>){to, cap, (int)vec[to].size()});
      vec[to].pb((edge<T>){at, 0, (int)vec[at].size() - 1});
    }
    T dfs(int s, int t, T f){
      if(s == t)return f;
      used[s] = true;
      for(int i = 0; i < vec[s].size(); i++){
        edge<T> &e = vec[s][i];
        if(!used[e.to] && e.cap > 0){
          int d = dfs(e.to, t, min(f, e.cap));
          if(d > 0){
            e.cap -= d;
            vec[e.to][e.rev].cap += d;
            return d;
          }
        }
      }
      return 0;
    }
    T min_cut(int s, int t){
      return max_flow(s, t);
    }
    T max_flow(int s, int t){
      T inf = numeric_limits<T>::max();
      T flow = 0;

      while(true){
        fill(used.begin(), used.end(), false);
        int f = dfs(s, t, inf);
        if(f == 0)return flow;
        flow += f;
      }
    }
  };

  typedef Graph_<int> GraphI;
  typedef Graph_<ll> GraphL;

snippet dijkstra_use
  GraphI graphi(4);
  graphi.dijkstra(1, 3);

snippet dijkstra_def
  template <typename T>
  struct Graph_ {
    int n;
    vector<vector<pair<int, T> > > edge;
    vector<T> dis;
    Graph_(int ns) {
      n = ns;
      edge.resize(n);
      dis.resize(n);
    }
    void dijkstra(int s){
      dijkstra(s, 0);
    }
    T dijkstra(int s, int t){
      // initialize
      fill(dis.begin(), dis.end(), -1);
      vector<bool> used;
      used.resize(n);
      fill(used.begin(), used.end(), false);
      dis[s] = 0;
      // dijkstra
      priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > q;
      q.push(make_pair(0, s));
      while(!q.empty()){
        pair<T, int> p = q.top(); q.pop();
        int at = p.second;
        T distance = p.first;
        if(used[at])continue;
        used[at] = true;
        for(auto itr = edge[at].begin(); itr != edge[at].end(); ++itr){
          int to = (*itr).first;
          T cost = (*itr).second;
          if(used[to])continue;
          if(dis[to] == -1 || dis[to] > distance + cost){
            q.push(make_pair(distance + cost, to));
            dis[to] = distance + cost;
          }
        }
      }
      return dis[t];
    }
    void adde(int at, int to, T cost){
      edge[at].push_back(make_pair(to, cost));
    }
    [[deprecated("This function takes O(edge[at].size()).")]]
    void remove(int at, int to){
      int index = -1;
      for(int i = 0; i < edge[at].size(); i++){
        if(edge[at][i].first == to){
          index = i;
          break;
        }
      }
      edge[at].erase(edge[at].begin() + index);
    }
  };

  typedef struct Graph_<int> GraphI;
  typedef struct Graph_<ll> GraphL;
  typedef struct Graph_<double> GraphD;

snippet warshallfloyd_use
  GraphI graphi(4);
  graphi.warshall_floyd();

snippet warshallfloyd_def
  template <typename T>
  struct Graph_ {
    int n;
    vector<vector<T> > d;
    vector<vector<int> > path;
    Graph_(int ns) {
      n = ns;
      d = vector<vector<T> >(n, vector<T>(n, numeric_limits<T>::max() / 10));
      path = vector<vector<int> >(n, vector<int>(n, -1));
      for(int i = 0; i < n; i++)d[i][i] = 0;
    }
    void warshall_floyd(){
      for(int k = 0; k < n; k++){
        for(int i = 0; i < n; i++){
          for(int j = 0; j < n; j++){
            if(d[i][j] > d[i][k] + d[k][j]){
              d[i][j] = d[i][k] + d[k][j];
              path[i][j] = k;
            }
          }
        }
      }
    }
    void adde(int at, int to, T cost){
      d[at][to] = cost;
    }
  };

  typedef struct Graph_<int> GraphI;
  typedef struct Graph_<ll> GraphL;

snippet gcd_use
  gcd<int>(2, 3);

snippet extgcd_use
  extgcd<int>(3, 2, x, y);

snippet chinesereminder_use
  pair<int, int> p = chinese_reminder_theorem(b, m);

snippet gcd_def
  template<typename T>
  T gcd(T a, T b) {
    if(a > b)return gcd(b, a);
    if(a == 0)return b;
    return gcd(b % a, a);
  }

snippet extgcd_def
  template<typename T>
  T extgcd(T a, T b, T &x, T &y){
    T d = a;
    if(b != 0){
      d = extgcd(b, a % b, y, x);
      y -= (a / b) * x;
    }else{
      x = 1, y = 0;
    }
    return d;
  }

snippet chinesereminder_def
  template<typename T>
  pair<T, T> chinese_reminder_theorem(vector<T> b, vector<T> m){
    T r = 0, M = 1;
    for(int i = 0; i < b.size(); i++){
      T x, y;
      T d = extgcd<T>(M, m[i], x, y);
      if((b[i] - r) % d != 0)return make_pair(0, -1);
      T tmp = (b[i] - r) / d * x % (m[i] / d);
      r += M * tmp;
      M *= m[i] / d;
    }
    r %= M;
    if(r < 0)r += M;
    return make_pair(r % M, M);
  }

snippet convexhulltrick_use
  ConvexHullTrickI cht;
  cht.add(make_pair(2, 0));
  cht.val(2);

snippet convexhulltrick_def
  template <typename T>
  struct ConvexHullTrick_ {
    vector<pair<T, T> > lines;
    function<bool(T l, T r)> comp;
    ConvexHullTrick_(function<bool(T l, T r)> comp_=[](T l, T r){return l >= r;}): comp(comp_){}
    bool isnot_require(pair<T, T> l1, pair<T, T> l2, pair<T, T> l3){
      if(l1 < l3)swap(l1, l3);
      return (l3.second - l2.second) * (l2.first - l1.first) >= (l2.second - l1.second) * (l3.first - l2.first);
    }
    void add(pair<T, T> p){
      while(lines.size() >= 2 && isnot_require(*(lines.end()-2), *(lines.end()-1), p))lines.pop_back();
      lines.push_back(p);
    }
    T f(int i, T x){
      return lines[i].first * x + lines[i].second;
    }
    T val(T x){
      int ld = -1;
      int rd = lines.size() - 1;
      while(rd - ld > 1){
        int md = (rd + ld) / 2;
        if(comp(f(md, x), f(md + 1, x)))ld = md;
        else rd = md;
      }
      return f(rd, x);
    }
  };

  using ConvexHullTrickI = ConvexHullTrick_<int>;
  using ConvexHullTrickL = ConvexHullTrick_<long long>;

snippet crossing_use
  crossing(mk(1, 3), mk(3, 1), mk(0, 0), mk(1, 1));

snippet convexhull_use
  vector<Pd> ch = convex_hull(vec);

snippet crossing_def
  bool crossing(P p1, P p2, P q1, P q2){
    double pq1 = (q1.first - p1.first) * (q2.second - p1.second)
      - (q1.second - p1.second) * (q2.first - p1.first);
    double pq2 = (q1.first - p2.first) * (q2.second - p2.second)
      - (q1.second - p2.second) * (q2.first - p2.first);
    double qp1 = (p1.first - q1.first) * (p2.second - q1.second)
      - (p1.second - q1.second) * (p2.first - q1.first);
    double qp2 = (p1.first - q2.first) * (p2.second - q2.second)
      - (p1.second - q2.second) * (p2.first - q2.first);
    return (pq1 * pq2 < EPS && qp1 * qp2 < EPS);
  }

snippet convex_hull_def
  double cross(const Pd &o, const Pd &a, const Pd &b){
    return (a.first - o.first) * (b.second - o.second) - (a.second - o.second) * (b.first - o.first);
  }

  vector<Pd> convex_hull(vector<Pd> vec){
    int n = vec.size(), k = 0;
    if(n < 3)return vec;

    vector<Pd> ch(2 * n);
    sort(vec.begin(), vec.end());

    // lower
    for(int i = 0; i < n; i++){
      while(k >= 2 && cross(ch[k-2], ch[k-1], vec[i]) <= 0.)k--;
      ch[k++] = vec[i];
    }

    // upper
    for(int i = n - 1, t = k + 1; i > 0; --i){
      while(k >= t && cross(ch[k-2], ch[k-1], vec[i-1]) <= 0.)k--;
      ch[k++] = vec[i-1];
    }

    ch.resize(k - 1);
    return ch;

  }

snippet power_use
  power(2, 3, mod);

snippet inverse_use
  inverse(1, mod);

snippet power_def
  template <typename T>
  T power(T a, T n, T mod) {
    T res = 1;
    T tmp = n;
    T curr = a;
    while(tmp){
      if(tmp % 2 == 1){
        res = (T)((ll)res * curr % mod);
      }
      curr = (T)((ll)curr * curr % mod);
      tmp >>= 1;
    }
    return res;
  }

snippet inverse_def
  // this function can be used when x and mod is coprime
  template <typename T>
  T inverse(T x, T mod) {
    return power<T>(x, mod - 2, mod);
  }

snippet is_prime_use
  is_prime(23);

snippet list_prime_use
  vector<int> p = list_prime(15);

snippet is_prime_def
  template <typename T>
  bool is_prime(T x){
    if(x == 1)return false;
    for(ll i = 2; i * i <= x; i++){
      if(x % i == 0)return false;
    }
    return true;
  }

snippet list_prime_def
  template <typename T>
  vector<T> list_prime(T n){
    vector<T> res;
    vector<bool> i_prime = vector<bool>(n+1, true);
    for(ll i = 2; i <= n; i++){
      if(i_prime[i]){
        res.push_back(i);
        for(ll j = 2; j * i <= n; j++){
          i_prime[i * j] = false;
        }
      }
    }
    return res;
  }

snippet excout_use
  excout("a", "b", "c", 1);

snippet excout_def
  void excout(){
    cout << endl;
  }

  template <class Head, class... Tail>
  void excout(Head&& head, Tail&&... tail){
    if(sizeof...(tail) != 0)cout << head << " ";
    else cout << head;
    excout(forward<Tail>(tail)...);
  }

snippet succinctbitvector_use
  SuccinctBitVector sbv(9);

snippet succinctbitvector_def
  typedef struct SuccinctBitVector_ {
    int size;
    const int block = 32;
    const int l = 256;
    vector<uint32_t> B;
    vector<unsigned> L, S;
    SuccinctBitVector_(int size_){
      size = size_;
      B.assign((size + block - 1) / block, 0U);
      L.assign((size + l - 1) / l, 0U);
      S.assign((size + block - 1) / block, 0U);
    }
    void set_bit(int at){
      B[at / block] |= (1U << (at % block));
    }
    void build(){
      int true_count = 0;
      for(int i = 0; i < ((size + block - 1) / block) * block; i+=block){
        if(i % l == 0)L[i / l] = true_count;
        S[i / block] = true_count - L[i / l];
        true_count += __builtin_popcount(B[i / block]);
      }
    }
    bool access(int at){
      return (B[at / block] >> (at % block)) & 1U;
    }
    // this is rank1
    int rank(int at){
      return S[at / block] + __builtin_popcount((B[at / block] & ((1U << (at % block)) - 1)));
    }
    // this is select1
    int select(int x){
      // binary search for L
      int lld = 0, lrd = L.size();
      while(lrd - lld > 1){
        int md = (lld + lrd) / 2;
        if(L[md] <= x)lld = md;
        else lrd = md;
      }
      // binary search for S
      int sld = lld * l / block;
      int srd = min((lld + 1) * l / block, (int)S.size());
      while(srd - sld > 1){
        int md = (sld + srd) / 2;
        if(L[lld] + S[md] <= x)sld = md;
        else srd = md;
      }
      int tcount = L[lld] + S[sld];
      for(int i = 0; i < block; i++){
        if(((B[sld] >> i) & 1U) == 1)tcount++;
        if(tcount == x + 1)return sld * block + i;
      }
      return -1;
    }
  } SuccinctBitVector;

snippet louds_use
  GraphI graphi(8);
  LOUDS louds = construct_louds(graphi);

snippet louds_def
  typedef struct LOUDS_: SuccinctBitVector{
    LOUDS_(int n): SuccinctBitVector(2 * n + 2){}
    int select0(int x){
      // binary search for L
      int lld = 0, lrd = L.size();
      while(lrd - lld > 1){
        int md = (lld + lrd) / 2;
        if(md * l - L[md] <= x)lld = md;
        else lrd = md;
      }
      // binary search for S
      int sld = lld * l / block;
      int srd = min((lld + 1) * l / block, (int)S.size());
      while(srd - sld > 1){
        int md = (sld + srd) / 2;
        if(md * block - L[lld] - S[md] <= x)sld = md;
        else srd = md;
      }
      int tcount = sld * block - L[lld] - S[sld];
      for(int i = 0; i < block; i++){
        if(((B[sld] >> i) & 1U) == 0)tcount++;
        if(tcount == x + 1)return sld * block + i;
      }
      return -1;
    }
    int par(int x){
      int zero_x = select0(x);
      return rank(zero_x) - 1;
    }
    pair<int, int> child(int x){
      if(select(x) + 1 == select(x + 1))return make_pair(-1, -1);
      int ld = select(x) + 1;
      int rd = select(x + 1);
      return make_pair(ld - rank(ld), rd - 1 - rank(rd));
    }
  } LOUDS;


  LOUDS construct_louds(GraphI graph){
    LOUDS louds(graph.n);
    int curr = 2;
    louds.set_bit(1);
    queue<int> q;
    q.push(0);
    vector<bool> used = vector<bool>(graph.n, false);
    used[0] = true;
    while(!q.empty()){
      int p = q.front(); q.pop();
      for(pair<int, int> c: graph.edge[p]){
        if(!used[c.first]){
          used[c.first] = true;
          q.push(c.first);
          curr++;
        }
      }
      louds.set_bit(curr);
      curr++;
    }
    louds.build();
    return louds;
  }

snippet lazyseg_def
  template<typename T, typename E>
  struct LazySegmentTree_ {
    function<T(T, T)> f;
    function<E(E, E)> h;
    function<T(T, E, int)> p;
    int n;
    T def;
    E l_def;
    vector<T> vec;
    vector<E> lazy;
    LazySegmentTree_(){}
    LazySegmentTree_(int n_, function<T(T, T)> f_, T def_,
        function<E(E, E)> h_, E l_def_, function<T(T, E, int)> p_, vector<T> v=vector<T>()){
      f = f_;
      h = h_;
      p = p_;
      def = def_;
      l_def = l_def_;

      // initialize vector
      n = 1;
      while(n < n_){
        n *= 2;
      }
      vec = vector<T>(2*n-1, def);
      lazy = vector<E>(2*n-1, l_def);

      // initialize segment tree
      for(int i = 0; i < v.size(); i++){
        vec[i + n - 1] = v[i];
      }
      for(int i = n - 2; i >= 0; i--){
        vec[i] = f(vec[2*i+1], vec[2*i+2]);
      }
    }
    void eval(int k, int len){
      if(lazy[k] != l_def){
        if(k < n - 1){
          lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);
          lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);
        }
        vec[k] = p(vec[k], lazy[k], len);
        lazy[k] = l_def;
      }
    }
    E update(int a, int b, const E &val, int k, int l, int r){
      eval(k, r - l);
      if(r <= a || b <= l){
        return vec[k];
      }else if(a <= l && r <= b){
        lazy[k] = h(lazy[k], val);
        eval(k, r - l);
        return vec[k];
      }else{
        return vec[k] = f(update(a, b, val, 2*k+1, l, (l+r)/2),
            update(a, b, val, 2*k+2, (l+r)/2, r));
      }
    }
    E update(int a, int b, E val){
      return update(a, b, val, 0, 0, n);
    }
    // [l, r) -> [a, b) (at k)
    T query(int a, int b, int k, int l, int r){
      eval(k, r - l);
      if(r <= a || b <= l)return def;
      if(a <= l && r <= b)return vec[k];
      T ld = query(a, b, 2*k+1, l, (l+r)/2);
      T rd = query(a, b, 2*k+2, (l+r)/2, r);
      return f(ld, rd);
    }
    T query(int a, int b){
      return query(a, b, 0, 0, n);
    }
  };

  template<typename T, typename E>
  using LazySegmentTree = struct LazySegmentTree_<T, E>;
  using LazySegmentTreeI = LazySegmentTree<int, int>;
  using LazySegmentTreeL = LazySegmentTree<long long, long long>;

snippet lazyseg_use
  LazySegmentTreeI seg = LazySegmentTreeI(n, [](int a, int b){return a + b;},
      0, [](int a, int b){return a + b;}, 0, [](int a, int b, int c){return a + b * c;}, v);

snippet bipartile_def
  struct GraphI {
    int n;
    vector<int> color;
    vector<vector<int> > vec;
    GraphI(int ns) {
      n = ns;
      color.resize(n, 0);
      vec.resize(n);
    }
    void adde(int at, int to){
      vec[at].push_back(to);
    }
    bool is_bipartile(){
      for(int i = 0; i < n; i++){
        if(color[i] == 0){
          if(!dfs(i, 1)){
            return false;
          }
        }
      }
      return true;
    }
    bool dfs(int v, int c){
      color[v] = c;
      for(int i: vec[v]){
        if(color[i] == c){
          return false;
        }
        if(color[i] == 0 && !dfs(i, -c))return false;
      }
      return true;
    }
  };

snippet bipartile_use
  GraphI graph(3);
  graph.is_bipartile();

snippet topologicaldag_def
  struct Graph{
    int n;
    vector<vector<int> > edge;
    vector<int> in_deg;
    Graph(int n_){
      n = n_;
      edge.resize(n);
      in_deg.resize(n, 0);
    }
    void adde(int at, int to){
      edge[at].push_back(to);
      in_deg[to]++;
    }
    vector<int> topological_sort(){
      stack<int> st;
      for(int i = 0; i < n; i++){
        if(in_deg[i] == 0)st.push(i);
      }
      vector<int> res;
      while(st.size()){
        int at = st.top(); st.pop();
        res.push_back(at);
        for(int j: edge[at]){
          in_deg[j]--;
          if(in_deg[j] == 0)st.push(j);
        }
      }

      return res;
    }
  };

snippet topologicaldag_use
  Graph graph(7);
  vector<int> ts = graph.topological_sort();

snippet bellmanford_def
  template <typename T>
  struct edge{int from, to; T cost;};

  template <typename T>
  struct Graph{
    int n;
    vector<T> d;
    vector<edge<T>> es;
    Graph(int n_){
      n = n_;
      d.resize(n, numeric_limits<T>::max());
    }
    void adde(edge<T> e){
      es.push_back(e);
    }
    bool bellman_ford(int s){
      T maxim = numeric_limits<T>::max();
      fill(d.begin(), d.end(), maxim);
      d[s] = 0;
      for(int i = 0; i < n; i++){
        bool update = false;
        for(auto e: es){
          if(d[e.from] != maxim && d[e.to] > d[e.from] + e.cost){
            d[e.to] = d[e.from] + e.cost;
            update = true;
            if(i == n - 1)return false;
          }
        }
        if(!update)break;
      }
      return true;
    }
  };

snippet bellmanford_use
  Graph<ll> graphl(5);
  graphl.bellman_ford(0);

snippet prim_def
  template <typename T>
  struct Graph{
    int n;
    vector<vector<pair<int, T> > > es;
    vector<T> mincost;
    vector<bool> used;
    Graph(int n_){
      n = n_;
      es.resize(n);
      mincost.resize(n);
      used.resize(n);
    }
    void adde(int from, int to, T cost){
      es[from].push_back(make_pair(to, cost));
      es[to].push_back(make_pair(from, cost));
    }
    T prim(){
      fill(mincost.begin(), mincost.end(), numeric_limits<T>::max());
      fill(used.begin(), used.end(), false);
      T res = 0;
      priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > pq;
      mincost[0] = 0;
      pq.push(make_pair(0, 0));
      while(!pq.empty()){
        pair<T, int> p = pq.top(); pq.pop();
        if(used[p.second])continue;
        used[p.second] = true;
        res += p.first;
        for(auto e: es[p.second]){
          if(!used[e.first] && mincost[e.first] > e.second){
            mincost[e.first] = e.second;
            pq.push(make_pair(mincost[e.first], e.first));
          }
        }
      }
      return res;
    }
  };

  using GraphI = Graph<int>;

snippet prim_use
  GraphI graph(7);
  int cost = graph.prim();

snippet kruskal_def
  typedef struct UnionFind_ {
    vector<int> par;
    vector<int> rank_;
    UnionFind_(int n): rank_(n, 0) {
      for(int i = 0; i < n; i++)par.push_back(i);
    }
    int find(int x) {
      if(par[x] == x)return x;
      else return par[x] = find(par[x]);
    }
    bool same(int x, int y) {
      if(find(x) == find(y))return true;
      else return false;
    }
    bool unite(int x, int y){
      int xp = find(x);
      int yp = find(y);
      if(xp == yp)return false;
      if(rank_[xp] > rank_[yp])par[yp] = xp;
      else if(rank_[xp] < rank_[yp])par[xp] = yp;
      else {
        par[yp] = xp;
        rank_[xp]++;
      }
      return true;
    }
  } UnionFind;

  template <typename T>
  struct edge{
    int from;
    int to;
    T cost;
  };

  template <typename T>
  bool comp(const edge<T> &a, const edge<T> &b){
    return a.cost < b.cost;
  }

  template <typename T>
  struct Graph {
    int n;
    vector<edge<T>> es;
    Graph(int n_){
      n = n_;
    }
    void adde(int from, int to, T cost){
      es.push_back((edge<T>){from, to, cost});
    }
    T kruskal(){
      T res = 0;
      UnionFind uf(n);
      sort(es.begin(), es.end(), comp<T>);
      for(auto e: es){
        int from = e.from;
        int to = e.to;
        T cost = e.cost;
        if(uf.same(from, to))continue;
        res += cost;
        uf.unite(from, to);
      }

      return res;
    }
  };

  using GraphI = Graph<int>;

snippet kruskal_use
  GraphI graphi(7);
  graphi.kruskal();

snippet merge_def
  template <typename T>
  void merge(vector<T> &a, int l, int m, int r){
    int n1 = m - l;
    int n2 = r - m;
    vector<T> L, R;
    for(int i = 0; i < n1; i++)L.push_back(a[l+i]);
    for(int i = 0; i < n2; i++)R.push_back(a[m+i]);
    L.push_back(numeric_limits<T>::max());
    R.push_back(numeric_limits<T>::max());
    int i = 0, j = 0;
    for(int k = l; k < r; k++){
      if(L[i] <= R[j]){
        a[k] = L[i];
        i++;
      }else{
        a[k] = R[j];
        j++;
      }
    }
  }

  template <typename T>
  void merge_sort(vector<T> &a, int l, int r){
    if(l + 1 < r){
      int m = (l + r) / 2;
      merge_sort<T>(a, l, m);
      merge_sort<T>(a, m, r);
      merge<T>(a, l, m, r);
    }
  }

  template <typename T>
  void merge_sort(vector<T> &a){
    merge_sort<T>(a, 0, a.size());
  }

snippet merge_use
  merge_sort(vec);

snippet devisor_def
  template <typename T>
  vector<T> devisor(T n){
    vector<T> res;
    for(T i = 1; i * i <= n; i++){
      if(n % i == 0){
        res.push_back(i);
        if(n != i * i)res.push_back(n / i);
      }
    }
    sort(res.begin(), res.end());
    return res;
  }

snippet devisor_use
  vector<int> d = devisor(n);

snippet factorize_def
  template <typename T>
  map<T, int> factorize(T n){
    map<T, int> res;
    T tmp = n;
    for(T i = 2; i * i <= n; i++){
      while(tmp % i == 0){
        ++res[i];
        tmp /= i;
      }
    }
    if(tmp != 1)res[tmp] = 1;
    return res;
  }

snippet factorize_use
  map<int, int> mp = factorize(n);

snippet millar_rabin_def
  template <typename T>
  bool suspect(T a, int s, T d, T n){
    T x = power<T>(a, d, n);
    if(x == 1)return true;
    for(int r = 0; r < s; r++){
      if(x == n - 1)return true;
      x = x * x % n;
    }
    return false;
  }

  template <typename T>
  bool millar_rabin(T n){
    if(n <= 1 || (n > 2 && n % 2 == 0))return false;
    vector<ll> test = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    T d = n - 1;
    int s = 0;
    while(d % 2 == 0)s++, d /= 2;
    for(int i = 0; i < test.size() && test[i] < n; i++){
      if(!suspect<T>(test[i], s, d, n))return false;
    }
    return true;
  }

snippet millar_rabin_use
  bool b = millar_rabin(n)

snippet gauss_jordan_def
  template <typename T>
  struct Matrix{
    T EPS = (T)1e-10;
    vector<vector<T> > val;
    Matrix(int n, int m, T def = 0): val(n, vector<T>(m, def)){}
    inline vector<T> &operator[](size_t i){return val[i];};
    size_t size() const {return val.size();}
    int gauss_jordan(bool is_extended = false){
      int m = val.size(), n = val[0].size();
      int rank = 0;
      for(int col = 0; col < n; col++){
        if(col == n - 1 && is_extended)break;

        int pivot = -1;
        T ma = EPS;
        for(int row = rank; row < m; row++){
          if(abs(val[row][col]) > ma){
            ma = abs(val[row][col]);
            pivot = row;
          }
        }
        if(pivot == -1)continue;
        swap(val[rank], val[pivot]);

        T fac = val[rank][col];
        for(int col2 = 0; col2 < n; col2++){
          val[rank][col2] /= fac;
        }

        for(int row = 0; row < m; row++){
          if(row != rank && abs(val[row][col]) > EPS){
            T fac = val[row][col];
            for(int col2 = 0; col2 < n; col2++){
              val[row][col2] -= val[rank][col2] * fac;
            }
          }
        }

        rank++;
      }
      return rank;
    }
  };

snippet linear_eq_def
  template <typename T>
  vector<T> linear_eq(Matrix<T>& A, vector<T>& b){
    int m = A.size(), n = A[0].size();
    Matrix<T> M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);
    vector<T> res;
    for(int row = rank; row < m; row++){
      if(abs(M[row][n]) > M.EPS)return res;
    }
    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return res;
  }

snippet gauss_jordan_use
  int rank = M.gauss_jordan();

snippet linear_eq_use
  vector<T> res = linear_eq(A, b);

snippet gauss_jordanp_def
  template <typename T, int mod = int(1e9+7)>
  struct MatrixP{
    vector<vector<T> > val;
    MatrixP(int n, int m, T def = 0): val(n, vector<T>(m, def)){}
    inline vector<T> &operator[](size_t i){return val[i];};
    size_t size() const {return val.size();}
    int gauss_jordan(bool is_extended = false){
      int m = val.size(), n = val[0].size();
      int rank = 0;
      for(int row = 0; row < m; row++){
        for(int col = 0; col < n; col++){
          val[row][col] = (val[row][col] % mod + mod) % mod;
        }
      }
      for(int col = 0; col < n; col++){
        if(col == n - 1 && is_extended)break;

        int pivot = -1;
        for(int row = rank; row < m; row++){
          if(val[row][col] != 0){
            pivot = row;
            break;
          }
        }
        if(pivot == -1)continue;
        swap(val[rank], val[pivot]);

        T fac = power(val[rank][col], mod - 2, mod);
        for(int col2 = 0; col2 < n; col2++){
          val[rank][col2] * fac % mod;
        }

        for(int row = 0; row < m; row++){
          if(row != rank && val[row][col] != 0){
            T fac = val[row][col];
            for(int col2 = 0; col2 < n; col2++){
              val[row][col2] -= val[rank][col2] * fac % mod;
              if(val[row][col2])val[row][col2] += mod;
            }
          }
        }

        rank++;
      }
      return rank;
    }
  };

snippet gauss_jordanp_use
  int rank = M.gauss_jordan();

snippet linear_eqp_def
  template <typename T, int mod = int(1e9+7)>
  int linear_eq(MatrixP<T>& A, vector<T>& b, vector<T> &res){
    int m = A.size(), n = A[0].size();
    MatrixP<T, mod> M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);
    for(int row = rank; row < m; row++){
      if(M[row][n] != 0)return -1;
    }
    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return rank;
  }

snippet linear_eqp_use
  int rank = linear_eq(A, b, res);

snippet gauss_jordanb_def
  const int MAX_H = 510, MAX_W = 510;
  struct MatrixB {
    int H, W;
    bitset<MAX_W> val[MAX_H];
    MatrixB(int m = 1, int n = 1): H(m), W(n){}
    inline bitset<MAX_W>& operator[](size_t i){return val[i];}
    int gauss_jordan(bool is_extended = false){
      int rank = 0;
      for(int col = 0; col < W; col++){
        if(col == W - 1 && is_extended)break;
        int pivot = -1;
        for(int row = rank; row < H; row++){
          if(val[row][col]){
            pivot = row;
            break;
          }
        }
        if(pivot == -1)continue;
        swap(val[pivot], val[rank]);
        for(int row = 0; row < H; row++){
          if(row != rank && val[row][col])val[row] ^= val[rank];
        }
        rank++;
      }
      return rank;
    }
  };

snippet gauss_jordanb_use
  int rank = M.gauss_jordan();

snippet linear_eqb_def
  int linear_eq(MatrixB &A, vector<int> b, vector<int> & res){
    int m = A.H, n = A.W;
    MatrixB M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);

    for(int row = rank; row < m; row++){
      if(M[row][n])return -1;
    }

    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return rank;
  }

snippet linear_eqb_use
  int rank = M.linear_eq(A, b, res);

snippet treap_def
  template <typename T>
  struct Treap{
    random_device rnd;
    struct Node{
      T key;
      int pri;
      Node *l, *r;
      Node(T key, int pri): key(key), pri(pri), l(nullptr), r(nullptr){}
      ~Node(){
        delete l;
        delete r;
      }
    };
    using Tree = Node *;
    Tree root = nullptr;
    size_t _size = 0;

    Treap(){}
    size_t size(){
      return _size;
    }
    void split(Tree t, T key, Tree &l, Tree &r){
      if(!t){
        l = r = nullptr;
      }else if(key < t->key){
        split(t->l, key, l, t->l);
        r = t;
      }else{
        split(t->r, key, t->r, r);
        l = t;
      }
    }
    void merge(Tree &t, Tree l, Tree r){
      if(!l)return r;
      if(!r)return l;
      if(l->pri > r->pri){
        merge(l->r, l->r, r);
        t = l;
      }else{
        merge(r->l, l, r->l);
        t = r;
      }
    }
    void insert(Tree &t, Tree n){
      if(!t)t = n;
      else if(n->pri > t->pri){
        split(t, n->key, n->l, n->r);
        t = n;
      }else{
        if(n->key < t->key)insert(t->l, n);
        else insert(t->r, n);
      }
    }
    void insert(T key){
      insert(root, new Node(key, rnd()));
      _size++;
    }
    void erase(Tree &t, T key){
      if(t->key == key){
        merge(t, t->l, t->r);
        _size--;
      }else{
        if(key < t->key)erase(t->l, key);
        else erase(t->r, key);
      }
    }
    void erase(T key){
      erase(root, key);
    }
    bool find(Tree &t, T key){
      if(!t)return false;
      else if(t->key == key)return true;
      else{
        if(key < t->key)return find(t->l, key);
        else return find(t->r, key);
      }
    }
    bool find(T key){
      return find(root, key);
    }
  };

snippet treap_use
  Treap<int> tr;

snippet fast_zeta_def
  /*
   * f(U) = \sum_{U\in T}f(T)
   * for f(U) = \sum_{T\in U}f(T), use f[j | i] += f[j];
   */
  template <typename T>
  void fast_zeta(vector<T> &f){
    int n = f.size();
    for(int i = 1; i < n; i<<=1){
      for(int j = 0; j < n; j++){
        if((j & i) == 0){
          f[j] += f[j | i];
        }
      }
    }
  }

snippet fast_zeta_use
  fast_zeta(vec);

snippet fast_moebius_def
  /*
   * f(U) = \sum_{U\in T}(-1)^(|T\U|)f(T)
   * for f(U) = \sum_{T\in U}f(T), use f[j | i] -= f[j];
   */
  template <typename T>
  void fast_moebius(vector<T> &f){
    int n = f.size();
    for(int i = 1; i < n; i<<=1){
      for(int j = 0; j < n; j++){
        if((j & i) == 0){
          f[j] -= f[j | i];
        }
      }
    }
  }

snippet fast_moebius_use
  fast_moebius(vec);

snippet implicit_treap_def
  template <typename T, typename E>
  struct ImplicitTreap{
    random_device rnd;
    T def = 0;
    E l_def = 0;
    function<T(T, T)> f;
    function<E(E, E)> g;
    function<T(T, E, int)> p;

    struct Node{
      T val, acc;
      E lazy;
      int cnt, pri;
      bool rev;
      Node *l, *r;
      Node(T val, int pri, T def, E l_def): val(val), acc(def), lazy(l_def), cnt(1), pri(pri), rev(false), l(nullptr), r(nullptr){}
    };
    using Tree = Node *;
    Tree root = nullptr;
    ImplicitTreap(T def, E l_def, function<T(T, T)> f, function<E(E, E)> g, function<T(T, E, int)> p): def(def), l_def(l_def), f(f), g(g), p(p){}
    int cnt(Tree t){
      if(!t)return 0;
      return t->cnt;
    }
    T acc(Tree t){
      if(!t)return def;
      return t->acc;
    }
    void update_cnt(Tree t){
      if(t){
        t->cnt = 1 + cnt(t->l) + cnt(t->r);
      }
    }
    void update_acc(Tree t){
      if(t){
        t->acc = f(t->val, f(acc(t->l), acc(t->r)));
      }
    }
    void pushup(Tree t){
      update_cnt(t);
      update_acc(t);
    }
    void pushdown(Tree t){
      if(t){
        if(t->rev){
          t->rev = false;
          swap(t->l, t->r);
          if(t->l)t->l->rev ^= 1;
          if(t->r)t->r->rev ^= 1;
        }
        if(t->lazy != l_def){
          if(t->l){
            t->l->lazy = g(t->l->lazy, t->lazy);
            t->l->acc = p(t->l->acc, t->lazy, cnt(t->l));
          }
          if(t->r){
            t->r->lazy = g(t->r->lazy, t->lazy);
            t->r->acc = p(t->r->acc, t->lazy, cnt(t->r));
          }
          t->val = p(t->val, t->lazy, 1);
          t->lazy = l_def;
        }
      }
      pushup(t);
    }
    void split(Tree t, int key, Tree &l, Tree &r){
      if(!t){
        l = r = nullptr;
        return;
      }
      pushdown(t);
      int ikey = cnt(t->l) + 1;
      if(key < ikey)split(t->l, key, l, t->l), r = t;
      else split(t->r, key - ikey, t->r, r), l = t;
      pushup(t);
    }
    void merge(Tree &t, Tree l, Tree r){
      pushdown(l);
      pushdown(r);
      if(!l || !r){
        if(l)t = l;
        else t = r;
        return;
      }
      if(l->pri > r->pri){
        merge(l->r, l->r, r), t = l;
      }else{
        merge(r->l, l, r->l), t = r;
      }
      pushup(t);
    }
    void insert(Tree &t, int key, Tree item){
      Tree t1, t2;
      split(t, key, t1, t2);
      merge(t1, t1, item);
      merge(t, t1, t2);
    }
    void erase(Tree &t, int key){
      Tree t1, t2, t3;
      split(t, key + 1, t1, t2);
      split(t1, key, t1, t3);
      merge(t, t1, t2);
      delete t2;
    }
    void update(Tree t, int l, int r, E x){
      Tree t1, t2, t3;
      split(t, l, t1, t2);
      split(t2, r - l, t2, t3);
      t2->lazy = g(t2->lazy, x);
      t2->acc = p(t2->acc, x, cnt(t2));
      merge(t2, t2, t3);
      merge(t, t1, t2);
    }
    T query(Tree t, int l, int r){
      Tree t1, t2, t3;
      split(t, l, t1, t2);
      split(t2, r - l, t2, t3);
      T res = t2->acc;
      merge(t2, t2, t3);
      merge(t, t1, t2);
      return res;
    }
    int find(Tree t, T x, int of, bool left=true){
      if(f(t->acc, x) == x)return -1;
      if(left){
        if(t->l && f(t->l->acc, x) != x)return find(t->l, x, of, left);
        if(f(t->val, x) != x)return of + cnt(t->l);
        return find(t->r, x, of + cnt(t->l) + 1, left);
      }else{
        if(t->r && f(t->r->acc, x) != x)return find(t->r, x, of + cnt(t->l) + 1, left);
        if(f(t->val, x) != x)return of + cnt(t->l);
        return find(t->l, x, of, left);
      }
    }
    void reverse(Tree t, int l, int r){
      if(l > r)return;
      Tree t1, t2, t3;
      split(t, l, t1, t2);
      split(t2, r - l, t2, t3);
      t2->rev ^= 1;
      merge(t2, t2, t3);
      merge(t, t1, t2);
    }
    // m is top
    void rotate(Tree t, int l, int m, int r){
      reverse(t, l, r);
      reverse(t, l, l + r - m);
      reverse(t, l + r - m, r);
    }
    int size(){
      return cnt(root);
    }
    void insert(int pos, T x){
      insert(root, pos, new Node(x, rnd(), def, l_def));
    }
    void update(int l, int r, T x){
      update(root, l, r, x);
    }
    T query(int l, int r){
      return query(root, l, r);
    }
    int find(int l, int r, T x, bool left=true){
      Tree t1, t2, t3;
      split(root, l, t1, t2);
      split(t2, r - l, t2, t3);
      int res = find(t2, x, l, left);
      merge(t2, t2, t3);
      merge(root, t1, t2);
      return res;
    }
    void erase(int pos){
      erase(root, pos);
    }
    void reverse(int l, int r){
      reverse(root, l, r);
    }
    void rotate(int l, int m, int r){
      rotate(root, l, m, r);
    }
    T operator[](int pos){
      Tree t1, t2, t3;
      split(root, pos + 1, t1, t2);
      split(t1, pos, t1, t3);
      T res = t3->acc;
      merge(t1, t1, t3);
      merge(root, t1, t2);
      return res;
    }
  };

snippet implicit_treap_use
  ImplicitTreap<int, int> itr(0, 0, [](int a, int b){return a + b;},
      [](int a, int b){return a + b;}, [](int a, int b, int c){return a + b * c;});

snippet rolling_hash_def
  template <int MS = 2>
  struct RollingHash{
    const long long mod[2] = {999999937LL, 1000000007L};
    const long long base[2] = {9973, 10007};
    vector<long long> hash[MS], power[MS];
    int n = 0;
    RollingHash(){}
    RollingHash(const string &s){
      n = s.size();
      for(int i = 0; i < MS; i++){
        hash[i].assign(n + 1, 0);
        power[i].assign(n + 1, 0);
        hash[i][0] = 0;
        power[i][0] = 1;
        for(int j = 0; j < n; j++){
          power[i][j+1] = power[i][j] * base[i] % mod[i];
          hash[i][j+1] = (hash[i][j] * base[i] + s[j]) % mod[i];
        }
      }
    }
    long long get(int l, int r, int i) const{
      return ((hash[i][r] - hash[i][l] * power[i][r-l]) % mod[i] + mod[i]) % mod[i];
    }
    bool match(int l1, int r1, int l2, int r2) const{
      bool res = true;
      for(int i = 0; i < MS; i++){
        res &= (get(l1, r1, i) == get(l2, r2, i));
      }
      return res;
    }
    bool match(int l1, int r1, const RollingHash<MS> &rs, int l2, int r2){
      bool res = true;
      for(int i = 0; i < MS; i++){
        res &= (get(l1, r1, i) == rs.get(l2, r2, i));
      }
      return res;
    }
  };

snippet rolling_hash_use
  RollingHash<> rs(s);

snippet rh_search_def
  vector<int> rh_search(string s, string t){
    RollingHash<> rs = RollingHash<>(s);
    RollingHash<> rt = RollingHash<>(t);
    vector<int> res;
    for(int i = 0; i + t.size() <= s.size(); i++){
      if(rs.match(i, i + t.size(), rt, 0, t.size()))res.push_back(i);
    }
    return res;
  }

snippet rh_search_use
  vector<int> res = rh_search(s, t);
snippet cout_int128_def
  ostream& operator<<(ostream& dest, __int128_t value) {
    ostream::sentry s(dest);
    if(s){
      __uint128_t tmp = value < 0 ? - value: value;
      char buf[128];
      char *d = end(buf);
      do{
        --d;
        *d = "0123456789"[tmp % 10];
        tmp /= 10;
      }while(tmp != 0);
      if(value < 0)--d, *d='-';
      int len = end(buf) - d;
      if(dest.rdbuf()->sputn(d, len) != len){
        dest.setstate(ios_base::badbit);
      }
    }
    return dest;
  }

  __int128_t to_int128(string s){
    __int128_t res = 0;
    for(int i = 0; i < s.size(); i++){
      res = res * 10 + (s[i] - '0');
    }
    return res;
  }

snippet bigint_def
  const ll B = 10000;
  const int BW = 4;
  struct BigInt{
    vector<ll> digit;
    BigInt(ll a = 0){
      digit.emplace_back(a);
      normalize();
    }
    BigInt(const string &s){
      from_string(s);
    }
    void from_string(const string &s){
      digit.clear();
      int i;
      for(i = (int)s.size() - BW; i >= 0; i-=BW){
        digit.emplace_back(stol(s.substr(i, BW)));
      }
      i += BW;
      if(i > 0)digit.emplace_back(stol(s.substr(0, i)));
    }
    void normalize(){
      ll c = 0;
      for(int i = 0; i < digit.size(); i++){
        while(digit[i] < 0){
          if(i + 1 == digit.size())digit.emplace_back(0);
          digit[i+1]--;
          digit[i] += B;
        }
        ll a = digit[i] + c;
        digit[i] = a % B;
        c = a / B;
      }
      while(c){
        digit.emplace_back(c % B);
        c /= B;
      }
      for(int i = (int)digit.size() - 1; i >= 1; i--){
        if(digit[i] == 0){
          digit.pop_back();
        }else{
          break;
        }
      }
    }
    size_t size(){
      return digit.size();
    }
    BigInt& operator=(ll a){
      digit.resize(1, a);
      normalize();
      return *this;
    }
    BigInt& operator=(const string &s){
      from_string(s);
      return *this;
    }
  } ZERO(0), ONE(1);

  ostream &operator<<(ostream &os, const BigInt &b){
    os << b.digit[b.digit.size() - 1];
    for(int i = (int)b.digit.size() - 2; i >= 0; i--){
      os << setw(BW) << setfill('0') << b.digit[i];
    }
    return os;
  }

  istream & operator>>(istream &is, BigInt &b){
    string s;
    is >> s;
    b.from_string(s);
    return is;
  }

  bool operator<(const BigInt &x, const BigInt &y){
    if(x.digit.size() != y.digit.size())return x.digit.size() < y.digit.size();
    for(int i = x.digit.size() - 1; i >= 0; i--){
      if(x.digit[i] != y.digit[i])return x.digit[i] < y.digit[i];
    }
    return false;
  }

  bool operator>(const BigInt &x, const BigInt y){
    return y < x;
  }

  bool operator<=(const BigInt &x, const BigInt &y){
    return !(y < x);
  }

  bool operator>=(const BigInt &x, const BigInt &y){
    return !(x < y);
  }

  bool operator!=(const BigInt &x, const BigInt &y){
    return x < y || y < x;
  }

  bool operator==(const BigInt &x, const BigInt &y){
    return !(x < y) && !(y < x);
  }

  BigInt operator+(const BigInt &x, ll a){
    BigInt res = x;
    res.digit[0] += a;
    res.normalize();
    return res;
  }

  BigInt operator+(const BigInt &x, const BigInt &y){
    BigInt res = x;
    while(res.digit.size() < y.digit.size())res.digit.emplace_back(0);
    for(int i = 0; i < y.digit.size(); i++)res.digit[i] += y.digit[i];
    res.normalize();
    return res;
  }

  BigInt operator-(const BigInt &x, const BigInt &y){
    BigInt res = x;
    assert(res.digit.size() >= y.digit.size());
    for(int i = 0; i < y.digit.size(); i++)res.digit[i] -= y.digit[i];
    res.normalize();
    return res;
  }

  BigInt operator*(const BigInt &x, const BigInt &y){
    BigInt z;
    z.digit.assign(x.digit.size() + y.digit.size(), 0);
    for(int i = 0; i < x.digit.size(); i++){
      for(int j = 0; j < y.digit.size(); j++){
        z.digit[i+j] += x.digit[i] * y.digit[j];
      }
    }
    z.normalize();
    return z;
  }

  BigInt operator*(const BigInt &x, ll a){
    BigInt res = x;
    for(int i = 0; i < res.digit.size(); i++)res.digit[i] *= a;
    res.normalize();
    return res;
  }

  pair<BigInt, ll> divmod(const BigInt &x, ll a){
    ll c = 0;
    BigInt res = x;
    for(int i = (int)res.digit.size() - 1; i >= 0; i--){
      ll t = B * c + res.digit[i];
      res.digit[i] = t / a;
      c = t % a;
    }
    res.normalize();
    return make_pair(res, c);
  }

  BigInt operator/(const BigInt &x, ll a){
    return divmod(x, a).first;
  }

  BigInt operator%(const BigInt &x, ll a){
    return divmod(x, a).second;
  }

  pair<BigInt, BigInt> divmod(const BigInt &x, const BigInt &y){
    BigInt rx = x, ry = y;
    if(x.digit.size() < y.digit.size())return make_pair(ZERO, x);
    int F = B / (y.digit[y.digit.size() - 1] + 1);
    rx = rx * F; ry = ry * F;
    BigInt z;
    z.digit.assign(rx.digit.size() - ry.digit.size() + 1, 0);
    for(int k = (int)z.digit.size() - 1, i = (int)rx.digit.size() - 1; k >= 0; k--, i--){
      z.digit[k] = (i + 1 < rx.digit.size() ? rx.digit[i+1]: 0) * B + rx.digit[i];
      z.digit[k] /= ry.digit[ry.digit.size() - 1];
      BigInt t;
      t.digit.assign(k + ry.digit.size(), 0);
      for(int m = 0; m < ry.digit.size(); m++){
        t.digit[k+m] = z.digit[k] * ry.digit[m];
      }
      t.normalize();
      while(rx < t){
        z.digit[k] -= 1;
        for(int m = 0; m < ry.digit.size(); m++){
          t.digit[k+m] -= ry.digit[m];
        }
        t.normalize();
      }
      rx = rx - t;
    }
    z.normalize();
    return make_pair(z, rx / F);
  }

  BigInt operator/(const BigInt &x, const BigInt &y){
    return divmod(x, y).first;
  }

  BigInt operator%(const BigInt &x, const BigInt &y){
    return divmod(x, y).second;
  }

  BigInt& operator+=(BigInt &x, ll a){
    x = x + a;
    return x;
  }

  BigInt &operator+=(BigInt &x, const BigInt &y){
    x = x + y;
    return x;
  }

  BigInt &operator-=(BigInt &x, const BigInt &y){
    x = x - y;
    return x;
  }

  BigInt& operator*=(BigInt &x, const BigInt &y){
    x = x * y;
    return x;
  }

  BigInt& operator/=(BigInt &x, const BigInt &y){
    x = x / y;
    return x;
  }

  BigInt& operator%=(BigInt &x, const BigInt &y){
    x = x % y;
    return x;
  }

  BigInt& operator/=(BigInt &x, ll a){
    x = x / a;
    return x;
  }

  BigInt& operator%=(BigInt &x, ll a){
    x = x % a;
    return x;
  }

  BigInt sqrt(const BigInt &x){
    BigInt l = 1;
    BigInt r = x;
    while(r - l > BigInt(1)){
      BigInt m = (r + l) / 2;
      if(m * m > x)r = m;
      else l = m;
    }
    return l;
  }

snippet bigint_use
  BigInt b = BigInt("123");

snippet mergable_range_set_def
  template <typename T>
  struct MergableRangeSet{
    using PT = pair<T, T>;
    set<PT> st;
    MergableRangeSet(){}
    // [l, r)
    void add(T l, T r){
      st.insert(make_pair(l, r));
      merge();
    }
    void merge(){
      auto itr = st.begin();
      while(itr != st.end()){
        int l1 = itr->first;
        int r1 = itr->second;
        ++itr;
        if(itr == st.end())break;
        int l2 = itr->first;
        int r2 = itr->second;
        if(l2 <= r1){
          auto prev = itr;
          --prev;
          st.erase(itr);
          st.erase(prev);
          st.insert(make_pair(l1, r2));
          itr = st.lower_bound(make_pair(l1, r2));
        }
      }
    }
    auto begin() noexcept{
      return st.begin();
    }
    auto end() noexcept{
      return st.end();
    }
    size_t size(){
      return st.size();
    }
  };

snippet mergable_range_set_use
  MergableRangeSet<int> mrs;

snippet trie_def
  const int N_AL = 52;
  struct Trie{
    Trie *next[N_AL];
    bool exists = false;
    Trie(){
      for(int i = 0; i < N_AL; i++)next[i] = nullptr;
    }
    int get_index(const char c){
      if('a' <= c && c <= 'z')return int(c - 'a');
      else return 26 + int(c - 'A');
    }
    void insert(const string &s, int i){
      if(i == s.size()){
        exists = true;
        return;
      }
      int index = get_index(s[i]);
      if(!next[index]){
        next[index] = new Trie();
      }
      next[index]->insert(s, i+1);
    }
    void insert(const string &s){
      insert(s, 0);
    }
    bool find(const string &s, int i){
      if(i == s.size()){
        return exists;
      }
      int index = get_index(s[i]);
      if(next[index])return next[index]->find(s, i+1);
      return false;
    }
    bool find(const string &s){
      return find(s, 0);
    }
  };

snippet trie_use
  Trie *root = new Trie();
  root->insert("abc");

snippet lagrangeinterpolationdouble_def
  struct LagrangeInterpolationD{
    int n = 0;
    using T = double;
    vector<T> x, y;
    vector<T> nume;
    LagrangeInterpolationD(const vector<T> &x, const vector<T> &y): x(x), y(y){
      n = x.size() - 1;
      nume.resize(n + 1);
      for(int i = 0; i < n + 1; i++){
        T t = 1.;
        for(int j = 0; j < n + 1; j++){
          if(i == j)continue;
          t = t * (x[i] - x[j]);
        }
        nume[i] = 1. / t;
      }
    }
    T val(T t){
      T a = 1.;
      for(int i = 0; i < n + 1; i++){
        if(t == x[i])return y[i];
        a = a * (t - x[i]);
      }
      T res = 0.;
      for(int i = 0; i < n + 1; i++){
        res += y[i] * nume[i] * (a / (t - x[i]));
      }
      return res;
    }
  };

  using LID = LagrangeInterpolationD;

snippet lagrangeinterpolationdouble_use
  LID lid(x, y);
  lid.val(1.);

snippet modint_def
  template <int MOD>
  struct ModInt {
    ll x = 0;
    ModInt(){}
    ModInt(ll x_){
      x = int(x_ % MOD);
      if(x < 0)x += MOD;
    }
    ModInt(const ModInt &m){
      x = m.x;
    }
    ModInt& operator+=(const ModInt &y){
      x = (x + y.x) % MOD;
      if(x < 0)x += MOD;
      return *this;
    }
    ModInt& operator-=(const ModInt &y){
      x = (x - y.x) % MOD;
      if(x < 0)x += MOD;
      return *this;
    }
    ModInt& operator*=(const ModInt &y){
      x = (x * y.x) % MOD;
      return *this;
    }
    ModInt& operator/=(const ModInt &y){
      x = (x * y.inverse().x) % MOD;
      return *this;
    }
    ModInt inverse() const{
      ll res = 1;
      ll tmp = MOD - 2;
      ll curr = x;
      while(tmp){
        if(tmp % 2 == 1)res = res * curr % MOD;
        curr = curr * curr % MOD;
        tmp /= 2;
      }
      return ModInt(res);
    }
    ModInt operator-() const{
      return ModInt(-x);
    }
    ModInt operator+(const ModInt &y) const{
      return ModInt(*this) += y;
    }
    ModInt operator-(const ModInt &y) const{
      return ModInt(*this) -= y;
    }
    ModInt operator*(const ModInt &y) const{
      return ModInt(*this) *= y;
    }
    ModInt operator/(const ModInt &y) const{
      return ModInt(*this) /= y;
    }
    bool operator==(const ModInt &y) const{
      return x == y.x;
    }
    bool operator!=(const ModInt &y) const{
      return x != y.x;
    }
    friend ostream& operator<<(ostream &os, const ModInt<MOD> &m){
      return os << m.x;
    }
    friend istream& operator>>(istream &is, ModInt<MOD> &m){
      long t;
      is >> t;
      m = ModInt<MOD>(t);
      return is;
    }
  };

snippet modint_use
  ModInt m(3);

snippet lagrangeinterpolationN_def
  template <typename T>
  struct LagrangeInterpolationN{
    int n = 0;
    vector<T> ifrac;
    vector<T> y;
    vector<T> coeff;
    LagrangeInterpolationN(const vector<T> &y): y(y){
      n = y.size() - 1;
      ifrac.resize(n + 1);
      coeff.resize(n + 1);
      ifrac[0] = T(1);
      for(int i = 1; i <= n; i++){
        ifrac[i] = T(i) * ifrac[i-1];
      }
      for(int i = 0; i <= n; i++)ifrac[i] = ifrac[i].inverse();
      for(int i = 0; i <= n; i++){
        T tmp = y[i] * ifrac[i] * ifrac[n-i];
        if((n-i) % 2 == 1)tmp *= T(-1);
        coeff[i] = tmp;
      }
    }
    T val(int t){
      if(t >= 0 && t <= n)return y[t];
      T a = T(1);
      for(int i = 0; i <= n; i++){
        a = a * T(t - i);
      }
      T res = T(0);
      for(int i = 0; i <= n; i++){
        res += a * coeff[i] / T(t - i);
      }
      return res;
    }
  };

snippet lagrangeinterpolation_use
  LagrangeInterpolationN<ModInt<mod>> lin(a);
  lin.val(3);

snippet zalgo_def
  vector<int> zarray(const string &s){
    int n = s.size();
    vector<int> z(n, 0);
    int c = 0;
    for(int i = 1; i < n; i++){
      if(i + z[i - c] < c + z[c]){
        z[i] = z[i - c];
      }else{
        int j = max(0, c + z[c] - i);
        while(i + j < n && s[j] == s[i + j])j++;
        z[i] = j;
        c = i;
      }
    }
    z[0] = n;
    return z;
  }

snippet zalgo_use
  auto p = zarray(s);

snippet z_search_def
  vector<int> z_search(string s, string t){
    string u = t;
    u += "$";
    u += s;
    vector<int> z = zarray(u);
    vector<int> res;
    for(int i = 1; i < u.size(); i++){
      if(z[i] >= t.size())res.push_back(i - int(t.size()) - 1);
    }
    return res;
  }

snippet z_search_use
  auto p = z_search(s, t);

snippet factorial_def
  struct Factorial{
    int n;
    const int MOD = 1e9 + 7;
    vector<long long> fac;
    vector<long long> inv_;
    Factorial(int n): n(n){
      fac.resize(n + 1);
      inv_.resize(n + 1);
      calc_factorial();
      calc_inv();
    }
    void calc_factorial(){
      fac[0] = 1;
      for(int i = 1; i <= n; i++){
        fac[i] = i * fac[i-1] % MOD;
      }
    }
    void calc_inv(){
      inv_[n] = power<long long>(fac[n], MOD - 2, MOD);
      for(int i = n - 1; i >= 0; i--){
        inv_[i] = (i + 1) * inv_[i+1] % MOD;
      }
    }
    long long& operator[](size_t i){
      if(i < 0 || i > n){
        cerr << "list index out of range" << endl;
        abort();
      }
      return fac[i];
    }
    long long inv(size_t i){
      if(i < 0 || i > n){
        cerr << "list index out of range" << endl;
        abort();
      }
      return inv_[i];
    }
    long long comb(int n, int k){
      if(n < k)return 0;
      long long res = fac[n];
      res = res * inv_[n-k] % MOD;
      res = res * inv_[k] % MOD;
      return res;
    }
    long long perm(int n, int k){
      if(n < k)return 0;
      long long res = fac[n];
      res = res * inv_[n-k] % MOD;
      return res;
    }
    long long h(int n, int k){
      if(n == 0 && k == 0)return 1;
      return comb(n + k - 1, k);
    }
  };

snippet factorial_use
  Factorial fac(n);

snippet sbigint_def
  struct SBigInt{
    bool neg = false;
    BigInt b = 0;
    SBigInt(){}
    SBigInt(ll a): b(BigInt(abs(a))){
      if(a < 0)neg = true;
    }
    SBigInt(const string &s){
      string t = s;
      if(t[0] == '-'){
        neg = true;
        t = t.substr(1, t.size() - 1);
      }
      b = BigInt(t);
    }
    void check_zero(){
      if(b == ZERO)neg = false;
    }
    bool operator==(const SBigInt &r) const{
      return (neg == r.neg) && (b == r.b);
    }
    bool operator!=(const SBigInt &r) const{
      return (neg != r.neg) || (b != r.b);
    }
    SBigInt operator-() const{
      SBigInt res = *this;
      res.neg = !res.neg;
      res.check_zero();
      return res;
    }
  };

  SBigInt operator+(const SBigInt &x, const SBigInt &y){
    SBigInt res;
    if(x.neg == y.neg){
      res.b = x.b + y.b;
      res.neg = x.neg;
    }else{
      if(x.b > y.b){
        res.b = x.b - y.b;
        res.neg = x.neg;
      }else{
        res.b = y.b - x.b;
        res.neg = y.neg;
      }
    }
    res.check_zero();
    return res;
  }

  SBigInt operator-(const SBigInt &x, const SBigInt &y){
    SBigInt res = x + (- y);
    res.check_zero();
    return res;
  }

  SBigInt operator*(const SBigInt &x, const SBigInt &y){
    SBigInt res;
    res.neg = !(x.neg == y.neg);
    res.b = x.b * y.b;
    res.check_zero();
    return res;
  }

  SBigInt operator/(const SBigInt &x, const SBigInt &y){
    SBigInt res;
    res.neg = !(x.neg == y.neg);
    res.b = x.b / y.b;
    res.check_zero();
    return res;
  }

  ostream &operator<<(ostream &os, const SBigInt &b){
    if(b.neg)os << "-";
    os << b.b;
    return os;
  }

snippet sbigint_use
  SBigInt("-3");

snippet modinv_def
  template <typename T>
  T modinv(T a, T m){
    long long x = 0, y = 0;
    extgcd<long long>(a, m, x, y);
    x %= m;
    if(x < 0)x += m;
    return x;
  }

snippet modinv_use
  ll res = modinv(a, mod);

snippet modlog_def
  long long modlog(long long a, long long b, long long m){
    a %= m;
    b %= m;

    long long l = -1, r = m;
    while(r - l > 1){
      long long md = (l + r) / 2;
      if(md * md >= m)r = md;
      else l = md;
    }
    long long sm = r;

    map<long long, long long> mp;
    long long curr = 1;
    for(long long i = 0; i < sm; i++){
      mp[curr] = max(mp[curr], i);
      curr = curr * a % m;
    }

    long long A = power<long long>(modinv(a, m), sm, m);
    curr = b;
    for(long long i = 0; i < sm; i++){
      if(mp.find(curr) != mp.end()){
        long long res = i * sm + mp[curr];
        if(res > 0)return res;
      }
      curr = curr * A % m;
    }
    return -1;
  }

snippet modlog_use
  ll res = modlog(a, b, mod);

snippet garner_def
  template <typename T>
  long long garner(vector<T> b, vector<T> m, T MOD){
    m.emplace_back(MOD);
    vector<long long> coef(m.size(), 1);
    vector<long long> consts(m.size(), 0);
    for(int i = 0; i < b.size(); i++){
      long long t = ((b[i] - consts[i]) % m[i]) * modinv<long long>(coef[i], m[i]) % m[i];
      for(int j = i + 1; j < m.size(); j++){
        consts[j] = (consts[j] + t * coef[j] % m[j]) % m[j];
        coef[j] = coef[j] * m[i] % m[j];
      }
    }
    return consts.back();
  }

snippet garner_use
  long long res = garner(b, m, MOD);

snippet fft_def
  // f.size() should be the power of 2.
  void fft(vector<cd> &f, bool inv=false){
    int n = f.size();
    if(n == 1)return;
    vector<cd> f0(n / 2), f1(n / 2);
    for(int i = 0; i < n / 2; i++){
      f0[i] = f[i * 2];
      f1[i] = f[i * 2 + 1];
    }
    fft(f0, inv);
    fft(f1, inv);
    double th = M_PI * 2 / n;
    if(inv)th = - th;
    cd u(cos(th), sin(th)), ui(1, 0);
    for(int i = 0; i < n; i++){
      f[i] = f0[i%(n/2)] + ui * f1[i%(n/2)];
      ui = ui * u;
    }
  }

  void dft(vector<cd> &f){
    fft(f);
  }

  void idft(vector<cd> &f){
    fft(f, true);
    for(int i = 0; i < f.size(); i++)f[i] = f[i] / cd(f.size());
  }

snippet fft_use
  dft(f);
  idft(f);

snippet convolution_def
  template <typename T>
  vector<T> convolution(vector<T> &f, vector<T> &g){
    int n = 1;
    while(n < 2 * f.size() + 1)n *= 2;
    vector<cd> F(n, 0), G(n, 0);
    for(int i = 0; i < f.size(); i++)F[i] = cd(f[i]);
    for(int i = 0; i < g.size(); i++)G[i] = cd(g[i]);

    dft(F);
    dft(G);
    vector<cd> H(n);
    for(int i = 0; i < n; i++)H[i] = F[i] * G[i];
    idft(H);
    vector<T> h(n);
    for(int i = 0; i < n; i++){
      h[i] = T(round(H[i].real()));
    }
    return h;
  }

snippet convolution_use
  auto h = convolution(f, g);

snippet weightedunionfind_def
  template <typename T>
  struct WeightedUnionFind_{
    int n;
    vector<int> par;
    vector<int> rank;
    vector<T> diff_weight;
    WeightedUnionFind_(int n, T def=0): n(n){
      par.resize(n);
      rank.resize(n);
      diff_weight.resize(n);
      for(int i = 0; i < n; i++){
        par[i] = i;
        rank[i] = 0;
        diff_weight[i] = def;
      }
    }
    int find(int x){
      if(par[x] == x)return x;
      int r = find(par[x]);
      diff_weight[x] += diff_weight[par[x]];
      return par[x] = r;
    }
    T weight(int x){
      find(x);
      return diff_weight[x];
    }
    bool same(int x, int y){
      return find(x) == find(y);
    }
    bool unite(int x, int y, T w){
      w += weight(x), w -= weight(y);
      x = find(x), y = find(y);
      if(x == y)return false;
      if(rank[x] < rank[y])swap(x, y), w = - w;
      if(rank[x] == rank[y])rank[x]++;
      par[y] = x;
      diff_weight[y] = w;
      return true;
    }
    T diff(int x, int y){
      return weight(y) - weight(x);
    }
  };

  using WeightedUnionFind = WeightedUnionFind_<int>;

snippet weightedunionfind_use
  WeightedUnionFind wuf(n);

snippet bipartile_matching_def
  struct BGraph{
    int n, m;
    GraphI graph;
    BGraph(int n, int m): n(n), m(m){
      graph = GraphI(n + m + 2);
      for(int i = 0; i < n; i++){
        graph.adde(0, get_left_index(i), 1);
      }
      for(int i = 0; i < m; i++){
        graph.adde(get_right_index(i), n + m + 1, 1);
      }
    }
    int get_left_index(int i){
      return i + 1;
    }
    int get_right_index(int i){
      return i + n + 1;
    }
    void adde(int at, int to){
      graph.adde(get_left_index(at), get_right_index(to), 1);
    }
    int maximum_matching(){
      return graph.max_flow(0, n + m + 1);
    }
  };

snippet bipartile_matching_use
  BGraph graph(n);
  graph.maximum_matching();

snippet boruvka_def
  template <typename T>
  struct Graph{
    struct edge{
      int to;
      T cost;
      edge(int to, T cost): to(to), cost(cost){}
    };
    int n;
    vector<vector<edge>> edges;
    Graph(int n): n(n){ edges.resize(n);
    }
    void adde(int from, int to, T cost){
      edges[from].push_back(edge(to, cost));
      edges[to].push_back(edge(from, cost));
    }
    T boruvka(){
      T ans = 0;
      vector<vector<edge>> res(n);
      UnionFind uf(n);

      while(true){
        vector<pair<int, edge>> f;
        int c = 0;
        vector<int> id(n, -1);
        for(int i = 0; i < n; i++){
          if(id[i] == -1){
            id[i] = c;
            vector<int> C;
            queue<int> q;
            q.push(i);
            while(!q.empty()){
              int v = q.front(); q.pop();
              C.push_back(v);
              for(auto e: res[v]){
                if(id[e.to] == -1){
                  id[e.to] = c;
                  q.push(e.to);
                }
              }
            }
            c++;
            int from = -1, to = -1;
            T cost = -1;
            for(int j = 0; j < C.size(); j++){
              int v = C[j];
              for(auto e: edges[v]){
                if(id[e.to] != id[i]){
                  if(cost == -1 || cost > e.cost){
                    cost = e.cost;
                    to = e.to;
                    from = v;
                  }
                }
              }
            }
            if(cost != -1)f.push_back(make_pair(from, edge(to, cost)));
          }
        }
        if(c == 1)break;
        for(int i = 0; i < f.size(); i++){
          int u = f[i].first;
          int v = f[i].second.to;
          T cost = f[i].second.cost;
          if(!uf.same(u, v)){
            uf.unite(u, v);
            ans += cost;
            res[u].push_back(edge(v, cost));
            res[v].push_back(edge(u, cost));
          }
        }
      }
      return ans;
    }
  };

  using GraphI = Graph<int>;
  using GraphL = Graph<long long>;

snippet boruvka_use
  GraphI graph(n);
  graph.adde(from, to, cost);
  graph.boruvka();

snippet RMQ_use
  SegmentTreeL seg = SegmentTreeL(n, [](ll a, ll b){return min(a, b);},
      [](ll a,ll b){return b;}, INF, V);

snippet RSQ_use
  SegmentTreeL seg = SegmentTreeL(n, [](ll a, ll b){return a + b;},
      [](ll a,ll b){return a + b;}, 0, V);

snippet RUQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return b;}, NAN, [](ll a, ll b, int c){return b * c;}, vector<ll>(n, DEF));

snippet RAQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return a + b;}, 0, [](ll a, ll b, int c){return a + b * c;}, vector<ll>(n, DEF));

snippet RMQRUQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return min(a, b);},
      INF, [](ll a, ll b){return b;}, NAN, [](ll a, ll b, int c){return b;}, vector<ll>(n, DEF));

snippet RSQRAQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return a + b;}, 0, [](ll a, ll b, int c){return a + b * c;}, vector<ll>(n, DEF));

snippet RMQRAQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return min(a, b);},
      INF, [](ll a, ll b){return a + b;}, 0, [](ll a, ll b, int c){return a + b;}, vector<ll>(n, DEF));

snippet RSQRUQ_use
  LazySegmentTreeL seg = LazySegmentTreeL(n, [](ll a, ll b){return a + b;},
      0, [](ll a, ll b){return b;}, NAN, [](ll a, ll b, int c){return b * c;}, vector<ll>(n, DEF));

snippet euler_phi_def
  long long euler_phi(long long n){
    ll res = n;
    auto mp = factorize(n);
    const int MOD = 1e9 + 7;
    for(auto itr = mp.begin(); itr != mp.end(); ++itr){
      long long p = itr->first;
      res = res * ((p-1) * modinv<long long>(p, MOD) % MOD) % MOD;
    }
    return res;
  }

snippet euler_phi_use
  long long k = euler_phi(n);

snippet coordinate_compression_def
  template <typename T>
  struct CoordinateCompression{
    map<T, int> mp;
    vector<T> v;
    CoordinateCompression(vector<T> &x){
      v.resize(x.size());
      copy(x.begin(), x.end(), v.begin());
      sort(v.begin(), v.end());
      v.erase(unique(v.begin(), v.end()), v.end());
      for(int i = 0; i < v.size(); i++){
        mp[v[i]] = i;
      }
    }
  };

  using CoordinateCompressionI = CoordinateCompression<int>;
  using CoordinateCompressionL = CoordinateCompression<long long>;

snippet coordinate_compression_use
  CoordinateCompressionL cc(v);

snippet lmatrix_def
  template <int MOD = int(1e9+7)>
  struct LMatrix{
    vector<vector<long long>> v;
    int n, m;
    LMatrix(int n_, int m_ = -1): n(n_), m(m_){
      if(m < 0)m = n;
      v.resize(n);
      for(int i = 0; i < n; i++)v[i].resize(m);
    }
    void identity(){
      assert(n == m);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
          v[i][j] = (i == j ? 1: 0);
        }
      }
    }
    vector<long long> &operator[](size_t i){
      return v[i];
    }
    const vector<long long> &operator[](size_t i) const{
      return v[i];
    }
    LMatrix operator*(const LMatrix &r) const{
      assert(m == r.n);
      int l = r.m;
      LMatrix res(n, l);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < l; j++){
          res.v[i][j] = 0;
          for(int k = 0; k < m; k++){
            res.v[i][j] = (res.v[i][j] + v[i][k] * r.v[k][j] % MOD) % MOD;
          }
        }
      }
      return res;
    }
    LMatrix operator+(const LMatrix &r) const{
      assert(n == r.n);
      assert(m == r.m);
      LMatrix res(n, m);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
          res[i][j] = (v[i][j] + r[i][j]) % MOD;
        }
      }
      return res;
    }
    LMatrix operator-(const LMatrix &r) const{
      assert(n == r.n);
      assert(m == r.m);
      LMatrix res(n, m);
      for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
          res[i][j] = (v[i][j] - r[i][j]) % MOD;
          if(res[i][j] < 0)res[i][j] += MOD;
        }
      }
      return res;
    }
    template <typename T>
    LMatrix operator*(T a) const{
      LMatrix res = *this;
      for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
          res[i][j] = a * res[i][j] % MOD;
        }
      }
      return res;
    }
    LMatrix inv2() const{
      assert(n == 2 && m == 2);
      long long det = v[0][0] * v[1][1] % MOD - v[0][1] * v[1][0] % MOD;
      if(det < 0)det += MOD;
      assert(det != 0);
      LMatrix res(2, 2);
      long long inv = modinv(det, (long long)MOD);
      res[0][0] = v[1][1];
      res[1][1] = v[0][0];
      res[1][0] = - v[1][0];
      res[0][1] = - v[0][1];
      for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
          res[i][j] %= MOD;
          res[i][j] = res[i][j] * inv % MOD;
          if(res[i][j] < 0)res[i][j] += MOD;
        }
      }
      return res;
    }
  };

  template <typename T, int MOD = int(1e9+7)>
  LMatrix<MOD> operator*(T a, const LMatrix<MOD> b){
    return b * a;
  }

  template <int MOD = int(1e9+7)>
  LMatrix<MOD> powerm(LMatrix<MOD> &a, long long n){
    long long tmp = n;
    LMatrix<MOD> curr = a;
    LMatrix<MOD> res(a.n);
    res.identity();
    while(tmp){
      if(tmp % 2 == 1){
        res = res * curr;
      }
      curr = curr * curr;
      tmp /= 2;
    }
    return res;
  }

snippet lmatrix_use
  LMatrix<> l(2, 2);
