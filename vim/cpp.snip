snippet bw_def
  string bwt_sa(string s) {
    SAManberMyers sa = SAManberMyers(s);
    string res = "";
    for(int i = 0; i <= s.size(); i++){
      if(sa.sa[i] == 0)res += '$';
      else res += s[sa.sa[i] - 1];
    }
    return res;
  }

  string inverse_bwt(string s) {
    string res = "";
    vector<int> C = vector<int>(27, 0);
    vector<int> psi = vector<int>(s.size(), 0);
    int p = 0;

    for(int i = 0; i < s.size(); i++){
      if(s[i] == '$'){
        C[0]++;
      }
      else C[s[i] - 'a' + 1]++;
    }
    int sum = 0;
    for(int i = 0; i <= 26; i++){
      int tmp = C[i];
      C[i] = sum;
      sum += tmp;
    }

    for(int i = 0; i < s.size(); i++){
      int c;
      if(s[i] == '$')c = 0;
      else c = int(s[i] - 'a' + 1);
      psi[C[c]] = i;
      C[c]++;
    }

    for(int i = 0; i < s.size(); i++){
      p = psi[p];
      res += s[p];
    }

    return res.substr(1, res.size() - 1);
  }

snippet bw_use
  string tb = bwt_sa(s);

snippet suffixarray_use
  SAManberMyers sa = SAManberMyers(s);

snippet suffixarray_def
  typedef struct SAManberMyers_ {
    string s;
    vector<int> rank;
    vector<int> tmp;
    vector<int> sa;
    int n, k;
    SAManberMyers_(string ss){
      s = ss;
      n = s.size();
      rank.resize(n + 1);
      tmp.resize(n + 1);
      sa.resize(n + 1);
      k = 0;

      // construct suffix array
      construct();
    }
    bool comp(const int &a, const int &b){
      if(rank[a] != rank[b])return rank[a] < rank[b];
      int ra = a + k <= n ? rank[a + k] : -1;
      int rb = b + k <= n ? rank[b + k] : -1;
      return ra < rb;
    }
    void construct(){
      for(int i = 0; i <= n; i++){
        sa[i] = i;
        rank[i] = i < n ? s[i] : -1;
      }

      for(k = 1; k <= n; k *= 2){
        sort(sa.begin(), sa.end(), [this] (const int &a, const int &b) {return comp(a, b);});

        tmp[sa[0]] = 0;
        for(int i = 1; i <= n; i++){
          tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1], sa[i]) ? 1 : 0);
        }
        for(int i = 0; i <= n; i++){
          rank[i] = tmp[i];
        }
      }
    }
  } SAManberMyers;

snippet brute_search_use
  res = find_text(s, t);

snippet kmp_search_use
  res = kmp_search(s, t);

snippet bm_search_use
  res = bm_search(s, t);

snippet sa_search_use
  res = sa_search(s, t);

snippet brute_search_def
  vector<int> find_text(string s, string t) {
    vector<int> res;
    for(int i = 0; i + t.size() <= s.size(); i++){
      bool flag = true;
      for(int j = 0; j < t.size(); j++){
        if(s[i + j] != t[j]){
          flag = false;
          break;
        }
      }
      if(flag)res.push_back(i);
    }
    return res;
  }

snippet kmp_search_def
  vector<int> kmp_table(string t){
    vector<int> res = vector<int>(t.size(), 0);
    int j = 0;
    for(int i = 1; i < t.size(); i++){
      if(t[i] == t[j]){
        j++;
      }else{
        j = 0;
      }
      res[i] = j;
    }
    return res;
  }

  // s: text, t: pattern
  vector<int> kmp_search(string s, string t){
    vector<int> res;
    vector<int> shift = kmp_table(t);

    // i: text index, p: pattern index
    int i = 0, p = 0;
    while(i < s.size() && p < t.size()){
      if(s[i] == t[p]){
        i++;
        p++;
      }else if(p == 0){
        i++;
      }else{
        p = shift[p - 1];
      }
      if(p == t.size()){
        res.push_back(i - p);
        p = shift[p - 1];
      }
    }

    return res;
  }

snippet bm_search_def
  // s: text, t: pattern
  vector<int> bm_search(string s, string t){
    vector<int> res;
    unordered_map<char, int> mp;
    for(int i = 0; i < t.size(); i++){
      mp[t[i]] = t.size() - 1 - i;
    }
    // i: text index, p: pattern index
    int i = t.size() - 1, p = t.size() - 1;
    while(i < s.size() && p < t.size()){
      if(s[i] == t[p]){
        i--;
        p--;
      }else{
        if(mp.find(s[i]) == mp.end()){
          i += t.size();
        }else{
          if(p >= t.size() - 1 - mp[s[i]])i += mp[s[i]];
          else i += t.size() - p + 1;
        }
        p = t.size() - 1;
      }
      if(p < 0){
        res.push_back(i + 1);
        i += t.size() + 1;
        p = t.size() - 1;
      }
    }

    return res;
  }

snippet sa_search_def
  vector<int> sa_search(string s, string t){
    SAManberMyers sa(s);
    vector<int> res;
    t += "$";
    s += "$";
    int ld = -1;
    int rd = sa.sa.size() - 1;
    while(rd - ld > 1){
      int md = (rd + ld) / 2;
      if(s.substr(sa.sa[md]) < t)ld = md;
      else rd = md;
    }
    t = t.substr(0, t.size() - 1);
    while(true){
      if(s.substr(sa.sa[rd], t.size()) != t)break;
      res.push_back(sa.sa[rd]);
      rd++;
    }
    sort(res.begin(), res.end());
    return res;
  }
snippet BIT_use
  BITI bt(10);

snippet BIT_def
  template<typename T>
  struct BIT_{
    int n;
    vector<T> bit;
    BIT_(int n_){
      n = n_;
      bit = vector<T>(n+1, 0);
    }
    void add(int a, T w){
      for(int x = a; x < n; x |= (x + 1)){
        bit[x] += w;
      }
    }
    T sum(int a){
      T res = 0;
      for(int x = a; x >= 0; x = (x & (x + 1)) - 1){
        res += bit[x];
      }
      return res;
    }
  };

  typedef struct BIT_<int> BITI;
  typedef struct BIT_<long long> BITL;

snippet segtree_use
  SegmentTreeI seg = SegmentTreeI(n, [](int a, int b){return min(a, b);},
      [](int a,int b){return b;}, INT_MAX, v);

snippet segtree_def
  template<typename T, typename E>
  struct SegmentTree_ {
    function<T(T, T)> f;
    function<T(T, E)> g;
    int n;
    T def;
    vector<T> vec;
    SegmentTree_(){}
    SegmentTree_(int n_, function<T(T, T)> f_, function<T(T, E)> g_, T def_, vector<T> v=vector<T>()){
      f = f_;
      g = g_;
      def = def_;

      // initialize vector
      n = 1;
      while(n < n_){
        n *= 2;
      }
      vec = vector<T>(2*n -1, def);

      // initialize segment tree
      for(int i = 0; i < v.size(); i++){
        vec[i + n - 1] = v[i];
      }
      for(int i = n - 2; i >= 0; i--){
        vec[i] = f(vec[2*i+1], vec[2*i+2]);
      }
    }
    void update(int k, E val){
      k = k + n - 1;
      vec[k] = g(vec[k], val);
      while(k > 0){
        k = (k - 1) / 2;
        vec[k] = f(vec[2*k+1], vec[2*k+2]);
      }
    }
    // [l, r) -> [a, b) (at k)
    T query(int a, int b, int k, int l, int r){
      if(r <= a || b <= l)return def;
      if(a <= l && r <= b)return vec[k];
      T ld = query(a, b, 2*k+1, l, (l+r)/2);
      T rd = query(a, b, 2*k+2, (l+r)/2, r);
      return f(ld, rd);
    }
    T query(int a, int b){
      return query(a, b, 0, 0, n);
    }
  };

  template<typename T, typename E>
  using SegmentTree = struct SegmentTree_<T, E>;
  using SegmentTreeI = SegmentTree<int, int>;

snippet unionfind_use
  UnionFind uf(10);

snippet unionfind_def
  typedef struct UnionFind_ {
    vector<int> par;
    vector<int> rank_;
    UnionFind_(int n): rank_(n, 0) {
      for(int i = 0; i < n; i++)par.push_back(i);
    }
    int find(int x) {
      if(par[x] == x)return x;
      else return par[x] = find(par[x]);
    }
    bool same(int x, int y) {
      if(find(x) == find(y))return true;
      else return false;
    }
    bool unite(int x, int y){
      int xp = find(x);
      int yp = find(y);
      if(xp == yp)return false;
      if(rank_[xp] > rank_[yp])par[yp] = xp;
      else if(rank_[xp] < rank_[yp])par[xp] = yp;
      else {
        par[yp] = xp;
        rank_[xp]++;
      }
      return true;
    }
  } UnionFind;

snippet fordfulkerson_use
  GraphI graph(5);
  int res = graph.max_flow(0, 4);

snippet fordfulkerson_def
  template <typename T>
  struct edge {int to; T cap; int rev;};

  template <typename T>
  struct Graph_ {
    int n;
    vector<bool> used;
    vector<vector<edge<T>> > vec;
    Graph_(int ns) {
      n = ns;
      used.resize(n);
      vec.resize(n);
    }
    void adde(int at, int to, T cap){
      vec[at].pb((edge<T>){to, cap, (int)vec[to].size()});
      vec[to].pb((edge<T>){at, 0, (int)vec[at].size() - 1});
    }
    T dfs(int s, int t, T f){
      if(s == t)return f;
      used[s] = true;
      for(int i = 0; i < vec[s].size(); i++){
        edge<T> &e = vec[s][i];
        if(!used[e.to] && e.cap > 0){
          int d = dfs(e.to, t, min(f, e.cap));
          if(d > 0){
            e.cap -= d;
            vec[e.to][e.rev].cap += d;
            return d;
          }
        }
      }
      return 0;
    }
    T min_cut(int s, int t){
      return max_flow(s, t);
    }
    T max_flow(int s, int t){
      T inf = numeric_limits<T>::max();
      T flow = 0;

      while(true){
        fill(used.begin(), used.end(), false);
        int f = dfs(s, t, inf);
        if(f == 0)return flow;
        flow += f;
      }
    }
  };

  typedef Graph_<int> GraphI;
  typedef Graph_<ll> GraphL;

snippet dijkstra_use
  GraphI graphi(4);
  graphi.dijkstra(1, 3);

snippet dijkstra_def
  template <typename T>
  struct Graph_ {
    int n;
    vector<vector<pair<int, T> > > edge;
    vector<T> dis;
    Graph_(int ns) {
      n = ns;
      edge.resize(n);
      dis.resize(n);
    }
    void dijkstra(int s){
      dijkstra(s, 0);
    }
    T dijkstra(int s, int t){
      // initialize
      fill(dis.begin(), dis.end(), -1);
      vector<bool> used;
      used.resize(n);
      fill(used.begin(), used.end(), false);
      dis[s] = 0;
      // dijkstra
      priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > q;
      q.push(make_pair(0, s));
      while(!q.empty()){
        pair<T, int> p = q.top(); q.pop();
        int at = p.second;
        T distance = p.first;
        if(used[at])continue;
        used[at] = true;
        for(auto itr = edge[at].begin(); itr != edge[at].end(); ++itr){
          int to = (*itr).first;
          T cost = (*itr).second;
          if(used[to])continue;
          if(dis[to] == -1 || dis[to] > distance + cost){
            q.push(make_pair(distance + cost, to));
            dis[to] = distance + cost;
          }
        }
      }
      return dis[t];
    }
    void adde(int at, int to, T cost){
      edge[at].push_back(make_pair(to, cost));
    }
    [[deprecated("This function takes O(edge[at].size()).")]]
    void remove(int at, int to){
      int index = -1;
      for(int i = 0; i < edge[at].size(); i++){
        if(edge[at][i].first == to){
          index = i;
          break;
        }
      }
      edge[at].erase(edge[at].begin() + index);
    }
  };

  typedef struct Graph_<int> GraphI;
  typedef struct Graph_<ll> GraphL;
  typedef struct Graph_<double> GraphD;

snippet warshallfloyd_use
  GraphI graphi(4);
  graphi.warshall_floyd();

snippet warshallfloyd_def
  template <typename T>
  struct Graph_ {
    int n;
    vector<vector<T> > d;
    vector<vector<int> > path;
    Graph_(int ns) {
      n = ns;
      d = vector<vector<T> >(n, vector<T>(n, numeric_limits<T>::max() / 10));
      path = vector<vector<int> >(n, vector<int>(n, -1));
      for(int i = 0; i < n; i++)d[i][i] = 0;
    }
    void warshall_floyd(){
      for(int k = 0; k < n; k++){
        for(int i = 0; i < n; i++){
          for(int j = 0; j < n; j++){
            if(d[i][j] > d[i][k] + d[k][j]){
              d[i][j] = d[i][k] + d[k][j];
              path[i][j] = k;
            }
          }
        }
      }
    }
    void adde(int at, int to, T cost){
      d[at][to] = cost;
    }
  };

  typedef struct Graph_<int> GraphI;
  typedef struct Graph_<ll> GraphL;

snippet gcd_use
  gcd<int>(2, 3);

snippet extgcd_use
  extgcd<int>(3, 2, x, y);

snippet chinesereminder_use
  pair<int, int> p = chinese_reminder_theorem(b, m);

snippet gcd_def
  template<typename T>
  T gcd(T a, T b) {
    if(a > b)return gcd(b, a);
    if(a == 0)return b;
    return gcd(b % a, a);
  }

snippet extgcd_def
  template<typename T>
  T extgcd(T a, T b, T &x, T &y){
    T d = a;
    if(b != 0){
      d = extgcd(b, a % b, y, x);
      y -= (a / b) * x;
    }else{
      x = 1, y = 0;
    }
    return d;
  }

snippet chinesereminder_def
  template<typename T>
  pair<T, T> chinese_reminder_theorem(vector<T> b, vector<T> m){
    T r = 0, M = 1;
    for(int i = 0; i < b.size(); i++){
      T x, y;
      T d = extgcd<T>(M, m[i], x, y);
      if((b[i] - r) % d != 0)return make_pair(0, -1);
      T tmp = (b[i] - r) / d * x % (m[i] / d);
      r += M * tmp;
      M *= m[i] / d;
    }
    return make_pair(r % M, M);
  }

snippet convexhulltrick_use
  ConvexHullTrickI cht;
  cht.add(make_pair(2, 0));
  cht.val(2);

snippet convexhulltrick_def
  template <typename T>
  struct ConvexHullTrick_ {
    vector<pair<T, T> > lines;
    function<bool(T l, T r)> comp;
    ConvexHullTrick_(function<bool(T l, T r)> comp_=[](T l, T r){return l >= r;}): comp(comp_){}
    bool isnot_require(pair<T, T> l1, pair<T, T> l2, pair<T, T> l3){
      if(l1 < l3)swap(l1, l3);
      return (l3.second - l2.second) * (l2.first - l1.first) >= (l2.second - l1.second) * (l3.first - l2.first);
    }
    void add(pair<T, T> p){
      while(lines.size() >= 2 && isnot_require(*(lines.end()-2), *(lines.end()-1), p))lines.pop_back();
      lines.push_back(p);
    }
    T f(int i, T x){
      return lines[i].first * x + lines[i].second;
    }
    T val(T x){
      int ld = -1;
      int rd = lines.size() - 1;
      while(rd - ld > 1){
        int md = (rd + ld) / 2;
        if(comp(f(md, x), f(md + 1, x)))ld = md;
        else rd = md;
      }
      return f(rd, x);
    }
  };

  using ConvexHullTrickI = ConvexHullTrick_<int>;
  using ConvexHullTrickL = ConvexHullTrick_<long long>;

snippet crossing_use
  crossing(mk(1, 3), mk(3, 1), mk(0, 0), mk(1, 1));

snippet convexhull_use
  vector<Pd> ch = convex_hull(vec);

snippet crossing_def
  bool crossing(P p1, P p2, P q1, P q2){
    double pq1 = (q1.first - p1.first) * (q2.second - p1.second)
      - (q1.second - p1.second) * (q2.first - p1.first);
    double pq2 = (q1.first - p2.first) * (q2.second - p2.second)
      - (q1.second - p2.second) * (q2.first - p2.first);
    double qp1 = (p1.first - q1.first) * (p2.second - q1.second)
      - (p1.second - q1.second) * (p2.first - q1.first);
    double qp2 = (p1.first - q2.first) * (p2.second - q2.second)
      - (p1.second - q2.second) * (p2.first - q2.first);
    return (pq1 * pq2 < EPS && qp1 * qp2 < EPS);
  }

snippet convex_hull_def
  double cross(const Pd &o, const Pd &a, const Pd &b){
    return (a.first - o.first) * (b.second - o.second) - (a.second - o.second) * (b.first - o.first);
  }

  vector<Pd> convex_hull(vector<Pd> vec){
    int n = vec.size(), k = 0;
    if(n < 3)return vec;

    vector<Pd> ch(2 * n);
    sort(vec.begin(), vec.end());

    // lower
    for(int i = 0; i < n; i++){
      while(k >= 2 && cross(ch[k-2], ch[k-1], vec[i]) <= 0.)k--;
      ch[k++] = vec[i];
    }

    // upper
    for(int i = n - 1, t = k + 1; i > 0; --i){
      while(k >= t && cross(ch[k-2], ch[k-1], vec[i-1]) <= 0.)k--;
      ch[k++] = vec[i-1];
    }

    ch.resize(k - 1);
    return ch;

  }

snippet power_use
  power(2, 3, mod);

snippet inverse_use
  inverse(1, mod);

snippet power_def
  template <typename T>
  T power(T a, T n, T mod) {
    T res = 1;
    T tmp = n;
    T curr = a;
    while(tmp){
      if(tmp % 2 == 1){
        res = (T)((ll)res * curr % mod);
      }
      curr = (T)((ll)curr * curr % mod);
      tmp >>= 1;
    }
    return res;
  }

snippet inverse_def
  // this function can be used when x and mod is coprime
  template <typename T>
  T inverse(T x, T mod) {
    return power<T>(x, mod - 2, mod);
  }

snippet is_prime_use
  is_prime(23);

snippet list_prime_use
  vector<int> p = list_prime(15);

snippet is_prime_def
  template <typename T>
  bool is_prime(T x){
    if(x == 1)return false;
    for(ll i = 2; i * i <= x; i++){
      if(x % i == 0)return false;
    }
    return true;
  }

snippet list_prime_def
  template <typename T>
  vector<T> list_prime(T n){
    vector<T> res;
    vector<bool> i_prime = vector<bool>(n+1, true);
    for(ll i = 2; i <= n; i++){
      if(i_prime[i]){
        res.push_back(i);
        for(ll j = 2; j * i <= n; j++){
          i_prime[i * j] = false;
        }
      }
    }
    return res;
  }

snippet excout_use
  excout("a", "b", "c", 1);

snippet excout_def
  void excout(){
    cout << endl;
  }

  template <class Head, class... Tail>
  void excout(Head&& head, Tail&&... tail){
    if(sizeof...(tail) != 0)cout << head << " ";
    else cout << head;
    excout(forward<Tail>(tail)...);
  }

snippet succinctbitvector_use
  SuccinctBitVector sbv(9);

snippet SuccinctBitVector_def
  typedef struct SuccinctBitVector_ {
    int size;
    const int block = 32;
    const int l = 256;
    vector<uint32_t> B;
    vector<unsigned> L, S;
    SuccinctBitVector_(int size_){
      size = size_;
      B.assign((size + block - 1) / block, 0U);
      L.assign((size + l - 1) / l, 0U);
      S.assign((size + block - 1) / block, 0U);
    }
    void set_bit(int at){
      B[at / block] |= (1U << (at % block));
    }
    void build(){
      int true_count = 0;
      for(int i = 0; i < ((size + block - 1) / block) * block; i+=block){
        if(i % l == 0)L[i / l] = true_count;
        S[i / block] = true_count - L[i / l];
        true_count += __builtin_popcount(B[i / block]);
      }
    }
    bool access(int at){
      return (B[at / block] >> (at % block)) & 1U;
    }
    // this is rank1
    int rank(int at){
      return S[at / block] + __builtin_popcount((B[at / block] & ((1U << (at % block)) - 1)));
    }
    // this is select1
    int select(int x){
      // binary search for L
      int lld = 0, lrd = L.size();
      while(lrd - lld > 1){
        int md = (lld + lrd) / 2;
        if(L[md] <= x)lld = md;
        else lrd = md;
      }
      // binary search for S
      int sld = lld * l / block;
      int srd = min((lld + 1) * l / block, (int)S.size());
      while(srd - sld > 1){
        int md = (sld + srd) / 2;
        if(L[lld] + S[md] <= x)sld = md;
        else srd = md;
      }
      int tcount = L[lld] + S[sld];
      for(int i = 0; i < block; i++){
        if(((B[sld] >> i) & 1U) == 1)tcount++;
        if(tcount == x + 1)return sld * block + i;
      }
      return -1;
    }
  } SuccinctBitVector;

snippet louds_use
  GraphI graphi(8);
  LOUDS louds = construct_louds(graphi);

snippet louds_def
  typedef struct LOUDS_: SuccinctBitVector{
    LOUDS_(int n): SuccinctBitVector(2 * n + 2){}
    int select0(int x){
      // binary search for L
      int lld = 0, lrd = L.size();
      while(lrd - lld > 1){
        int md = (lld + lrd) / 2;
        if(md * l - L[md] <= x)lld = md;
        else lrd = md;
      }
      // binary search for S
      int sld = lld * l / block;
      int srd = min((lld + 1) * l / block, (int)S.size());
      while(srd - sld > 1){
        int md = (sld + srd) / 2;
        if(md * block - L[lld] - S[md] <= x)sld = md;
        else srd = md;
      }
      int tcount = sld * block - L[lld] - S[sld];
      for(int i = 0; i < block; i++){
        if(((B[sld] >> i) & 1U) == 0)tcount++;
        if(tcount == x + 1)return sld * block + i;
      }
      return -1;
    }
    int par(int x){
      int zero_x = select0(x);
      return rank(zero_x) - 1;
    }
    pair<int, int> child(int x){
      if(select(x) + 1 == select(x + 1))return make_pair(-1, -1);
      int ld = select(x) + 1;
      int rd = select(x + 1);
      return make_pair(ld - rank(ld), rd - 1 - rank(rd));
    }
  } LOUDS;


  LOUDS construct_louds(GraphI graph){
    LOUDS louds(graph.n);
    int curr = 2;
    louds.set_bit(1);
    queue<int> q;
    q.push(0);
    vector<bool> used = vector<bool>(graph.n, false);
    used[0] = true;
    while(!q.empty()){
      int p = q.front(); q.pop();
      for(pair<int, int> c: graph.edge[p]){
        if(!used[c.first]){
          used[c.first] = true;
          q.push(c.first);
          curr++;
        }
      }
      louds.set_bit(curr);
      curr++;
    }
    louds.build();
    return louds;
  }

snippet lazyseg_def
  template<typename T, typename E>
  struct LazySegmentTree_ {
    function<T(T, T)> f;
    function<E(E, E)> h;
    function<T(T, E, int)> p;
    int n;
    T def;
    E l_def;
    vector<T> vec;
    vector<E> lazy;
    LazySegmentTree_(){}
    LazySegmentTree_(int n_, function<T(T, T)> f_, T def_,
        function<E(E, E)> h_, E l_def_, function<T(T, E, int)> p_, vector<T> v=vector<T>()){
      f = f_;
      h = h_;
      p = p_;
      def = def_;
      l_def = l_def_;

      // initialize vector
      n = 1;
      while(n < n_){
        n *= 2;
      }
      vec = vector<T>(2*n-1, def);
      lazy = vector<E>(2*n-1, l_def);

      // initialize segment tree
      for(int i = 0; i < v.size(); i++){
        vec[i + n - 1] = v[i];
      }
      for(int i = n - 2; i >= 0; i--){
        vec[i] = f(vec[2*i+1], vec[2*i+2]);
      }
    }
    void eval(int k, int len){
      if(lazy[k] != l_def){
        if(k < n - 1){
          lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);
          lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);
        }
        vec[k] = p(vec[k], lazy[k], len);
        lazy[k] = l_def;
      }
    }
    E update(int a, int b, const E &val, int k, int l, int r){
      eval(k, r - l);
      if(r <= a || b <= l){
        return vec[k];
      }else if(a <= l && r <= b){
        lazy[k] = h(lazy[k], val);
        eval(k, r - l);
        return vec[k];
      }else{
        return vec[k] = f(update(a, b, val, 2*k+1, l, (l+r)/2),
            update(a, b, val, 2*k+2, (l+r)/2, r));
      }
    }
    E update(int a, int b, E val){
      return update(a, b, val, 0, 0, n);
    }
    // [l, r) -> [a, b) (at k)
    T query(int a, int b, int k, int l, int r){
      eval(k, r - l);
      if(r <= a || b <= l)return def;
      if(a <= l && r <= b)return vec[k];
      T ld = query(a, b, 2*k+1, l, (l+r)/2);
      T rd = query(a, b, 2*k+2, (l+r)/2, r);
      return f(ld, rd);
    }
    T query(int a, int b){
      return query(a, b, 0, 0, n);
    }
  };

  template<typename T, typename E>
  using LazySegmentTree = struct LazySegmentTree_<T, E>;
  using LazySegmentTreeI = LazySegmentTree<int, int>;

snippet lazyseg_use
  LazySegmentTreeI seg = LazySegmentTreeI(n, [](int a, int b){return a + b;},
      0, [](int a, int b){return a + b;}, 0, [](int a, int b, int c){return a + b * c;}, v);

snippet bipartile_def
  struct GraphI {
    int n;
    vector<int> color;
    vector<vector<int> > vec;
    GraphI(int ns) {
      n = ns;
      color.resize(n, 0);
      vec.resize(n);
    }
    void adde(int at, int to){
      vec[at].push_back(to);
    }
    bool is_bipartile(){
      for(int i = 0; i < n; i++){
        if(color[i] == 0){
          if(!dfs(i, 1)){
            return false;
          }
        }
      }
      return true;
    }
    bool dfs(int v, int c){
      color[v] = c;
      for(int i: vec[v]){
        if(color[i] == c){
          return false;
        }
        if(color[i] == 0 && !dfs(i, -c))return false;
      }
      return true;
    }
  };

snippet bipartile_use
  GraphI graph(3);
  graph.is_bipartile();

snippet topologicaldag_def
  struct Graph{
    int n;
    vector<vector<int> > edge;
    vector<int> in_deg;
    Graph(int n_){
      n = n_;
      edge.resize(n);
      in_deg.resize(n, 0);
    }
    void adde(int at, int to){
      edge[at].push_back(to);
      in_deg[to]++;
    }
    vector<int> topological_sort(){
      stack<int> st;
      for(int i = 0; i < n; i++){
        if(in_deg[i] == 0)st.push(i);
      }
      vector<int> res;
      while(st.size()){
        int at = st.top(); st.pop();
        res.push_back(at);
        for(int j: edge[at]){
          in_deg[j]--;
          if(in_deg[j] == 0)st.push(j);
        }
      }

      return res;
    }
  };

snippet topologicaldag_use
  Graph graph(7);
  vector<int> ts = graph.topological_sort();

snippet bellmanford_def
  template <typename T>
  struct edge{int from, to; T cost;};

  template <typename T>
  struct Graph{
    int n;
    vector<T> d;
    vector<edge<T>> es;
    Graph(int n_){
      n = n_;
      d.resize(n, numeric_limits<T>::max());
    }
    void adde(edge<T> e){
      es.push_back(e);
    }
    bool bellman_ford(int s){
      T maxim = numeric_limits<T>::max();
      fill(d.begin(), d.end(), maxim);
      d[s] = 0;
      for(int i = 0; i < n; i++){
        bool update = false;
        for(auto e: es){
          if(d[e.from] != maxim && d[e.to] > d[e.from] + e.cost){
            d[e.to] = d[e.from] + e.cost;
            update = true;
            if(i == n - 1)return false;
          }
        }
        if(!update)break;
      }
      return true;
    }
  };

snippet bellmanford_use
  Graph<ll> graphl(5);
  graphl.bellman_ford(0);

snippet prim_def
  template <typename T>
  struct Graph{
    int n;
    vector<vector<pair<int, T> > > es;
    vector<T> mincost;
    vector<bool> used;
    Graph(int n_){
      n = n_;
      es.resize(n);
      mincost.resize(n);
      used.resize(n);
    }
    void adde(int from, int to, T cost){
      es[from].push_back(make_pair(to, cost));
      es[to].push_back(make_pair(from, cost));
    }
    T prim(){
      fill(mincost.begin(), mincost.end(), numeric_limits<T>::max());
      fill(used.begin(), used.end(), false);
      T res = 0;
      priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > pq;
      mincost[0] = 0;
      pq.push(make_pair(0, 0));
      while(!pq.empty()){
        pair<T, int> p = pq.top(); pq.pop();
        if(used[p.second])continue;
        used[p.second] = true;
        res += p.first;
        for(auto e: es[p.second]){
          if(!used[e.first] && mincost[e.first] > e.second){
            mincost[e.first] = e.second;
            pq.push(make_pair(mincost[e.first], e.first));
          }
        }
      }
      return res;
    }
  };

  using GraphI = Graph<int>;

snippet prim_use
  GraphI graph(7);
  int cost = graph.prim();

snippet kruskal_def
  typedef struct UnionFind_ {
    vector<int> par;
    vector<int> rank_;
    UnionFind_(int n): rank_(n, 0) {
      for(int i = 0; i < n; i++)par.push_back(i);
    }
    int find(int x) {
      if(par[x] == x)return x;
      else return par[x] = find(par[x]);
    }
    bool same(int x, int y) {
      if(find(x) == find(y))return true;
      else return false;
    }
    bool unite(int x, int y){
      int xp = find(x);
      int yp = find(y);
      if(xp == yp)return false;
      if(rank_[xp] > rank_[yp])par[yp] = xp;
      else if(rank_[xp] < rank_[yp])par[xp] = yp;
      else {
        par[yp] = xp;
        rank_[xp]++;
      }
      return true;
    }
  } UnionFind;

  template <typename T>
  struct edge{
    int from;
    int to;
    T cost;
  };

  template <typename T>
  bool comp(const edge<T> &a, const edge<T> &b){
    return a.cost < b.cost;
  }

  template <typename T>
  struct Graph {
    int n;
    vector<edge<T>> es;
    Graph(int n_){
      n = n_;
    }
    void adde(int from, int to, T cost){
      es.push_back((edge<T>){from, to, cost});
    }
    T kruskal(){
      T res = 0;
      UnionFind uf(n);
      sort(es.begin(), es.end(), comp<T>);
      for(auto e: es){
        int from = e.from;
        int to = e.to;
        T cost = e.cost;
        if(uf.same(from, to))continue;
        res += cost;
        uf.unite(from, to);
      }

      return res;
    }
  };

  using GraphI = Graph<int>;

snippet kruskal_use
  GraphI graphi(7);
  graphi.kruskal();

snippet merge_def
  template <typename T>
  void merge(vector<T> &a, int l, int m, int r){
    int n1 = m - l;
    int n2 = r - m;
    vector<T> L, R;
    for(int i = 0; i < n1; i++)L.push_back(a[l+i]);
    for(int i = 0; i < n2; i++)R.push_back(a[m+i]);
    L.push_back(numeric_limits<T>::max());
    R.push_back(numeric_limits<T>::max());
    int i = 0, j = 0;
    for(int k = l; k < r; k++){
      if(L[i] <= R[j]){
        a[k] = L[i];
        i++;
      }else{
        a[k] = R[j];
        j++;
      }
    }
  }

  template <typename T>
  void merge_sort(vector<T> &a, int l, int r){
    if(l + 1 < r){
      int m = (l + r) / 2;
      merge_sort<T>(a, l, m);
      merge_sort<T>(a, m, r);
      merge<T>(a, l, m, r);
    }
  }

  template <typename T>
  void merge_sort(vector<T> &a){
    merge_sort<T>(a, 0, a.size());
  }

snippet merge_use
  merge_sort(vec);

snippet devisor_def
  template <typename T>
  vector<T> devisor(T n){
    vector<T> res;
    for(T i = 1; i * i <= n; i++){
      if(n % i == 0){
        res.push_back(i);
        if(n != i * i)res.push_back(n / i);
      }
    }
    sort(res.begin(), res.end());
    return res;
  }

snippet devisor_use
  vector<int> d = devisor(n);

snippet factorize_def
  template <typename T>
  map<T, int> factorize(T n){
    map<T, int> res;
    T tmp = n;
    for(T i = 2; i * i <= n; i++){
      while(tmp % i == 0){
        ++res[i];
        tmp /= i;
      }
    }
    if(tmp != 1)res[tmp] = 1;
    return res;
  }

snippet factorize_use
  map<int, int> mp = factorize(n);

snippet millar_rabin_def
  template <typename T>
  bool suspect(T a, int s, T d, T n){
    T x = power<T>(a, d, n);
    if(x == 1)return true;
    for(int r = 0; r < s; r++){
      if(x == n - 1)return true;
      x = x * x % n;
    }
    return false;
  }

  template <typename T>
  bool millar_rabin(T n){
    if(n <= 1 || (n > 2 && n % 2 == 0))return false;
    vector<ll> test = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    T d = n - 1;
    int s = 0;
    while(d % 2 == 0)s++, d /= 2;
    for(int i = 0; i < test.size() && test[i] < n; i++){
      if(!suspect<T>(test[i], s, d, n))return false;
    }
    return true;
  }

snippet millar_rabin_use
  bool b = millar_rabin(n)

snippet gauss_jordan_def
  template <typename T>
  struct Matrix{
    T EPS = (T)1e-10;
    vector<vector<T> > val;
    Matrix(int n, int m, T def = 0): val(n, vector<T>(m, def)){}
    inline vector<T> &operator[](size_t i){return val[i];};
    size_t size() const {return val.size();}
    int gauss_jordan(bool is_extended = false){
      int m = val.size(), n = val[0].size();
      int rank = 0;
      for(int col = 0; col < n; col++){
        if(col == n - 1 && is_extended)break;

        int pivot = -1;
        T ma = EPS;
        for(int row = rank; row < m; row++){
          if(abs(val[row][col]) > ma){
            ma = abs(val[row][col]);
            pivot = row;
          }
        }
        if(pivot == -1)continue;
        swap(val[rank], val[pivot]);

        T fac = val[rank][col];
        for(int col2 = 0; col2 < n; col2++){
          val[rank][col2] /= fac;
        }

        for(int row = 0; row < m; row++){
          if(row != rank && abs(val[row][col]) > EPS){
            T fac = val[row][col];
            for(int col2 = 0; col2 < n; col2++){
              val[row][col2] -= val[rank][col2] * fac;
            }
          }
        }

        rank++;
      }
      return rank;
    }
  };

snippet linear_eq_def
  template <typename T>
  vector<T> linear_eq(Matrix<T>& A, vector<T>& b){
    int m = A.size(), n = A[0].size();
    Matrix<T> M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);
    vector<T> res;
    for(int row = rank; row < m; row++){
      if(abs(M[row][n]) > M.EPS)return res;
    }
    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return res;
  }

snippet gauss_jordan_use
  int rank = M.gauss_jordan();

snippet linear_eq_use
  vector<T> res = linear_eq(A, b);

snippet gauss_jordanp_def
  template <typename T, int mod = int(1e9+7)>
  struct MatrixP{
    vector<vector<T> > val;
    MatrixP(int n, int m, T def = 0): val(n, vector<T>(m, def)){}
    inline vector<T> &operator[](size_t i){return val[i];};
    size_t size() const {return val.size();}
    int gauss_jordan(bool is_extended = false){
      int m = val.size(), n = val[0].size();
      int rank = 0;
      for(int row = 0; row < m; row++){
        for(int col = 0; col < n; col++){
          val[row][col] = (val[row][col] % mod + mod) % mod;
        }
      }
      for(int col = 0; col < n; col++){
        if(col == n - 1 && is_extended)break;

        int pivot = -1;
        for(int row = rank; row < m; row++){
          if(val[row][col] != 0){
            pivot = row;
            break;
          }
        }
        if(pivot == -1)continue;
        swap(val[rank], val[pivot]);

        T fac = power(val[rank][col], mod - 2, mod);
        for(int col2 = 0; col2 < n; col2++){
          val[rank][col2] * fac % mod;
        }

        for(int row = 0; row < m; row++){
          if(row != rank && val[row][col] != 0){
            T fac = val[row][col];
            for(int col2 = 0; col2 < n; col2++){
              val[row][col2] -= val[rank][col2] * fac % mod;
              if(val[row][col2])val[row][col2] += mod;
            }
          }
        }

        rank++;
      }
      return rank;
    }
  };

snippet gauss_jordanp_use
  int rank = M.gauss_jordan();

snippet linear_eqp_def
  template <typename T, int mod = int(1e9+7)>
  int linear_eq(MatrixP<T>& A, vector<T>& b, vector<T> &res){
    int m = A.size(), n = A[0].size();
    MatrixP<T, mod> M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);
    for(int row = rank; row < m; row++){
      if(M[row][n] != 0)return -1;
    }
    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return rank;
  }

snippet linear_eqp_use
  int rank = linear_eq(A, b, res);

snippet gauss_jordanb_def
  const int MAX_H = 510, MAX_W = 510;
  struct MatrixB {
    int H, W;
    bitset<MAX_W> val[MAX_H];
    MatrixB(int m = 1, int n = 1): H(m), W(n){}
    inline bitset<MAX_W>& operator[](size_t i){return val[i];}
    int gauss_jordan(bool is_extended = false){
      int rank = 0;
      for(int col = 0; col < W; col++){
        if(col == W - 1 && is_extended)break;
        int pivot = -1;
        for(int row = rank; row < H; row++){
          if(val[row][col]){
            pivot = row;
            break;
          }
        }
        if(pivot == -1)continue;
        swap(val[pivot], val[rank]);
        for(int row = 0; row < H; row++){
          if(row != rank && val[row][col])val[row] ^= val[rank];
        }
        rank++;
      }
      return rank;
    }
  };

snippet gauss_jordanb_use
  int rank = M.gauss_jordan();

snippet linear_eqb_def
  int linear_eq(MatrixB &A, vector<int> b, vector<int> & res){
    int m = A.H, n = A.W;
    MatrixB M(m, n + 1);
    for(int i = 0; i < m; i++){
      for(int j = 0; j < n; j++){
        M[i][j] = A[i][j];
      }
      M[i][n] = b[i];
    }
    int rank = M.gauss_jordan(true);

    for(int row = rank; row < m; row++){
      if(M[row][n])return -1;
    }

    res.assign(n, 0);
    for(int i = 0; i < rank; i++)res[i] = M[i][n];
    return rank;
  }

snippet linear_eqb_use
  int rank = M.linear_eq(A, b, res);

snippet treap_def
  template <typename T>
  struct Treap{
    random_device rnd;
    struct Node{
      T key;
      int pri;
      Node *l, *r;
      Node(T key, int pri): key(key), pri(pri), l(nullptr), r(nullptr){}
      ~Node(){
        delete l;
        delete r;
      }
    };
    using Tree = Node *;
    Tree root = nullptr;
    size_t _size = 0;

    Treap(){}
    size_t size(){
      return _size;
    }
    void split(Tree t, T key, Tree &l, Tree &r){
      if(!t){
        l = r = nullptr;
      }else if(key < t->key){
        split(t->l, key, l, t->l);
        r = t;
      }else{
        split(t->r, key, t->r, r);
        l = t;
      }
    }
    void merge(Tree &t, Tree l, Tree r){
      if(!l)return r;
      if(!r)return l;
      if(l->pri > r->pri){
        merge(l->r, l->r, r);
        t = l;
      }else{
        merge(r->l, l, r->l);
        t = r;
      }
    }
    void insert(Tree &t, Tree n){
      if(!t)t = n;
      else if(n->pri > t->pri){
        split(t, n->key, n->l, n->r);
        t = n;
      }else{
        if(n->key < t->key)insert(t->l, n);
        else insert(t->r, n);
      }
    }
    void insert(T key){
      insert(root, new Node(key, rnd()));
      _size++;
    }
    void erase(Tree &t, T key){
      if(t->key == key){
        merge(t, t->l, t->r);
        _size--;
      }else{
        if(key < t->key)erase(t->l, key);
        else erase(t->r, key);
      }
    }
    void erase(T key){
      erase(root, key);
    }
    bool find(Tree &t, T key){
      if(!t)return false;
      else if(t->key == key)return true;
      else{
        if(key < t->key)return find(t->l, key);
        else return find(t->r, key);
      }
    }
    bool find(T key){
      return find(root, key);
    }
  };

snippet treap_use
  Treap<int> tr;

snippet fast_zeta_def
  /*
   * f(U) = \sum_{U\in T}f(T)
   * for f(U) = \sum_{T\in U}f(T), use f[j | i] += f[j];
   */
  template <typename T>
  void fast_zeta(vector<T> &f){
    int n = f.size();
    for(int i = 1; i < n; i<<=1){
      for(int j = 0; j < n; j++){
        if((j & i) == 0){
          f[j] += f[j | i];
        }
      }
    }
  }

snippet fast_zeta_use
  fast_zeta(vec);

snippet fast_moebius_def
  /*
   * f(U) = \sum_{U\in T}(-1)^(|T\U|)f(T)
   * for f(U) = \sum_{U\in T}f(T), use f[j | i] -= f[j];
   */
  template <typename T>
  void fast_moebius(vector<T> &f){
    int n = f.size();
    for(int i = 1; i < n; i<<=1){
      for(int j = 0; j < n; j++){
        if((j & i) == 0){
          f[j] -= f[j | i];
        }
      }
    }
  }

snippet fast_moebius_use
  fast_moebius(vec);
